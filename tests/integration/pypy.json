{
  "entries": [
    {
      "author": "Corbin",
      "content": [
        {
          "type": "text/html",
          "value": "h3 id=\"introduction\"Introduction/h3\npThis post started as a quick note summarizing a recent experiment I carried\nout upon a small RPython interpreter by rewriting it in an uncommon style. It\nis written for folks who have already written some RPython and want to take a\ndeeper look at interpreter architecture./p\npSome experiments are about finding solutions to problems. This experiment is\nabout taking a solution which is already well-understood and applying it in\nthe context of RPython to find a new approach. As we will see, there is no\nreal change in functionality or the number of clauses in the interpreter; it's\nmore like a comparison between endo- and exoskeletons, a different arrangement\nof equivalent bones and plates./p\nh3 id=\"overview\"Overview/h3\npAn RPython interpreter for a programming language generally does three or four\nthings, in order:/p\nol\nliRead and parse input programs/li\nliEncode concrete syntax as abstract syntax/li\nliemOptionally/em, optimize or reduce the abstract syntax/li\nliEvaluate the abstract syntax: read input data, compute, print output data,\n   etc./li\n/ol\npToday we'll look at abstract syntax. Most programming languages admit a\na href=\"https://en.wikipedia.org/wiki/Parse_tree\"concrete parse tree/a which is\nreadily abstracted to provide an a href=\"https://en.wikipedia.org/wiki/Abstract_syntax_tree\"abstract syntax\ntree/a (AST). The AST is\nusually encoded with the eminitial/em style of encoding. An initial encoding can\nbe transformed into any other encoding for the same AST, looks like a\nhierarchy of classes, and is implemented as a static structure on the heap./p\npIn contrast, there is also a emfinal/em encoding. A final encoding can be\ntransformed into by any other encoding, looks like an interface for the\nactions of the interpreter, and is implemented as an unwinding structure on\nthe stack. From the RPython perspective, Python builtin modules like codeos/code or\ncodesys/code are final encodings for features of the operating system; the underlying\nimplementation is different when translated or untranslated, but the interface\nused to access those features does not change./p\npIn RPython, an initial encoding is built from a hierarchy of classes. Each\nclass represents a type of tree nodes, corresponding to a parser production in\nthe concrete parse tree. Each class instance therefore represents an\nindividual tree node. The fields of a class, particularly those filled during\ncode.__init__()/code, store pre-computed properties of each node; methods can be used\nto compute node properties on demand. This seems like an obvious and simple\napproach; what other approaches could there be? We need an example./p\nh3 id=\"final-encoding-of-brainfuck\"Final Encoding of Brainfuck/h3\npWe will consider a href=\"https://esolangs.org/wiki/Brainfuck\"Brainfuck/a, a simple\nTuring-complete programming language. An example Brainfuck program might be:/p\ndiv class=\"code\"pre class=\"code literal-block\"span class=\"k\"[/spanspan class=\"nb\"-/spanspan class=\"k\"]/span\n/pre/div\n\npThis program is built from a loop and a decrement, and sets a cell to zero. In\nan initial encoding which follows the a href=\"https://esolangs.org/wiki/Algebraic_Brainfuck\"algebraic semantics of\nBrainfuck/a, the program could\nbe expressed by applying class constructors to build a structure on the heap:/p\ndiv class=\"code\"pre class=\"code literal-block\"span class=\"n\"Loop/spanspan class=\"p\"(/spanspan class=\"n\"Plus/spanspan class=\"p\"(/spanspan class=\"o\"-/spanspan class=\"mi\"1/spanspan class=\"p\"))/span\n/pre/div\n\npA final encoding is similar, except that class constructors are replaced by\nmethods, the structure is built on the stack, and we are parameterized over\nthe choice of class:/p\ndiv class=\"code\"pre class=\"code literal-block\"span class=\"k\"lambda/span span class=\"bp\"cls/spanspan class=\"p\":/span span class=\"bp\"cls/spanspan class=\"o\"./spanspan class=\"n\"loop/spanspan class=\"p\"(/spanspan class=\"bp\"cls/spanspan class=\"o\"./spanspan class=\"n\"plus/spanspan class=\"p\"(/spanspan class=\"o\"-/spanspan class=\"mi\"1/spanspan class=\"p\"))/span\n/pre/div\n\npIn ordinary Python, transforming between these would be trivial, and mostly is\na matter of passing around the appropriate class. Indeed, initial and final\nencodings are equivalent; we'll return to that fact later. However, in RPython,\nall of the types must line up, and classes must be determined before\ntranslation. We'll need to monomorphize our final encodings, using some\nRPython tricks later on. Before that, let's see what an actual Brainfuck\ninterface looks like, so that we can cover all of the difficulties with final\nencoding./p\npBefore we embark, please keep in mind that local code doesn't know what codecls/code\nis. There's no type-safe way to inspect an arbitrary semantic domain. In the\ninitial-encoded version, we can ask codeisinstance(bf, Loop)/code to see whether an\nAST node is a loop, but there simply isn't an equivalent for final-encoded\nASTs. So, there is an implicit challenge to think about: how do we evaluate a\nprogram in an arbitrary semantic domain? For bonus points, how do we optimize\na program without inspecting the types of its AST nodes?/p\npWhat follows is a dissection of\na href=\"https://github.com/rpypkgs/rpypkgs/blob/d439d225b79ac82e009a5f1cd1c670f00356464c/bf/bf.py\"this/a\nmodule at the given revision. Readers may find it satisfying to read the\nentire interpreter top to bottom first; it is less than 300 lines./p\nh4 id=\"core-functionality\"Core Functionality/h4\npFinal encoding is given as methods on an interface. These five methods\ncorrespond precisely to the summands of the algebra of Brainfuck./p\ndiv class=\"code\"pre class=\"code literal-block\"span class=\"k\"class/span span class=\"nc\"BF/spanspan class=\"p\"(/spanspan class=\"nb\"object/spanspan class=\"p\"):/span\n    span class=\"c1\"# Other methods elided/span\n    span class=\"k\"def/span span class=\"nf\"plus/spanspan class=\"p\"(/spanspan class=\"bp\"self/spanspan class=\"p\",/span span class=\"n\"i/spanspan class=\"p\"):/span span class=\"k\"pass/span\n    span class=\"k\"def/span span class=\"nf\"right/spanspan class=\"p\"(/spanspan class=\"bp\"self/spanspan class=\"p\",/span span class=\"n\"i/spanspan class=\"p\"):/span span class=\"k\"pass/span\n    span class=\"k\"def/span span class=\"nf\"input/spanspan class=\"p\"(/spanspan class=\"bp\"self/spanspan class=\"p\"):/span span class=\"k\"pass/span\n    span class=\"k\"def/span span class=\"nf\"output/spanspan class=\"p\"(/spanspan class=\"bp\"self/spanspan class=\"p\"):/span span class=\"k\"pass/span\n    span class=\"k\"def/span span class=\"nf\"loop/spanspan class=\"p\"(/spanspan class=\"bp\"self/spanspan class=\"p\",/span span class=\"n\"bfs/spanspan class=\"p\"):/span span class=\"k\"pass/span\n/pre/div\n\npNote that the code.loop()/code method takes another program as an argument.\nInitial-encoded ASTs have other initial-encoded ASTs as fields on class\ninstances; final-encoded ASTs have other final-encoded ASTs as parameters\nto interface methods. RPython infers all of the types, so the reader has to\nknow that codei/code is usually an integer while codebfs/code is a sequence of Brainfuck\noperations./p\npWe're using a class to implement this functionality. Later, we'll treat it as\na mixin, rather than a superclass, to avoid typing problems./p\nh4 id=\"monoid\"Monoid/h4\npIn order to optimize input programs, we'll need to represent the underlying\na href=\"https://en.wikipedia.org/wiki/Monoid\"monoid/a of Brainfuck programs. To do\nthis, we add the signature for a monoid:/p\ndiv class=\"code\"pre class=\"code literal-block\"span class=\"k\"class/span span class=\"nc\"BF/spanspan class=\"p\"(/spanspan class=\"nb\"object/spanspan class=\"p\"):/span\n    span class=\"c1\"# Other methods elided/span\n    span class=\"k\"def/span span class=\"nf\"unit/spanspan class=\"p\"(/spanspan class=\"bp\"self/spanspan class=\"p\"):/span span class=\"k\"pass/span\n    span class=\"k\"def/span span class=\"nf\"join/spanspan class=\"p\"(/spanspan class=\"bp\"self/spanspan class=\"p\",/span span class=\"n\"l/spanspan class=\"p\",/span span class=\"n\"r/spanspan class=\"p\"):/span span class=\"k\"pass/span\n/pre/div\n\npThis is technically a a href=\"https://en.wikipedia.org/wiki/Magma_(algebra)\"unital\nmagma/a, since RPython doesn't\nsupport algebraic laws, but we will enforce the algebraic laws later on during\noptimization. We also want to make use of the folklore that a href=\"https://en.wikipedia.org/wiki/Free_monoid\"free\nmonoids/a are lists, allowing\ncallers to pass a list of actions which we'll reduce with recursion:/p\ndiv class=\"code\"pre class=\"code literal-block\"span class=\"k\"class/span span class=\"nc\"BF/spanspan class=\"p\"(/spanspan class=\"nb\"object/spanspan class=\"p\"):/span\n    span class=\"c1\"# Other methods elided/span\n    span class=\"k\"def/span span class=\"nf\"joinList/spanspan class=\"p\"(/spanspan class=\"bp\"self/spanspan class=\"p\",/span span class=\"n\"bfs/spanspan class=\"p\"):/span\n        span class=\"k\"if/span span class=\"ow\"not/span span class=\"n\"bfs/spanspan class=\"p\":/span span class=\"k\"return/span span class=\"bp\"self/spanspan class=\"o\"./spanspan class=\"n\"unit/spanspan class=\"p\"()/span\n        span class=\"k\"elif/span span class=\"nb\"len/spanspan class=\"p\"(/spanspan class=\"n\"bfs/spanspan class=\"p\")/span span class=\"o\"==/span span class=\"mi\"1/spanspan class=\"p\":/span span class=\"k\"return/span span class=\"n\"bfs/spanspan class=\"p\"[/spanspan class=\"mi\"0/spanspan class=\"p\"]/span\n        span class=\"k\"elif/span span class=\"nb\"len/spanspan class=\"p\"(/spanspan class=\"n\"bfs/spanspan class=\"p\")/span span class=\"o\"==/span span class=\"mi\"2/spanspan class=\"p\":/span span class=\"k\"return/span span class=\"bp\"self/spanspan class=\"o\"./spanspan class=\"n\"join/spanspan class=\"p\"(/spanspan class=\"n\"bfs/spanspan class=\"p\"[/spanspan class=\"mi\"0/spanspan class=\"p\"],/span span class=\"n\"bfs/spanspan class=\"p\"[/spanspan class=\"mi\"1/spanspan class=\"p\"])/span\n        span class=\"k\"else/spanspan class=\"p\":/span\n            span class=\"n\"i/span span class=\"o\"=/span span class=\"nb\"len/spanspan class=\"p\"(/spanspan class=\"n\"bfs/spanspan class=\"p\")/span span class=\"o\"gt;gt;/span span class=\"mi\"1/span\n            span class=\"k\"return/span span class=\"bp\"self/spanspan class=\"o\"./spanspan class=\"n\"join/spanspan class=\"p\"(/spanspan class=\"bp\"self/spanspan class=\"o\"./spanspan class=\"n\"joinList/spanspan class=\"p\"(/spanspan class=\"n\"bfs/spanspan class=\"p\"[:/spanspan class=\"n\"i/spanspan class=\"p\"]),/span span class=\"bp\"self/spanspan class=\"o\"./spanspan class=\"n\"joinList/spanspan class=\"p\"(/spanspan class=\"n\"bfs/spanspan class=\"p\"[/spanspan class=\"n\"i/spanspan class=\"p\":]))/span\n/pre/div\n\npcode.joinList()/code is a little bulky to implement, but Wirth's principle applies:\nthe interpreter is shorter with it than without it./p\nh4 id=\"idioms\"Idioms/h4\npFinally, our interface includes a few high-level idioms, like the zero program\nshown earlier, which are defined in terms of low-level behaviors. In an\ninitial encoding, these could be defined as module-level functions; here, we\ndefine them on the mixin class codeBF/code./p\ndiv class=\"code\"pre class=\"code literal-block\"span class=\"k\"class/span span class=\"nc\"BF/spanspan class=\"p\"(/spanspan class=\"nb\"object/spanspan class=\"p\"):/span\n    span class=\"c1\"# Other methods elided/span\n    span class=\"k\"def/span span class=\"nf\"zero/spanspan class=\"p\"(/spanspan class=\"bp\"self/spanspan class=\"p\"):/span span class=\"k\"return/span span class=\"bp\"self/spanspan class=\"o\"./spanspan class=\"n\"loop/spanspan class=\"p\"(/spanspan class=\"bp\"self/spanspan class=\"o\"./spanspan class=\"n\"plus/spanspan class=\"p\"(/spanspan class=\"o\"-/spanspan class=\"mi\"1/spanspan class=\"p\"))/span\n    span class=\"k\"def/span span class=\"nf\"move/spanspan class=\"p\"(/spanspan class=\"bp\"self/spanspan class=\"p\",/span span class=\"n\"i/spanspan class=\"p\"):/span span class=\"k\"return/span span class=\"bp\"self/spanspan class=\"o\"./spanspan class=\"n\"scalemove/spanspan class=\"p\"(/spanspan class=\"n\"i/spanspan class=\"p\",/span span class=\"mi\"1/spanspan class=\"p\")/span\n    span class=\"k\"def/span span class=\"nf\"move2/spanspan class=\"p\"(/spanspan class=\"bp\"self/spanspan class=\"p\",/span span class=\"n\"i/spanspan class=\"p\",/span span class=\"n\"j/spanspan class=\"p\"):/span span class=\"k\"return/span span class=\"bp\"self/spanspan class=\"o\"./spanspan class=\"n\"scalemove2/spanspan class=\"p\"(/spanspan class=\"n\"i/spanspan class=\"p\",/span span class=\"mi\"1/spanspan class=\"p\",/span span class=\"n\"j/spanspan class=\"p\",/span span class=\"mi\"1/spanspan class=\"p\")/span\n    span class=\"k\"def/span span class=\"nf\"scalemove/spanspan class=\"p\"(/spanspan class=\"bp\"self/spanspan class=\"p\",/span span class=\"n\"i/spanspan class=\"p\",/span span class=\"n\"s/spanspan class=\"p\"):/span\n        span class=\"k\"return/span span class=\"bp\"self/spanspan class=\"o\"./spanspan class=\"n\"loop/spanspan class=\"p\"(/spanspan class=\"bp\"self/spanspan class=\"o\"./spanspan class=\"n\"joinList/spanspan class=\"p\"([/span\n            span class=\"bp\"self/spanspan class=\"o\"./spanspan class=\"n\"plus/spanspan class=\"p\"(/spanspan class=\"o\"-/spanspan class=\"mi\"1/spanspan class=\"p\"),/span span class=\"bp\"self/spanspan class=\"o\"./spanspan class=\"n\"right/spanspan class=\"p\"(/spanspan class=\"n\"i/spanspan class=\"p\"),/span span class=\"bp\"self/spanspan class=\"o\"./spanspan class=\"n\"plus/spanspan class=\"p\"(/spanspan class=\"n\"s/spanspan class=\"p\"),/span span class=\"bp\"self/spanspan class=\"o\"./spanspan class=\"n\"right/spanspan class=\"p\"(/spanspan class=\"o\"-/spanspan class=\"n\"i/spanspan class=\"p\")]))/span\n    span class=\"k\"def/span span class=\"nf\"scalemove2/spanspan class=\"p\"(/spanspan class=\"bp\"self/spanspan class=\"p\",/span span class=\"n\"i/spanspan class=\"p\",/span span class=\"n\"s/spanspan class=\"p\",/span span class=\"n\"j/spanspan class=\"p\",/span span class=\"n\"t/spanspan class=\"p\"):/span\n        span class=\"k\"return/span span class=\"bp\"self/spanspan class=\"o\"./spanspan class=\"n\"loop/spanspan class=\"p\"(/spanspan class=\"bp\"self/spanspan class=\"o\"./spanspan class=\"n\"joinList/spanspan class=\"p\"([/span\n                span class=\"bp\"self/spanspan class=\"o\"./spanspan class=\"n\"plus/spanspan class=\"p\"(/spanspan class=\"o\"-/spanspan class=\"mi\"1/spanspan class=\"p\"),/span span class=\"bp\"self/spanspan class=\"o\"./spanspan class=\"n\"right/spanspan class=\"p\"(/spanspan class=\"n\"i/spanspan class=\"p\"),/span span class=\"bp\"self/spanspan class=\"o\"./spanspan class=\"n\"plus/spanspan class=\"p\"(/spanspan class=\"n\"s/spanspan class=\"p\"),/span span class=\"bp\"self/spanspan class=\"o\"./spanspan class=\"n\"right/spanspan class=\"p\"(/spanspan class=\"n\"j/span span class=\"o\"-/span span class=\"n\"i/spanspan class=\"p\"),/span\n                span class=\"bp\"self/spanspan class=\"o\"./spanspan class=\"n\"plus/spanspan class=\"p\"(/spanspan class=\"n\"t/spanspan class=\"p\"),/span span class=\"bp\"self/spanspan class=\"o\"./spanspan class=\"n\"right/spanspan class=\"p\"(/spanspan class=\"o\"-/spanspan class=\"n\"j/spanspan class=\"p\")]))/span\n/pre/div\n\nh3 id=\"interface-oriented-architecture\"Interface-oriented Architecture/h3\nh4 id=\"applying-interfaces\"Applying Interfaces/h4\npNow, we hack at RPython's object model until everything translates. First,\nconsider the task of pretty-printing. For Brainfuck, we'll simply regurgitate\nthe input program as a Python string:/p\ndiv class=\"code\"pre class=\"code literal-block\"span class=\"k\"class/span span class=\"nc\"AsStr/spanspan class=\"p\"(/spanspan class=\"nb\"object/spanspan class=\"p\"):/span\n    span class=\"n\"import_from_mixin/spanspan class=\"p\"(/spanspan class=\"n\"BF/spanspan class=\"p\")/span\n    span class=\"k\"def/span span class=\"nf\"unit/spanspan class=\"p\"(/spanspan class=\"bp\"self/spanspan class=\"p\"):/span span class=\"k\"return/span span class=\"s2\"\"\"/span\n    span class=\"k\"def/span span class=\"nf\"join/spanspan class=\"p\"(/spanspan class=\"bp\"self/spanspan class=\"p\",/span span class=\"n\"l/spanspan class=\"p\",/span span class=\"n\"r/spanspan class=\"p\"):/span span class=\"k\"return/span span class=\"n\"l/span span class=\"o\"+/span span class=\"n\"r/span\n    span class=\"k\"def/span span class=\"nf\"plus/spanspan class=\"p\"(/spanspan class=\"bp\"self/spanspan class=\"p\",/span span class=\"n\"i/spanspan class=\"p\"):/span span class=\"k\"return/span span class=\"s1\"'+'/span span class=\"o\"*/span span class=\"n\"i/span span class=\"k\"if/span span class=\"n\"i/span span class=\"o\"gt;/span span class=\"mi\"0/span span class=\"k\"else/span span class=\"s1\"'-'/span span class=\"o\"*/span span class=\"o\"-/spanspan class=\"n\"i/span\n    span class=\"k\"def/span span class=\"nf\"right/spanspan class=\"p\"(/spanspan class=\"bp\"self/spanspan class=\"p\",/span span class=\"n\"i/spanspan class=\"p\"):/span span class=\"k\"return/span span class=\"s1\"'gt;'/span span class=\"o\"*/span span class=\"n\"i/span span class=\"k\"if/span span class=\"n\"i/span span class=\"o\"gt;/span span class=\"mi\"0/span span class=\"k\"else/span span class=\"s1\"'lt;'/span span class=\"o\"*/span span class=\"o\"-/spanspan class=\"n\"i/span\n    span class=\"k\"def/span span class=\"nf\"loop/spanspan class=\"p\"(/spanspan class=\"bp\"self/spanspan class=\"p\",/span span class=\"n\"bfs/spanspan class=\"p\"):/span span class=\"k\"return/span span class=\"s1\"'['/span span class=\"o\"+/span span class=\"n\"bfs/span span class=\"o\"+/span span class=\"s1\"']'/span\n    span class=\"k\"def/span span class=\"nf\"input/spanspan class=\"p\"(/spanspan class=\"bp\"self/spanspan class=\"p\"):/span span class=\"k\"return/span span class=\"s1\"','/span\n    span class=\"k\"def/span span class=\"nf\"output/spanspan class=\"p\"(/spanspan class=\"bp\"self/spanspan class=\"p\"):/span span class=\"k\"return/span span class=\"s1\"'.'/span\n/pre/div\n\npVia coderlib.objectmodel.import_from_mixin/code, no stressing with covariance of\nreturn types is required. Instead, we shift from a Java-esque view of classes\nand objects, to an OCaml-ish view of prebuilt classes and constructors.\ncodeAsStr/code is monomorphic, and any caller of it will have to create their own\ncovariance somehow. For example, here are the first few lines of the parsing\nfunction:/p\ndiv class=\"code\"pre class=\"code literal-block\"span class=\"nd\"@specialize/spanspan class=\"o\"./spanspan class=\"n\"argtype/spanspan class=\"p\"(/spanspan class=\"mi\"1/spanspan class=\"p\")/span\nspan class=\"k\"def/span span class=\"nf\"parse/spanspan class=\"p\"(/spanspan class=\"n\"s/spanspan class=\"p\",/span span class=\"n\"domain/spanspan class=\"p\"):/span\n    span class=\"n\"ops/span span class=\"o\"=/span span class=\"p\"[/spanspan class=\"n\"domain/spanspan class=\"o\"./spanspan class=\"n\"unit/spanspan class=\"p\"()]/span\n    span class=\"c1\"# Parser elided to preserve the reader's attention/span\n/pre/div\n\npBy invoking coderlib.objectmodel.specialize.argtype/code, we make copies of the\nparsing function, up to one per call site, based on our choice of semantic\ndomain. a href=\"https://okmij.org/ftp/tagless-final/\"Oleg/a calls these \"symantics\"\nbut I prefer \"domain\" in code. Also, note how the parsing stack starts with\nthe unit of the monoid, which corresponds to the empty input string; the\nparser will repeatedly use the monoidal join to build up a parsed expression\nwithout inspecting it. Here's a small taste of that:/p\ndiv class=\"code\"pre class=\"code literal-block\"span class=\"k\"while/span span class=\"n\"i/span span class=\"o\"lt;/span span class=\"nb\"len/spanspan class=\"p\"(/spanspan class=\"n\"s/spanspan class=\"p\"):/span\n    span class=\"n\"char/span span class=\"o\"=/span span class=\"n\"s/spanspan class=\"p\"[/spanspan class=\"n\"i/spanspan class=\"p\"]/span\n    span class=\"k\"if/span span class=\"n\"char/span span class=\"o\"==/span span class=\"s1\"'+'/spanspan class=\"p\":/span span class=\"n\"ops/spanspan class=\"p\"[/spanspan class=\"o\"-/spanspan class=\"mi\"1/spanspan class=\"p\"]/span span class=\"o\"=/span span class=\"n\"domain/spanspan class=\"o\"./spanspan class=\"n\"join/spanspan class=\"p\"(/spanspan class=\"n\"ops/spanspan class=\"p\"[/spanspan class=\"o\"-/spanspan class=\"mi\"1/spanspan class=\"p\"],/span span class=\"n\"domain/spanspan class=\"o\"./spanspan class=\"n\"plus/spanspan class=\"p\"(/spanspan class=\"mi\"1/spanspan class=\"p\"))/span\n    span class=\"k\"elif/span span class=\"n\"char/span span class=\"o\"==/span span class=\"s1\"'-'/spanspan class=\"p\":/span span class=\"n\"ops/spanspan class=\"p\"[/spanspan class=\"o\"-/spanspan class=\"mi\"1/spanspan class=\"p\"]/span span class=\"o\"=/span span class=\"n\"domain/spanspan class=\"o\"./spanspan class=\"n\"join/spanspan class=\"p\"(/spanspan class=\"n\"ops/spanspan class=\"p\"[/spanspan class=\"o\"-/spanspan class=\"mi\"1/spanspan class=\"p\"],/span span class=\"n\"domain/spanspan class=\"o\"./spanspan class=\"n\"plus/spanspan class=\"p\"(/spanspan class=\"o\"-/spanspan class=\"mi\"1/spanspan class=\"p\"))/span\n    span class=\"c1\"# and so on/span\n/pre/div\n\npThe reader may feel justifiably mystified; what breaks if we don't add these\nmagic annotations? Well, the translator will throw codeUnionError/code because the\nlow-level types don't match. RPython only wants to make one copy of functions\nlike codeparse()/code in its low-level representation, and each copy of codeparse()/code\nwill be compiled to monomorphic machine code. In this interpreter, in order to\nsupport parsing to an optimized string and also parsing to an evaluator, we\nneed two copies of codeparse()/code. strongIt is okay to not fully understand this at\nfirst./strong/p\nh4 id=\"composing-interfaces\"Composing Interfaces/h4\npEarlier, we noted that an interpreter can optionally optimize input programs\nafter parsing. To support this, we'll precompose a a href=\"https://en.wikipedia.org/wiki/Peephole_optimization\"peephole\noptimizer/a onto an\narbitrary domain. We could also postcompose with a parser instead, but that\nsounds more difficult. Here are the relevant parts:/p\ndiv class=\"code\"pre class=\"code literal-block\"span class=\"k\"def/span span class=\"nf\"makePeephole/spanspan class=\"p\"(/spanspan class=\"bp\"cls/spanspan class=\"p\"):/span\n    span class=\"n\"domain/span span class=\"o\"=/span span class=\"bp\"cls/spanspan class=\"p\"()/span\n    span class=\"k\"def/span span class=\"nf\"stripDomain/spanspan class=\"p\"(/spanspan class=\"n\"bfs/spanspan class=\"p\"):/span span class=\"k\"return/span span class=\"n\"domain/spanspan class=\"o\"./spanspan class=\"n\"joinList/spanspan class=\"p\"([/spanspan class=\"n\"t/spanspan class=\"p\"[/spanspan class=\"mi\"0/spanspan class=\"p\"]/span span class=\"k\"for/span span class=\"n\"t/span span class=\"ow\"in/span span class=\"n\"bfs/spanspan class=\"p\"])/span\n    span class=\"k\"class/span span class=\"nc\"Peephole/spanspan class=\"p\"(/spanspan class=\"nb\"object/spanspan class=\"p\"):/span\n        span class=\"n\"import_from_mixin/spanspan class=\"p\"(/spanspan class=\"n\"BF/spanspan class=\"p\")/span\n        span class=\"k\"def/span span class=\"nf\"unit/spanspan class=\"p\"(/spanspan class=\"bp\"self/spanspan class=\"p\"):/span span class=\"k\"return/span span class=\"p\"[]/span\n        span class=\"k\"def/span span class=\"nf\"join/spanspan class=\"p\"(/spanspan class=\"bp\"self/spanspan class=\"p\",/span span class=\"n\"l/spanspan class=\"p\",/span span class=\"n\"r/spanspan class=\"p\"):/span span class=\"k\"return/span span class=\"n\"l/span span class=\"o\"+/span span class=\"n\"r/span\n        span class=\"c1\"# Actual definition elided... for now.../span\n    span class=\"k\"return/span span class=\"n\"Peephole/spanspan class=\"p\",/span span class=\"n\"stripDomain/span\n/pre/div\n\npDon't worry about the actual optimization yet. What's important here is the\npattern of initialization of semantic domains. codemakePeephole/code is an\na href=\"https://en.wikipedia.org/wiki/Standard_ML\"SML/a-style functor on semantic\ndomains: given a final encoding of Brainfuck, it produces another final\nencoding of Brainfuck which incorporates optimizations. The helper\ncodestripDomain/code is a finalizer which performs the extraction from the\noptimizer's domain to the underlying codecls/code that was passed in at translation\ntime. For example, let's optimize pretty-printing:/p\ndiv class=\"code\"pre class=\"code literal-block\"span class=\"n\"AsStr/spanspan class=\"p\",/span span class=\"n\"finishStr/span span class=\"o\"=/span span class=\"n\"makePeephole/spanspan class=\"p\"(/spanspan class=\"n\"AsStr/spanspan class=\"p\")/span\n/pre/div\n\npNow, it only takes one line to parse and print an optimized AST without ever\nbuilding it on the heap. To be pedantic, fragments of the output string will\nbe heap-allocated, but the AST's node structure will only ever be\nstack-allocated. Further, to be shallow, the parser is written to prevent\nmalicious input from causing a stack overflow, and this forces it to maintain\na heap-allocated RPython list of intermediate operations inside loops./p\ndiv class=\"code\"pre class=\"code literal-block\"span class=\"nb\"print/span span class=\"n\"finishStr/spanspan class=\"p\"(/spanspan class=\"n\"parse/spanspan class=\"p\"(/spanspan class=\"n\"text/spanspan class=\"p\",/span span class=\"n\"AsStr/spanspan class=\"p\"()))/span\n/pre/div\n\nh3 id=\"performance\"Performance/h3\npBut is it fast? Yes. It's faster than the prior version, which was\ninitial-encoded, and also faster than Andrew Brown's classic version (a href=\"https://pypy.org/posts/2011/04/tutorial-writing-interpreter-with-pypy-3785910476193156295.html\"part\n1/a,\na href=\"https://pypy.org/posts/2011/04/tutorial-part-2-adding-jit-8121732841568309472.html\"part\n2/a).\nSince Brown's interpreter does not perform much optimization, we will focus on\nhow final encoding can outperform initial encoding./p\nh4 id=\"jit\"JIT/h4\npFirst, why is it faster than the same interpreter with initial encoding? Well,\nit still has initial encoding from the JIT's perspective! There is an codeOp/code\nclass with a hierarchy of subclasses implementing individual behaviors. A\nsincere tagless-final student, or those who remember a href=\"https://pyvideo.org/pycon-us-2012/stop-writing-classes.html\"Stop Writing Classes\n(2012, Pycon\nUS)/a, will\nrecognize that the following classes could be plain functions, and should\nthink of the classes as a concession to RPython's lack of support for lambdas\nwith closures rather than an initial encoding. We aren't ever going to\ndirectly typecheck any codeOp/code, but the JIT will generate typechecking guards\nanyway, so we effectively get a fully-promoted AST inlined into each JIT\ntrace. First, some simple behaviors:/p\ndiv class=\"code\"pre class=\"code literal-block\"span class=\"k\"class/span span class=\"nc\"Op/spanspan class=\"p\"(/spanspan class=\"nb\"object/spanspan class=\"p\"):/span span class=\"n\"_immutable_/span span class=\"o\"=/span span class=\"kc\"True/span\n\nspan class=\"k\"class/span span class=\"nc\"_Input/spanspan class=\"p\"(/spanspan class=\"n\"Op/spanspan class=\"p\"):/span\n    span class=\"n\"_immutable_/span span class=\"o\"=/span span class=\"kc\"True/span\n    span class=\"k\"def/span span class=\"nf\"runOn/spanspan class=\"p\"(/spanspan class=\"bp\"self/spanspan class=\"p\",/span span class=\"n\"tape/spanspan class=\"p\",/span span class=\"n\"position/spanspan class=\"p\"):/span\n        span class=\"n\"tape/spanspan class=\"p\"[/spanspan class=\"n\"position/spanspan class=\"p\"]/span span class=\"o\"=/span span class=\"nb\"ord/spanspan class=\"p\"(/spanspan class=\"n\"os/spanspan class=\"o\"./spanspan class=\"n\"read/spanspan class=\"p\"(/spanspan class=\"mi\"0/spanspan class=\"p\",/span span class=\"mi\"1/spanspan class=\"p\")[/spanspan class=\"mi\"0/spanspan class=\"p\"])/span\n        span class=\"k\"return/span span class=\"n\"position/span\nspan class=\"n\"Input/span span class=\"o\"=/span span class=\"n\"_Input/spanspan class=\"p\"()/span\n\nspan class=\"k\"class/span span class=\"nc\"_Output/spanspan class=\"p\"(/spanspan class=\"n\"Op/spanspan class=\"p\"):/span\n    span class=\"n\"_immutable_/span span class=\"o\"=/span span class=\"kc\"True/span\n    span class=\"k\"def/span span class=\"nf\"runOn/spanspan class=\"p\"(/spanspan class=\"bp\"self/spanspan class=\"p\",/span span class=\"n\"tape/spanspan class=\"p\",/span span class=\"n\"position/spanspan class=\"p\"):/span\n        span class=\"n\"os/spanspan class=\"o\"./spanspan class=\"n\"write/spanspan class=\"p\"(/spanspan class=\"mi\"1/spanspan class=\"p\",/span span class=\"nb\"chr/spanspan class=\"p\"(/spanspan class=\"n\"tape/spanspan class=\"p\"[/spanspan class=\"n\"position/spanspan class=\"p\"]))/span\n        span class=\"k\"return/span span class=\"n\"position/span\nspan class=\"n\"Output/span span class=\"o\"=/span span class=\"n\"_Output/spanspan class=\"p\"()/span\n\nspan class=\"k\"class/span span class=\"nc\"Add/spanspan class=\"p\"(/spanspan class=\"n\"Op/spanspan class=\"p\"):/span\n    span class=\"n\"_immutable_/span span class=\"o\"=/span span class=\"kc\"True/span\n    span class=\"n\"_immutable_fields_/span span class=\"o\"=/span span class=\"s2\"\"imm\"/spanspan class=\"p\",/span\n    span class=\"k\"def/span span class=\"fm\"__init__/spanspan class=\"p\"(/spanspan class=\"bp\"self/spanspan class=\"p\",/span span class=\"n\"imm/spanspan class=\"p\"):/span span class=\"bp\"self/spanspan class=\"o\"./spanspan class=\"n\"imm/span span class=\"o\"=/span span class=\"n\"imm/span\n    span class=\"k\"def/span span class=\"nf\"runOn/spanspan class=\"p\"(/spanspan class=\"bp\"self/spanspan class=\"p\",/span span class=\"n\"tape/spanspan class=\"p\",/span span class=\"n\"position/spanspan class=\"p\"):/span\n        span class=\"n\"tape/spanspan class=\"p\"[/spanspan class=\"n\"position/spanspan class=\"p\"]/span span class=\"o\"+=/span span class=\"bp\"self/spanspan class=\"o\"./spanspan class=\"n\"imm/span\n        span class=\"k\"return/span span class=\"n\"position/span\n/pre/div\n\npThe JIT does technically have less information than before; it no longer knows\nthat a sequence of immutable operations is immutable enough to be worth\nunrolling, but a bit of coderlib.jit.unroll_safe/code fixes that:/p\ndiv class=\"code\"pre class=\"code literal-block\"span class=\"k\"class/span span class=\"nc\"Seq/spanspan class=\"p\"(/spanspan class=\"n\"Op/spanspan class=\"p\"):/span\n    span class=\"n\"_immutable_/span span class=\"o\"=/span span class=\"kc\"True/span\n    span class=\"n\"_immutable_fields_/span span class=\"o\"=/span span class=\"s2\"\"ops[*]\"/spanspan class=\"p\",/span\n    span class=\"k\"def/span span class=\"fm\"__init__/spanspan class=\"p\"(/spanspan class=\"bp\"self/spanspan class=\"p\",/span span class=\"n\"ops/spanspan class=\"p\"):/span span class=\"bp\"self/spanspan class=\"o\"./spanspan class=\"n\"ops/span span class=\"o\"=/span span class=\"n\"ops/span\n    span class=\"nd\"@unroll_safe/span\n    span class=\"k\"def/span span class=\"nf\"runOn/spanspan class=\"p\"(/spanspan class=\"bp\"self/spanspan class=\"p\",/span span class=\"n\"tape/spanspan class=\"p\",/span span class=\"n\"position/spanspan class=\"p\"):/span\n        span class=\"k\"for/span span class=\"n\"op/span span class=\"ow\"in/span span class=\"bp\"self/spanspan class=\"o\"./spanspan class=\"n\"ops/spanspan class=\"p\":/span span class=\"n\"position/span span class=\"o\"=/span span class=\"n\"op/spanspan class=\"o\"./spanspan class=\"n\"runOn/spanspan class=\"p\"(/spanspan class=\"n\"tape/spanspan class=\"p\",/span span class=\"n\"position/spanspan class=\"p\")/span\n        span class=\"k\"return/span span class=\"n\"position/span\n/pre/div\n\npFinally, the JIT entry point is at the head of each loop, just like with prior\ninterpreters. Since Brainfuck doesn't support mid-loop jumps, there's no\npenalty for only allowing merge points at the head of the loop./p\ndiv class=\"code\"pre class=\"code literal-block\"span class=\"k\"class/span span class=\"nc\"Loop/spanspan class=\"p\"(/spanspan class=\"n\"Op/spanspan class=\"p\"):/span\n    span class=\"n\"_immutable_/span span class=\"o\"=/span span class=\"kc\"True/span\n    span class=\"n\"_immutable_fields_/span span class=\"o\"=/span span class=\"s2\"\"op\"/spanspan class=\"p\",/span\n    span class=\"k\"def/span span class=\"fm\"__init__/spanspan class=\"p\"(/spanspan class=\"bp\"self/spanspan class=\"p\",/span span class=\"n\"op/spanspan class=\"p\"):/span span class=\"bp\"self/spanspan class=\"o\"./spanspan class=\"n\"op/span span class=\"o\"=/span span class=\"n\"op/span\n    span class=\"k\"def/span span class=\"nf\"runOn/spanspan class=\"p\"(/spanspan class=\"bp\"self/spanspan class=\"p\",/span span class=\"n\"tape/spanspan class=\"p\",/span span class=\"n\"position/spanspan class=\"p\"):/span\n        span class=\"n\"op/span span class=\"o\"=/span span class=\"bp\"self/spanspan class=\"o\"./spanspan class=\"n\"op/span\n        span class=\"k\"while/span span class=\"n\"tape/spanspan class=\"p\"[/spanspan class=\"n\"position/spanspan class=\"p\"]:/span\n            span class=\"n\"jitdriver/spanspan class=\"o\"./spanspan class=\"n\"jit_merge_point/spanspan class=\"p\"(/spanspan class=\"n\"op/spanspan class=\"o\"=/spanspan class=\"n\"op/spanspan class=\"p\",/span span class=\"n\"position/spanspan class=\"o\"=/spanspan class=\"n\"position/spanspan class=\"p\",/span span class=\"n\"tape/spanspan class=\"o\"=/spanspan class=\"n\"tape/spanspan class=\"p\")/span\n            span class=\"n\"position/span span class=\"o\"=/span span class=\"n\"op/spanspan class=\"o\"./spanspan class=\"n\"runOn/spanspan class=\"p\"(/spanspan class=\"n\"tape/spanspan class=\"p\",/span span class=\"n\"position/spanspan class=\"p\")/span\n        span class=\"k\"return/span span class=\"n\"position/span\n/pre/div\n\npThat's the end of the implicit challenge. There's no secret to it; just\nevaluate the AST. Here's part of the semantic domain for evaluation, as well\nas the \"functor\" to optimize it. In codeAsOps.join()/code are the emonly/em\ncodeisinstance()/code calls in the entire interpreter! This is acceptable because\ncodeSeq/code is effectively a type wrapper for an RPython list, so that a list of\noperations is also an operation; its list is initial-encoded and available for\ninspection./p\ndiv class=\"code\"pre class=\"code literal-block\"span class=\"k\"class/span span class=\"nc\"AsOps/spanspan class=\"p\"(/spanspan class=\"nb\"object/spanspan class=\"p\"):/span\n    span class=\"n\"import_from_mixin/spanspan class=\"p\"(/spanspan class=\"n\"BF/spanspan class=\"p\")/span\n    span class=\"k\"def/span span class=\"nf\"unit/spanspan class=\"p\"(/spanspan class=\"bp\"self/spanspan class=\"p\"):/span span class=\"k\"return/span span class=\"n\"Shift/spanspan class=\"p\"(/spanspan class=\"mi\"0/spanspan class=\"p\")/span\n    span class=\"k\"def/span span class=\"nf\"join/spanspan class=\"p\"(/spanspan class=\"bp\"self/spanspan class=\"p\",/span span class=\"n\"l/spanspan class=\"p\",/span span class=\"n\"r/spanspan class=\"p\"):/span\n        span class=\"k\"if/span span class=\"nb\"isinstance/spanspan class=\"p\"(/spanspan class=\"n\"l/spanspan class=\"p\",/span span class=\"n\"Seq/spanspan class=\"p\")/span span class=\"ow\"and/span span class=\"nb\"isinstance/spanspan class=\"p\"(/spanspan class=\"n\"r/spanspan class=\"p\",/span span class=\"n\"Seq/spanspan class=\"p\"):/span\n            span class=\"k\"return/span span class=\"n\"Seq/spanspan class=\"p\"(/spanspan class=\"n\"l/spanspan class=\"o\"./spanspan class=\"n\"ops/span span class=\"o\"+/span span class=\"n\"r/spanspan class=\"o\"./spanspan class=\"n\"ops/spanspan class=\"p\")/span\n        span class=\"k\"elif/span span class=\"nb\"isinstance/spanspan class=\"p\"(/spanspan class=\"n\"l/spanspan class=\"p\",/span span class=\"n\"Seq/spanspan class=\"p\"):/span span class=\"k\"return/span span class=\"n\"Seq/spanspan class=\"p\"(/spanspan class=\"n\"l/spanspan class=\"o\"./spanspan class=\"n\"ops/span span class=\"o\"+/span span class=\"p\"[/spanspan class=\"n\"r/spanspan class=\"p\"])/span\n        span class=\"k\"elif/span span class=\"nb\"isinstance/spanspan class=\"p\"(/spanspan class=\"n\"r/spanspan class=\"p\",/span span class=\"n\"Seq/spanspan class=\"p\"):/span span class=\"k\"return/span span class=\"n\"Seq/spanspan class=\"p\"([/spanspan class=\"n\"l/spanspan class=\"p\"]/span span class=\"o\"+/span span class=\"n\"r/spanspan class=\"o\"./spanspan class=\"n\"ops/spanspan class=\"p\")/span\n        span class=\"k\"return/span span class=\"n\"Seq/spanspan class=\"p\"([/spanspan class=\"n\"l/spanspan class=\"p\",/span span class=\"n\"r/spanspan class=\"p\"])/span\n    span class=\"c1\"# Other methods elided!/span\n\nspan class=\"n\"AsOps/spanspan class=\"p\",/span span class=\"n\"finishOps/span span class=\"o\"=/span span class=\"n\"makePeephole/spanspan class=\"p\"(/spanspan class=\"n\"AsOps/spanspan class=\"p\")/span\n/pre/div\n\npAnd finally here is the actual top-level code to evaluate the input program.\nAs before, once everything is composed, the actual invocation only takes one\nline./p\ndiv class=\"code\"pre class=\"code literal-block\"span class=\"n\"tape/span span class=\"o\"=/span span class=\"nb\"bytearray/spanspan class=\"p\"(/spanspan class=\"s2\"\"/spanspan class=\"se\"\\x00/spanspan class=\"s2\"\"/span span class=\"o\"*/span span class=\"n\"cells/spanspan class=\"p\")/span\nspan class=\"n\"finishOps/spanspan class=\"p\"(/spanspan class=\"n\"parse/spanspan class=\"p\"(/spanspan class=\"n\"text/spanspan class=\"p\",/span span class=\"n\"AsOps/spanspan class=\"p\"()))/spanspan class=\"o\"./spanspan class=\"n\"runOn/spanspan class=\"p\"(/spanspan class=\"n\"tape/spanspan class=\"p\",/span span class=\"mi\"0/spanspan class=\"p\")/span\n/pre/div\n\nh4 id=\"peephole-optimization\"Peephole Optimization/h4\npOur peephole optimizer is an a href=\"https://en.wikipedia.org/wiki/Abstract_interpretation\"abstract\ninterpreter/a with one\ninstruction of lookahead/rewrite buffer. It implements the aforementioned\nalgebraic laws of the Brainfuck monoid. It also implements idiom recognition\nfor loops. First, the abstract interpreter. The abstract domain has six\nelements:/p\ndiv class=\"code\"pre class=\"code literal-block\"span class=\"k\"class/span span class=\"nc\"AbstractDomain/spanspan class=\"p\"(/spanspan class=\"nb\"object/spanspan class=\"p\"):/span span class=\"k\"pass/span\nspan class=\"n\"meh/spanspan class=\"p\",/span span class=\"n\"aLoop/spanspan class=\"p\",/span span class=\"n\"aZero/spanspan class=\"p\",/span span class=\"n\"theIdentity/spanspan class=\"p\",/span span class=\"n\"anAdd/spanspan class=\"p\",/span span class=\"n\"aRight/span span class=\"o\"=/span span class=\"p\"[/spanspan class=\"n\"AbstractDomain/spanspan class=\"p\"()/span span class=\"k\"for/span span class=\"n\"_/span span class=\"ow\"in/span span class=\"nb\"range/spanspan class=\"p\"(/spanspan class=\"mi\"6/spanspan class=\"p\")]/span\n/pre/div\n\npWe'll also tag everything with an integer, so that codeanAdd/code or codeaRight/code can be\nexact annotations. emThis/em is the actual codePeephole.join()/code method:/p\ndiv class=\"code\"pre class=\"code literal-block\"span class=\"k\"def/span span class=\"nf\"join/spanspan class=\"p\"(/spanspan class=\"bp\"self/spanspan class=\"p\",/span span class=\"n\"l/spanspan class=\"p\",/span span class=\"n\"r/spanspan class=\"p\"):/span\n    span class=\"k\"if/span span class=\"ow\"not/span span class=\"n\"l/spanspan class=\"p\":/span span class=\"k\"return/span span class=\"n\"r/span\n    span class=\"n\"rv/span span class=\"o\"=/span span class=\"n\"l/spanspan class=\"p\"[:]/span\n    span class=\"n\"bfHead/spanspan class=\"p\",/span span class=\"n\"adHead/spanspan class=\"p\",/span span class=\"n\"immHead/span span class=\"o\"=/span span class=\"n\"rv/spanspan class=\"o\"./spanspan class=\"n\"pop/spanspan class=\"p\"()/span\n    span class=\"k\"for/span span class=\"n\"bf/spanspan class=\"p\",/span span class=\"n\"ad/spanspan class=\"p\",/span span class=\"n\"imm/span span class=\"ow\"in/span span class=\"n\"r/spanspan class=\"p\":/span\n        span class=\"k\"if/span span class=\"n\"ad/span span class=\"ow\"is/span span class=\"n\"theIdentity/spanspan class=\"p\":/span span class=\"k\"continue/span\n        span class=\"k\"elif/span span class=\"n\"adHead/span span class=\"ow\"is/span span class=\"n\"aLoop/span span class=\"ow\"and/span span class=\"n\"ad/span span class=\"ow\"is/span span class=\"n\"aLoop/spanspan class=\"p\":/span span class=\"k\"continue/span\n        span class=\"k\"elif/span span class=\"n\"adHead/span span class=\"ow\"is/span span class=\"n\"theIdentity/spanspan class=\"p\":/span\n            span class=\"n\"bfHead/spanspan class=\"p\",/span span class=\"n\"adHead/spanspan class=\"p\",/span span class=\"n\"immHead/span span class=\"o\"=/span span class=\"n\"bf/spanspan class=\"p\",/span span class=\"n\"ad/spanspan class=\"p\",/span span class=\"n\"imm/span\n        span class=\"k\"elif/span span class=\"n\"adHead/span span class=\"ow\"is/span span class=\"n\"anAdd/span span class=\"ow\"and/span span class=\"n\"ad/span span class=\"ow\"is/span span class=\"n\"aZero/spanspan class=\"p\":/span\n            span class=\"n\"bfHead/spanspan class=\"p\",/span span class=\"n\"adHead/spanspan class=\"p\",/span span class=\"n\"immHead/span span class=\"o\"=/span span class=\"n\"bf/spanspan class=\"p\",/span span class=\"n\"ad/spanspan class=\"p\",/span span class=\"n\"imm/span\n        span class=\"k\"elif/span span class=\"n\"adHead/span span class=\"ow\"is/span span class=\"n\"anAdd/span span class=\"ow\"and/span span class=\"n\"ad/span span class=\"ow\"is/span span class=\"n\"anAdd/spanspan class=\"p\":/span\n            span class=\"n\"immHead/span span class=\"o\"+=/span span class=\"n\"imm/span\n            span class=\"k\"if/span span class=\"n\"immHead/spanspan class=\"p\":/span span class=\"n\"bfHead/span span class=\"o\"=/span span class=\"n\"domain/spanspan class=\"o\"./spanspan class=\"n\"plus/spanspan class=\"p\"(/spanspan class=\"n\"immHead/spanspan class=\"p\")/span\n            span class=\"k\"elif/span span class=\"n\"rv/spanspan class=\"p\":/span span class=\"n\"bfHead/spanspan class=\"p\",/span span class=\"n\"adHead/spanspan class=\"p\",/span span class=\"n\"immHead/span span class=\"o\"=/span span class=\"n\"rv/spanspan class=\"o\"./spanspan class=\"n\"pop/spanspan class=\"p\"()/span\n            span class=\"k\"else/spanspan class=\"p\":/span\n                span class=\"n\"bfHead/span span class=\"o\"=/span span class=\"n\"domain/spanspan class=\"o\"./spanspan class=\"n\"unit/spanspan class=\"p\"()/span\n                span class=\"n\"adHead/span span class=\"o\"=/span span class=\"n\"theIdentity/span\n        span class=\"k\"elif/span span class=\"n\"adHead/span span class=\"ow\"is/span span class=\"n\"aRight/span span class=\"ow\"and/span span class=\"n\"ad/span span class=\"ow\"is/span span class=\"n\"aRight/spanspan class=\"p\":/span\n            span class=\"n\"immHead/span span class=\"o\"+=/span span class=\"n\"imm/span\n            span class=\"k\"if/span span class=\"n\"immHead/spanspan class=\"p\":/span span class=\"n\"bfHead/span span class=\"o\"=/span span class=\"n\"domain/spanspan class=\"o\"./spanspan class=\"n\"right/spanspan class=\"p\"(/spanspan class=\"n\"immHead/spanspan class=\"p\")/span\n            span class=\"k\"elif/span span class=\"n\"rv/spanspan class=\"p\":/span span class=\"n\"bfHead/spanspan class=\"p\",/span span class=\"n\"adHead/spanspan class=\"p\",/span span class=\"n\"immHead/span span class=\"o\"=/span span class=\"n\"rv/spanspan class=\"o\"./spanspan class=\"n\"pop/spanspan class=\"p\"()/span\n            span class=\"k\"else/spanspan class=\"p\":/span\n                span class=\"n\"bfHead/span span class=\"o\"=/span span class=\"n\"domain/spanspan class=\"o\"./spanspan class=\"n\"unit/spanspan class=\"p\"()/span\n                span class=\"n\"adHead/span span class=\"o\"=/span span class=\"n\"theIdentity/span\n        span class=\"k\"else/spanspan class=\"p\":/span\n            span class=\"n\"rv/spanspan class=\"o\"./spanspan class=\"n\"append/spanspan class=\"p\"((/spanspan class=\"n\"bfHead/spanspan class=\"p\",/span span class=\"n\"adHead/spanspan class=\"p\",/span span class=\"n\"immHead/spanspan class=\"p\"))/span\n            span class=\"n\"bfHead/spanspan class=\"p\",/span span class=\"n\"adHead/spanspan class=\"p\",/span span class=\"n\"immHead/span span class=\"o\"=/span span class=\"n\"bf/spanspan class=\"p\",/span span class=\"n\"ad/spanspan class=\"p\",/span span class=\"n\"imm/span\n    span class=\"n\"rv/spanspan class=\"o\"./spanspan class=\"n\"append/spanspan class=\"p\"((/spanspan class=\"n\"bfHead/spanspan class=\"p\",/span span class=\"n\"adHead/spanspan class=\"p\",/span span class=\"n\"immHead/spanspan class=\"p\"))/span\n    span class=\"k\"return/span span class=\"n\"rv/span\n/pre/div\n\npIf this were to get much longer, then a href=\"https://pypy.org/posts/2024/10/jit-peephole-dsl.html\"implementing a\nDSL/a would be worth it,\nbut this is a short-enough method to inline. The abstract interpretation is\nassumed by induction for the left-hand side of the join, save for the final\ninstruction, which is loaded into a rewrite register. Each instruction on the\nright-hand side is inspected exactly once. The logic for codeanAdd/code followed by\ncodeanAdd/code is exactly the same as for codeaRight/code followed by codeaRight/code because they\nboth have underlying a href=\"https://en.wikipedia.org/wiki/Abelian_group\"Abelian\ngroups/a given by the integers.\nThe rewrite register is carefully pushed onto and popped off from the\nleft-hand side in order to cancel out codetheIdentity/code, which itself is merely a\nunifier for codeanAdd/code or codeaRight/code of 0./p\npNote that we generate a lot of garbage. For example, parsing a string of emn/em\n'+' characters will cause the peephole optimizer to allocate emn/em instances of\nthe underlying codedomain.plus()/code action, from codedomain.plus(1)/code up to\ncodedomain.plus(n)/code. An older initial-encoded version of this interpreter used\na href=\"https://en.wikipedia.org/wiki/Hash_consing\"hash consing/a to avoid ever\nbuilding an op more than once, even loops. It appears more efficient to\ngenerate lots of immutable garbage than to repeatedly hash inputs and search\nmutable hash tables, at least for optimizing Brainfuck incrementally during\nparsing./p\npFinally, let's look at idiom recognition. RPython lists are initial-coded, so\nwe can dispatch based on the length of the list, and then inspect the abstract\ndomains of each action./p\ndiv class=\"code\"pre class=\"code literal-block\"span class=\"k\"def/span span class=\"nf\"isConstAdd/spanspan class=\"p\"(/spanspan class=\"n\"bf/spanspan class=\"p\",/span span class=\"n\"i/spanspan class=\"p\"):/span span class=\"k\"return/span span class=\"n\"bf/spanspan class=\"p\"[/spanspan class=\"mi\"1/spanspan class=\"p\"]/span span class=\"ow\"is/span span class=\"n\"anAdd/span span class=\"ow\"and/span span class=\"n\"bf/spanspan class=\"p\"[/spanspan class=\"mi\"2/spanspan class=\"p\"]/span span class=\"o\"==/span span class=\"n\"i/span\n\nspan class=\"k\"def/span span class=\"nf\"oppositeShifts/spanspan class=\"p\"(/spanspan class=\"n\"bf1/spanspan class=\"p\",/span span class=\"n\"bf2/spanspan class=\"p\"):/span\n    span class=\"k\"return/span span class=\"n\"bf1/spanspan class=\"p\"[/spanspan class=\"mi\"1/spanspan class=\"p\"]/span span class=\"ow\"is/span span class=\"n\"bf2/spanspan class=\"p\"[/spanspan class=\"mi\"1/spanspan class=\"p\"]/span span class=\"ow\"is/span span class=\"n\"aRight/span span class=\"ow\"and/span span class=\"n\"bf1/spanspan class=\"p\"[/spanspan class=\"mi\"2/spanspan class=\"p\"]/span span class=\"o\"==/span span class=\"o\"-/spanspan class=\"n\"bf2/spanspan class=\"p\"[/spanspan class=\"mi\"2/spanspan class=\"p\"]/span\n\nspan class=\"k\"def/span span class=\"nf\"oppositeShifts2/spanspan class=\"p\"(/spanspan class=\"n\"bf1/spanspan class=\"p\",/span span class=\"n\"bf2/spanspan class=\"p\",/span span class=\"n\"bf3/spanspan class=\"p\"):/span\n    span class=\"k\"return/span span class=\"p\"(/spanspan class=\"n\"bf1/spanspan class=\"p\"[/spanspan class=\"mi\"1/spanspan class=\"p\"]/span span class=\"ow\"is/span span class=\"n\"bf2/spanspan class=\"p\"[/spanspan class=\"mi\"1/spanspan class=\"p\"]/span span class=\"ow\"is/span span class=\"n\"bf3/spanspan class=\"p\"[/spanspan class=\"mi\"1/spanspan class=\"p\"]/span span class=\"ow\"is/span span class=\"n\"aRight/span span class=\"ow\"and/span\n            span class=\"n\"bf1/spanspan class=\"p\"[/spanspan class=\"mi\"2/spanspan class=\"p\"]/span span class=\"o\"+/span span class=\"n\"bf2/spanspan class=\"p\"[/spanspan class=\"mi\"2/spanspan class=\"p\"]/span span class=\"o\"+/span span class=\"n\"bf3/spanspan class=\"p\"[/spanspan class=\"mi\"2/spanspan class=\"p\"]/span span class=\"o\"==/span span class=\"mi\"0/spanspan class=\"p\")/span\n\nspan class=\"k\"def/span span class=\"nf\"loop/spanspan class=\"p\"(/spanspan class=\"bp\"self/spanspan class=\"p\",/span span class=\"n\"bfs/spanspan class=\"p\"):/span\n    span class=\"k\"if/span span class=\"nb\"len/spanspan class=\"p\"(/spanspan class=\"n\"bfs/spanspan class=\"p\")/span span class=\"o\"==/span span class=\"mi\"1/spanspan class=\"p\":/span\n        span class=\"n\"bf/spanspan class=\"p\",/span span class=\"n\"ad/spanspan class=\"p\",/span span class=\"n\"imm/span span class=\"o\"=/span span class=\"n\"bfs/spanspan class=\"p\"[/spanspan class=\"mi\"0/spanspan class=\"p\"]/span\n        span class=\"k\"if/span span class=\"n\"ad/span span class=\"ow\"is/span span class=\"n\"anAdd/span span class=\"ow\"and/span span class=\"n\"imm/span span class=\"ow\"in/span span class=\"p\"(/spanspan class=\"mi\"1/spanspan class=\"p\",/span span class=\"o\"-/spanspan class=\"mi\"1/spanspan class=\"p\"):/span\n            span class=\"k\"return/span span class=\"p\"[(/spanspan class=\"n\"domain/spanspan class=\"o\"./spanspan class=\"n\"zero/spanspan class=\"p\"(),/span span class=\"n\"aZero/spanspan class=\"p\",/span span class=\"mi\"0/spanspan class=\"p\")]/span\n    span class=\"k\"elif/span span class=\"nb\"len/spanspan class=\"p\"(/spanspan class=\"n\"bfs/spanspan class=\"p\")/span span class=\"o\"==/span span class=\"mi\"4/spanspan class=\"p\":/span\n        span class=\"k\"if/span span class=\"p\"(/spanspan class=\"n\"isConstAdd/spanspan class=\"p\"(/spanspan class=\"n\"bfs/spanspan class=\"p\"[/spanspan class=\"mi\"0/spanspan class=\"p\"],/span span class=\"o\"-/spanspan class=\"mi\"1/spanspan class=\"p\")/span span class=\"ow\"and/span\n            span class=\"n\"bfs/spanspan class=\"p\"[/spanspan class=\"mi\"2/spanspan class=\"p\"][/spanspan class=\"mi\"1/spanspan class=\"p\"]/span span class=\"ow\"is/span span class=\"n\"anAdd/span span class=\"ow\"and/span\n            span class=\"n\"oppositeShifts/spanspan class=\"p\"(/spanspan class=\"n\"bfs/spanspan class=\"p\"[/spanspan class=\"mi\"1/spanspan class=\"p\"],/span span class=\"n\"bfs/spanspan class=\"p\"[/spanspan class=\"mi\"3/spanspan class=\"p\"])):/span\n            span class=\"k\"return/span span class=\"p\"[(/spanspan class=\"n\"domain/spanspan class=\"o\"./spanspan class=\"n\"scalemove/spanspan class=\"p\"(/spanspan class=\"n\"bfs/spanspan class=\"p\"[/spanspan class=\"mi\"1/spanspan class=\"p\"][/spanspan class=\"mi\"2/spanspan class=\"p\"],/span span class=\"n\"bfs/spanspan class=\"p\"[/spanspan class=\"mi\"2/spanspan class=\"p\"][/spanspan class=\"mi\"2/spanspan class=\"p\"]),/span span class=\"n\"aLoop/spanspan class=\"p\",/span span class=\"mi\"0/spanspan class=\"p\")]/span\n        span class=\"k\"if/span span class=\"p\"(/spanspan class=\"n\"isConstAdd/spanspan class=\"p\"(/spanspan class=\"n\"bfs/spanspan class=\"p\"[/spanspan class=\"mi\"3/spanspan class=\"p\"],/span span class=\"o\"-/spanspan class=\"mi\"1/spanspan class=\"p\")/span span class=\"ow\"and/span\n            span class=\"n\"bfs/spanspan class=\"p\"[/spanspan class=\"mi\"1/spanspan class=\"p\"][/spanspan class=\"mi\"1/spanspan class=\"p\"]/span span class=\"ow\"is/span span class=\"n\"anAdd/span span class=\"ow\"and/span\n            span class=\"n\"oppositeShifts/spanspan class=\"p\"(/spanspan class=\"n\"bfs/spanspan class=\"p\"[/spanspan class=\"mi\"0/spanspan class=\"p\"],/span span class=\"n\"bfs/spanspan class=\"p\"[/spanspan class=\"mi\"2/spanspan class=\"p\"])):/span\n            span class=\"k\"return/span span class=\"p\"[(/spanspan class=\"n\"domain/spanspan class=\"o\"./spanspan class=\"n\"scalemove/spanspan class=\"p\"(/spanspan class=\"n\"bfs/spanspan class=\"p\"[/spanspan class=\"mi\"0/spanspan class=\"p\"][/spanspan class=\"mi\"2/spanspan class=\"p\"],/span span class=\"n\"bfs/spanspan class=\"p\"[/spanspan class=\"mi\"1/spanspan class=\"p\"][/spanspan class=\"mi\"2/spanspan class=\"p\"]),/span span class=\"n\"aLoop/spanspan class=\"p\",/span span class=\"mi\"0/spanspan class=\"p\")]/span\n    span class=\"k\"elif/span span class=\"nb\"len/spanspan class=\"p\"(/spanspan class=\"n\"bfs/spanspan class=\"p\")/span span class=\"o\"==/span span class=\"mi\"6/spanspan class=\"p\":/span\n        span class=\"k\"if/span span class=\"p\"(/spanspan class=\"n\"isConstAdd/spanspan class=\"p\"(/spanspan class=\"n\"bfs/spanspan class=\"p\"[/spanspan class=\"mi\"0/spanspan class=\"p\"],/span span class=\"o\"-/spanspan class=\"mi\"1/spanspan class=\"p\")/span span class=\"ow\"and/span\n            span class=\"n\"bfs/spanspan class=\"p\"[/spanspan class=\"mi\"2/spanspan class=\"p\"][/spanspan class=\"mi\"1/spanspan class=\"p\"]/span span class=\"ow\"is/span span class=\"n\"bfs/spanspan class=\"p\"[/spanspan class=\"mi\"4/spanspan class=\"p\"][/spanspan class=\"mi\"1/spanspan class=\"p\"]/span span class=\"ow\"is/span span class=\"n\"anAdd/span span class=\"ow\"and/span\n            span class=\"n\"oppositeShifts2/spanspan class=\"p\"(/spanspan class=\"n\"bfs/spanspan class=\"p\"[/spanspan class=\"mi\"1/spanspan class=\"p\"],/span span class=\"n\"bfs/spanspan class=\"p\"[/spanspan class=\"mi\"3/spanspan class=\"p\"],/span span class=\"n\"bfs/spanspan class=\"p\"[/spanspan class=\"mi\"5/spanspan class=\"p\"])):/span\n            span class=\"k\"return/span span class=\"p\"[(/spanspan class=\"n\"domain/spanspan class=\"o\"./spanspan class=\"n\"scalemove2/spanspan class=\"p\"(/spanspan class=\"n\"bfs/spanspan class=\"p\"[/spanspan class=\"mi\"1/spanspan class=\"p\"][/spanspan class=\"mi\"2/spanspan class=\"p\"],/span span class=\"n\"bfs/spanspan class=\"p\"[/spanspan class=\"mi\"2/spanspan class=\"p\"][/spanspan class=\"mi\"2/spanspan class=\"p\"],/span\n                                       span class=\"n\"bfs/spanspan class=\"p\"[/spanspan class=\"mi\"1/spanspan class=\"p\"][/spanspan class=\"mi\"2/spanspan class=\"p\"]/span span class=\"o\"+/span span class=\"n\"bfs/spanspan class=\"p\"[/spanspan class=\"mi\"3/spanspan class=\"p\"][/spanspan class=\"mi\"2/spanspan class=\"p\"],/span\n                                       span class=\"n\"bfs/spanspan class=\"p\"[/spanspan class=\"mi\"4/spanspan class=\"p\"][/spanspan class=\"mi\"2/spanspan class=\"p\"]),/span span class=\"n\"aLoop/spanspan class=\"p\",/span span class=\"mi\"0/spanspan class=\"p\")]/span\n        span class=\"k\"if/span span class=\"p\"(/spanspan class=\"n\"isConstAdd/spanspan class=\"p\"(/spanspan class=\"n\"bfs/spanspan class=\"p\"[/spanspan class=\"mi\"5/spanspan class=\"p\"],/span span class=\"o\"-/spanspan class=\"mi\"1/spanspan class=\"p\")/span span class=\"ow\"and/span\n            span class=\"n\"bfs/spanspan class=\"p\"[/spanspan class=\"mi\"1/spanspan class=\"p\"][/spanspan class=\"mi\"1/spanspan class=\"p\"]/span span class=\"ow\"is/span span class=\"n\"bfs/spanspan class=\"p\"[/spanspan class=\"mi\"3/spanspan class=\"p\"][/spanspan class=\"mi\"1/spanspan class=\"p\"]/span span class=\"ow\"is/span span class=\"n\"anAdd/span span class=\"ow\"and/span\n            span class=\"n\"oppositeShifts2/spanspan class=\"p\"(/spanspan class=\"n\"bfs/spanspan class=\"p\"[/spanspan class=\"mi\"0/spanspan class=\"p\"],/span span class=\"n\"bfs/spanspan class=\"p\"[/spanspan class=\"mi\"2/spanspan class=\"p\"],/span span class=\"n\"bfs/spanspan class=\"p\"[/spanspan class=\"mi\"4/spanspan class=\"p\"])):/span\n            span class=\"k\"return/span span class=\"p\"[(/spanspan class=\"n\"domain/spanspan class=\"o\"./spanspan class=\"n\"scalemove2/spanspan class=\"p\"(/spanspan class=\"n\"bfs/spanspan class=\"p\"[/spanspan class=\"mi\"0/spanspan class=\"p\"][/spanspan class=\"mi\"2/spanspan class=\"p\"],/span span class=\"n\"bfs/spanspan class=\"p\"[/spanspan class=\"mi\"1/spanspan class=\"p\"][/spanspan class=\"mi\"2/spanspan class=\"p\"],/span\n                                       span class=\"n\"bfs/spanspan class=\"p\"[/spanspan class=\"mi\"0/spanspan class=\"p\"][/spanspan class=\"mi\"2/spanspan class=\"p\"]/span span class=\"o\"+/span span class=\"n\"bfs/spanspan class=\"p\"[/spanspan class=\"mi\"2/spanspan class=\"p\"][/spanspan class=\"mi\"2/spanspan class=\"p\"],/span\n                                       span class=\"n\"bfs/spanspan class=\"p\"[/spanspan class=\"mi\"3/spanspan class=\"p\"][/spanspan class=\"mi\"2/spanspan class=\"p\"]),/span span class=\"n\"aLoop/spanspan class=\"p\",/span span class=\"mi\"0/spanspan class=\"p\")]/span\n    span class=\"k\"return/span span class=\"p\"[(/spanspan class=\"n\"domain/spanspan class=\"o\"./spanspan class=\"n\"loop/spanspan class=\"p\"(/spanspan class=\"n\"stripDomain/spanspan class=\"p\"(/spanspan class=\"n\"bfs/spanspan class=\"p\")),/span span class=\"n\"aLoop/spanspan class=\"p\",/span span class=\"mi\"0/spanspan class=\"p\")]/span\n/pre/div\n\npThis ends the bonus question. How do we optimize an unknown semantic domain?\nWe must maintain an abstract context which describes elements of the domain.\nIn initial encoding, we ask an AST about itself. In final encoding, we already\nknow everything relevant about the AST./p\npThe careful reader will see that I didn't really answer that opening question\nin the JIT section. Because the JIT still ranges over the same operations as\nbefore, it can't really be slower; but why is it now faster? Because the\noptimizer is now slightly better in a few edge cases. It performs the same\noptimizations as before, but the rigor of abstract interpretation causes it to\nemit slightly better operations to the JIT backend./p\npConcretely, improving the optimizer can shorten pretty-printed programs. The\na href=\"https://bbgauge.info/\"Busy Beaver Gauge/a measures the length of programs\nwhich search for solutions to mathematical problems. After implementing and\ndebugging the final-encoded interpreter, I found that two of my entries on the\na href=\"https://bbgauge.info/brainfuck.html\"Busy Beaver Gauge for Brainfuck/a had\nbecome shorter by about 2%. (Most other entries are already hand-optimized\naccording to the standard algebra and have no optimization opportunities.)/p\nh3 id=\"discussion\"Discussion/h3\npGiven that initial and final encodings are equivalent, and noting that\nRPython's toolchain is written to prefer initial encodings, what did we\nactually gain? Did we gain anything?/p\npOne obvious downside to final encoding in RPython is interpreter size. The\nexample interpreter shown here is a rewrite of an initial-encoded interpreter\nwhich can be seen\na href=\"https://github.com/rpypkgs/rpypkgs/blob/659c8a26d428a1e04fdff614b28e464a50d4647b/bf/bf.py\"here/a\nfor comparison. Final encoding adds about 20% more code in this case./p\npFinal encoding is not necessarily more code than initial encoding, though. All\nAST encodings in interpreters are subject to the a href=\"https://en.wikipedia.org/wiki/Expression_problem\"Expression\nProblem/a, which states that\nthere is generally a quadratic amount of code required to implement multiple\nbehaviors for an AST with multiple types of nodes; specifically, emn/em behaviors\nfor emm/em types of nodes require emn/em  emm/em methods. Initial encodings improve the\ncost of adding new types of nodes; final encodings improve the cost of adding\nnew behaviors. Final encoding may tend to win in large codebases for mature\nlanguages, where the language does not change often but new behaviors are added\nfrequently and maintained for long periods./p\npOptimizations in final encoding require a bit of planning. The\nabstract-interpretation approach is solid but relies upon the monoid and its\nalgebraic laws. In the worst case, an entire class hierarchy could be required\nto encode the abstraction./p\npIt is remarkable to find stronga 2% improvement in residual program size/strong merely\nby reimplementing an optimizer as an abstract interpreter respecting the\nalgebraic laws. This could be the most important lesson for compiler\nengineers, if it happens to generalize./p\npFinal encoding was popularized via the tagless-final movement in OCaml and\nScala, including famously in a series of tutorials by a href=\"https://okmij.org/ftp/tagless-final/\"Kiselyov et\nal/a. A \"tag\", in this jargon, is a\nruntime identifier for an object's type or class; a tagless encoding\neffectively doesn't allow codeisinstance()/code at all. In the above presentation,\ntags could be hacked in, but were not materially relevant to most steps. Tags\nwere required for the final evaluation step, though, and the tagless-final\ninsight is that certain type systems can express type-safe evaluation without\nthose tags. We won't go further in this direction because tags also\ncommunicate valuable information to the JIT./p\nh4 id=\"summarizing-table\"Summarizing Table/h4\ntable\nthead\ntr\nthInitial Encoding/th\nthFinal Encoding/th\n/tr\n/thead\ntbody\ntr\ntdhierarchy of classes/td\ntdsignature of interfaces/td\n/tr\ntr\ntdclass constructors/td\ntdmethod calls/td\n/tr\ntr\ntdbuilt on the heap/td\ntdbuilt on the stack/td\n/tr\ntr\ntdtraversals allocate stack/td\ntdtraversals allocate heap/td\n/tr\ntr\ntdtags are available with codeisinstance()/code/td\ntdtags are only available through hacks/td\n/tr\ntr\ntdcost of adding a new AST node: one class/td\ntdcost of adding a new AST node: one method on every other class/td\n/tr\ntr\ntdcost of adding a new behavior: one method on every other class/td\ntdcost of adding a new behavior: one class/td\n/tr\n/tbody\n/table\nh3 id=\"credits\"Credits/h3\npThanks to folks in code#pypy/code on Libera Chat: arigato for the idea, larstiq for\npushing me to write it up, and cfbolz and mattip for reviewing and finding\nmistakes. The original IRC discussion leading to this blog post is available\na href=\"https://gist.github.com/MostAwesomeDude/fd86ad2d2e38af7aa67b6e548aabe008\"here/a./p\npThis interpreter is part of the a href=\"https://github.com/rpypkgs/rpypkgs\"rpypkgs/a\nsuite, a Nix flake for RPython interpreters. Readers with Nix installed can\nrun this interpreter directly from the flake:/p\ndiv class=\"code\"pre class=\"code literal-block\"$span class=\"w\" /spannix-prefetch-urlspan class=\"w\" /spanhttps://github.com/MG-K/pypy-tutorial-ko/raw/refs/heads/master/mandel.b\n$span class=\"w\" /spannixspan class=\"w\" /spanrunspan class=\"w\" /spangithub:rpypkgs/rpypkgs#bfspan class=\"w\" /span--span class=\"w\" /span/nix/store/ngnphbap9ncvz41d0fkvdh61n7j2bg21-mandel.b\n/pre/div"
        }
      ],
      "description": "h3 id=\"introduction\"Introduction/h3\npThis post started as a quick note summarizing a recent experiment I carried\nout upon a small RPython interpreter by rewriting it in an uncommon style. It\nis written for folks who have already written some RPython and want to take a\ndeeper look at interpreter architecture./p\npSome experiments are about finding solutions to problems. This experiment is\nabout taking a solution which is already well-understood and applying it in\nthe context of RPython to find a new approach. As we will see, there is no\nreal change in functionality or the number of clauses in the interpreter; it's\nmore like a comparison between endo- and exoskeletons, a different arrangement\nof equivalent bones and plates./p\nh3 id=\"overview\"Overview/h3\npAn RPython interpreter for a programming language generally does three or four\nthings, in order:/p\nol\nliRead and parse input programs/li\nliEncode concrete syntax as abstract syntax/li\nliemOptionally/em, optimize or reduce the abstract syntax/li\nliEvaluate the abstract syntax: read input data, compute, print output data,\n   etc./li\n/ol\npToday we'll look at abstract syntax. Most programming languages admit a\na href=\"https://en.wikipedia.org/wiki/Parse_tree\"concrete parse tree/a which is\nreadily abstracted to provide an a href=\"https://en.wikipedia.org/wiki/Abstract_syntax_tree\"abstract syntax\ntree/a (AST). The AST is\nusually encoded with the eminitial/em style of encoding. An initial encoding can\nbe transformed into any other encoding for the same AST, looks like a\nhierarchy of classes, and is implemented as a static structure on the heap./p\npIn contrast, there is also a emfinal/em encoding. A final encoding can be\ntransformed into by any other encoding, looks like an interface for the\nactions of the interpreter, and is implemented as an unwinding structure on\nthe stack. From the RPython perspective, Python builtin modules like codeos/code or\ncodesys/code are final encodings for features of the operating system; the underlying\nimplementation is different when translated or untranslated, but the interface\nused to access those features does not change./p\npIn RPython, an initial encoding is built from a hierarchy of classes. Each\nclass represents a type of tree nodes, corresponding to a parser production in\nthe concrete parse tree. Each class instance therefore represents an\nindividual tree node. The fields of a class, particularly those filled during\ncode.__init__()/code, store pre-computed properties of each node; methods can be used\nto compute node properties on demand. This seems like an obvious and simple\napproach; what other approaches could there be? We need an example./p\nh3 id=\"final-encoding-of-brainfuck\"Final Encoding of Brainfuck/h3\npWe will consider a href=\"https://esolangs.org/wiki/Brainfuck\"Brainfuck/a, a simple\nTuring-complete programming language. An example Brainfuck program might be:/p\ndiv class=\"code\"pre class=\"code literal-block\"span class=\"k\"[/spanspan class=\"nb\"-/spanspan class=\"k\"]/span\n/pre/div\n\npThis program is built from a loop and a decrement, and sets a cell to zero. In\nan initial encoding which follows the a href=\"https://esolangs.org/wiki/Algebraic_Brainfuck\"algebraic semantics of\nBrainfuck/a, the program could\nbe expressed by applying class constructors to build a structure on the heap:/p\ndiv class=\"code\"pre class=\"code literal-block\"span class=\"n\"Loop/spanspan class=\"p\"(/spanspan class=\"n\"Plus/spanspan class=\"p\"(/spanspan class=\"o\"-/spanspan class=\"mi\"1/spanspan class=\"p\"))/span\n/pre/div\n\npA final encoding is similar, except that class constructors are replaced by\nmethods, the structure is built on the stack, and we are parameterized over\nthe choice of class:/p\ndiv class=\"code\"pre class=\"code literal-block\"span class=\"k\"lambda/span span class=\"bp\"cls/spanspan class=\"p\":/span span class=\"bp\"cls/spanspan class=\"o\"./spanspan class=\"n\"loop/spanspan class=\"p\"(/spanspan class=\"bp\"cls/spanspan class=\"o\"./spanspan class=\"n\"plus/spanspan class=\"p\"(/spanspan class=\"o\"-/spanspan class=\"mi\"1/spanspan class=\"p\"))/span\n/pre/div\n\npIn ordinary Python, transforming between these would be trivial, and mostly is\na matter of passing around the appropriate class. Indeed, initial and final\nencodings are equivalent; we'll return to that fact later. However, in RPython,\nall of the types must line up, and classes must be determined before\ntranslation. We'll need to monomorphize our final encodings, using some\nRPython tricks later on. Before that, let's see what an actual Brainfuck\ninterface looks like, so that we can cover all of the difficulties with final\nencoding./p\npBefore we embark, please keep in mind that local code doesn't know what codecls/code\nis. There's no type-safe way to inspect an arbitrary semantic domain. In the\ninitial-encoded version, we can ask codeisinstance(bf, Loop)/code to see whether an\nAST node is a loop, but there simply isn't an equivalent for final-encoded\nASTs. So, there is an implicit challenge to think about: how do we evaluate a\nprogram in an arbitrary semantic domain? For bonus points, how do we optimize\na program without inspecting the types of its AST nodes?/p\npWhat follows is a dissection of\na href=\"https://github.com/rpypkgs/rpypkgs/blob/d439d225b79ac82e009a5f1cd1c670f00356464c/bf/bf.py\"this/a\nmodule at the given revision. Readers may find it satisfying to read the\nentire interpreter top to bottom first; it is less than 300 lines./p\nh4 id=\"core-functionality\"Core Functionality/h4\npFinal encoding is given as methods on an interface. These five methods\ncorrespond precisely to the summands of the algebra of Brainfuck./p\ndiv class=\"code\"pre class=\"code literal-block\"span class=\"k\"class/span span class=\"nc\"BF/spanspan class=\"p\"(/spanspan class=\"nb\"object/spanspan class=\"p\"):/span\n    span class=\"c1\"# Other methods elided/span\n    span class=\"k\"def/span span class=\"nf\"plus/spanspan class=\"p\"(/spanspan class=\"bp\"self/spanspan class=\"p\",/span span class=\"n\"i/spanspan class=\"p\"):/span span class=\"k\"pass/span\n    span class=\"k\"def/span span class=\"nf\"right/spanspan class=\"p\"(/spanspan class=\"bp\"self/spanspan class=\"p\",/span span class=\"n\"i/spanspan class=\"p\"):/span span class=\"k\"pass/span\n    span class=\"k\"def/span span class=\"nf\"input/spanspan class=\"p\"(/spanspan class=\"bp\"self/spanspan class=\"p\"):/span span class=\"k\"pass/span\n    span class=\"k\"def/span span class=\"nf\"output/spanspan class=\"p\"(/spanspan class=\"bp\"self/spanspan class=\"p\"):/span span class=\"k\"pass/span\n    span class=\"k\"def/span span class=\"nf\"loop/spanspan class=\"p\"(/spanspan class=\"bp\"self/spanspan class=\"p\",/span span class=\"n\"bfs/spanspan class=\"p\"):/span span class=\"k\"pass/span\n/pre/div\n\npNote that the code.loop()/code method takes another program as an argument.\nInitial-encoded ASTs have other initial-encoded ASTs as fields on class\ninstances; final-encoded ASTs have other final-encoded ASTs as parameters\nto interface methods. RPython infers all of the types, so the reader has to\nknow that codei/code is usually an integer while codebfs/code is a sequence of Brainfuck\noperations./p\npWe're using a class to implement this functionality. Later, we'll treat it as\na mixin, rather than a superclass, to avoid typing problems./p\nh4 id=\"monoid\"Monoid/h4\npIn order to optimize input programs, we'll need to represent the underlying\na href=\"https://en.wikipedia.org/wiki/Monoid\"monoid/a of Brainfuck programs. To do\nthis, we add the signature for a monoid:/p\ndiv class=\"code\"pre class=\"code literal-block\"span class=\"k\"class/span span class=\"nc\"BF/spanspan class=\"p\"(/spanspan class=\"nb\"object/spanspan class=\"p\"):/span\n    span class=\"c1\"# Other methods elided/span\n    span class=\"k\"def/span span class=\"nf\"unit/spanspan class=\"p\"(/spanspan class=\"bp\"self/spanspan class=\"p\"):/span span class=\"k\"pass/span\n    span class=\"k\"def/span span class=\"nf\"join/spanspan class=\"p\"(/spanspan class=\"bp\"self/spanspan class=\"p\",/span span class=\"n\"l/spanspan class=\"p\",/span span class=\"n\"r/spanspan class=\"p\"):/span span class=\"k\"pass/span\n/pre/div\n\npThis is technically a a href=\"https://en.wikipedia.org/wiki/Magma_(algebra)\"unital\nmagma/a, since RPython doesn't\nsupport algebraic laws, but we will enforce the algebraic laws later on during\noptimization. We also want to make use of the folklore that a href=\"https://en.wikipedia.org/wiki/Free_monoid\"free\nmonoids/a are lists, allowing\ncallers to pass a list of actions which we'll reduce with recursion:/p\ndiv class=\"code\"pre class=\"code literal-block\"span class=\"k\"class/span span class=\"nc\"BF/spanspan class=\"p\"(/spanspan class=\"nb\"object/spanspan class=\"p\"):/span\n    span class=\"c1\"# Other methods elided/span\n    span class=\"k\"def/span span class=\"nf\"joinList/spanspan class=\"p\"(/spanspan class=\"bp\"self/spanspan class=\"p\",/span span class=\"n\"bfs/spanspan class=\"p\"):/span\n        span class=\"k\"if/span span class=\"ow\"not/span span class=\"n\"bfs/spanspan class=\"p\":/span span class=\"k\"return/span span class=\"bp\"self/spanspan class=\"o\"./spanspan class=\"n\"unit/spanspan class=\"p\"()/span\n        span class=\"k\"elif/span span class=\"nb\"len/spanspan class=\"p\"(/spanspan class=\"n\"bfs/spanspan class=\"p\")/span span class=\"o\"==/span span class=\"mi\"1/spanspan class=\"p\":/span span class=\"k\"return/span span class=\"n\"bfs/spanspan class=\"p\"[/spanspan class=\"mi\"0/spanspan class=\"p\"]/span\n        span class=\"k\"elif/span span class=\"nb\"len/spanspan class=\"p\"(/spanspan class=\"n\"bfs/spanspan class=\"p\")/span span class=\"o\"==/span span class=\"mi\"2/spanspan class=\"p\":/span span class=\"k\"return/span span class=\"bp\"self/spanspan class=\"o\"./spanspan class=\"n\"join/spanspan class=\"p\"(/spanspan class=\"n\"bfs/spanspan class=\"p\"[/spanspan class=\"mi\"0/spanspan class=\"p\"],/span span class=\"n\"bfs/spanspan class=\"p\"[/spanspan class=\"mi\"1/spanspan class=\"p\"])/span\n        span class=\"k\"else/spanspan class=\"p\":/span\n            span class=\"n\"i/span span class=\"o\"=/span span class=\"nb\"len/spanspan class=\"p\"(/spanspan class=\"n\"bfs/spanspan class=\"p\")/span span class=\"o\"gt;gt;/span span class=\"mi\"1/span\n            span class=\"k\"return/span span class=\"bp\"self/spanspan class=\"o\"./spanspan class=\"n\"join/spanspan class=\"p\"(/spanspan class=\"bp\"self/spanspan class=\"o\"./spanspan class=\"n\"joinList/spanspan class=\"p\"(/spanspan class=\"n\"bfs/spanspan class=\"p\"[:/spanspan class=\"n\"i/spanspan class=\"p\"]),/span span class=\"bp\"self/spanspan class=\"o\"./spanspan class=\"n\"joinList/spanspan class=\"p\"(/spanspan class=\"n\"bfs/spanspan class=\"p\"[/spanspan class=\"n\"i/spanspan class=\"p\":]))/span\n/pre/div\n\npcode.joinList()/code is a little bulky to implement, but Wirth's principle applies:\nthe interpreter is shorter with it than without it./p\nh4 id=\"idioms\"Idioms/h4\npFinally, our interface includes a few high-level idioms, like the zero program\nshown earlier, which are defined in terms of low-level behaviors. In an\ninitial encoding, these could be defined as module-level functions; here, we\ndefine them on the mixin class codeBF/code./p\ndiv class=\"code\"pre class=\"code literal-block\"span class=\"k\"class/span span class=\"nc\"BF/spanspan class=\"p\"(/spanspan class=\"nb\"object/spanspan class=\"p\"):/span\n    span class=\"c1\"# Other methods elided/span\n    span class=\"k\"def/span span class=\"nf\"zero/spanspan class=\"p\"(/spanspan class=\"bp\"self/spanspan class=\"p\"):/span span class=\"k\"return/span span class=\"bp\"self/spanspan class=\"o\"./spanspan class=\"n\"loop/spanspan class=\"p\"(/spanspan class=\"bp\"self/spanspan class=\"o\"./spanspan class=\"n\"plus/spanspan class=\"p\"(/spanspan class=\"o\"-/spanspan class=\"mi\"1/spanspan class=\"p\"))/span\n    span class=\"k\"def/span span class=\"nf\"move/spanspan class=\"p\"(/spanspan class=\"bp\"self/spanspan class=\"p\",/span span class=\"n\"i/spanspan class=\"p\"):/span span class=\"k\"return/span span class=\"bp\"self/spanspan class=\"o\"./spanspan class=\"n\"scalemove/spanspan class=\"p\"(/spanspan class=\"n\"i/spanspan class=\"p\",/span span class=\"mi\"1/spanspan class=\"p\")/span\n    span class=\"k\"def/span span class=\"nf\"move2/spanspan class=\"p\"(/spanspan class=\"bp\"self/spanspan class=\"p\",/span span class=\"n\"i/spanspan class=\"p\",/span span class=\"n\"j/spanspan class=\"p\"):/span span class=\"k\"return/span span class=\"bp\"self/spanspan class=\"o\"./spanspan class=\"n\"scalemove2/spanspan class=\"p\"(/spanspan class=\"n\"i/spanspan class=\"p\",/span span class=\"mi\"1/spanspan class=\"p\",/span span class=\"n\"j/spanspan class=\"p\",/span span class=\"mi\"1/spanspan class=\"p\")/span\n    span class=\"k\"def/span span class=\"nf\"scalemove/spanspan class=\"p\"(/spanspan class=\"bp\"self/spanspan class=\"p\",/span span class=\"n\"i/spanspan class=\"p\",/span span class=\"n\"s/spanspan class=\"p\"):/span\n        span class=\"k\"return/span span class=\"bp\"self/spanspan class=\"o\"./spanspan class=\"n\"loop/spanspan class=\"p\"(/spanspan class=\"bp\"self/spanspan class=\"o\"./spanspan class=\"n\"joinList/spanspan class=\"p\"([/span\n            span class=\"bp\"self/spanspan class=\"o\"./spanspan class=\"n\"plus/spanspan class=\"p\"(/spanspan class=\"o\"-/spanspan class=\"mi\"1/spanspan class=\"p\"),/span span class=\"bp\"self/spanspan class=\"o\"./spanspan class=\"n\"right/spanspan class=\"p\"(/spanspan class=\"n\"i/spanspan class=\"p\"),/span span class=\"bp\"self/spanspan class=\"o\"./spanspan class=\"n\"plus/spanspan class=\"p\"(/spanspan class=\"n\"s/spanspan class=\"p\"),/span span class=\"bp\"self/spanspan class=\"o\"./spanspan class=\"n\"right/spanspan class=\"p\"(/spanspan class=\"o\"-/spanspan class=\"n\"i/spanspan class=\"p\")]))/span\n    span class=\"k\"def/span span class=\"nf\"scalemove2/spanspan class=\"p\"(/spanspan class=\"bp\"self/spanspan class=\"p\",/span span class=\"n\"i/spanspan class=\"p\",/span span class=\"n\"s/spanspan class=\"p\",/span span class=\"n\"j/spanspan class=\"p\",/span span class=\"n\"t/spanspan class=\"p\"):/span\n        span class=\"k\"return/span span class=\"bp\"self/spanspan class=\"o\"./spanspan class=\"n\"loop/spanspan class=\"p\"(/spanspan class=\"bp\"self/spanspan class=\"o\"./spanspan class=\"n\"joinList/spanspan class=\"p\"([/span\n                span class=\"bp\"self/spanspan class=\"o\"./spanspan class=\"n\"plus/spanspan class=\"p\"(/spanspan class=\"o\"-/spanspan class=\"mi\"1/spanspan class=\"p\"),/span span class=\"bp\"self/spanspan class=\"o\"./spanspan class=\"n\"right/spanspan class=\"p\"(/spanspan class=\"n\"i/spanspan class=\"p\"),/span span class=\"bp\"self/spanspan class=\"o\"./spanspan class=\"n\"plus/spanspan class=\"p\"(/spanspan class=\"n\"s/spanspan class=\"p\"),/span span class=\"bp\"self/spanspan class=\"o\"./spanspan class=\"n\"right/spanspan class=\"p\"(/spanspan class=\"n\"j/span span class=\"o\"-/span span class=\"n\"i/spanspan class=\"p\"),/span\n                span class=\"bp\"self/spanspan class=\"o\"./spanspan class=\"n\"plus/spanspan class=\"p\"(/spanspan class=\"n\"t/spanspan class=\"p\"),/span span class=\"bp\"self/spanspan class=\"o\"./spanspan class=\"n\"right/spanspan class=\"p\"(/spanspan class=\"o\"-/spanspan class=\"n\"j/spanspan class=\"p\")]))/span\n/pre/div\n\nh3 id=\"interface-oriented-architecture\"Interface-oriented Architecture/h3\nh4 id=\"applying-interfaces\"Applying Interfaces/h4\npNow, we hack at RPython's object model until everything translates. First,\nconsider the task of pretty-printing. For Brainfuck, we'll simply regurgitate\nthe input program as a Python string:/p\ndiv class=\"code\"pre class=\"code literal-block\"span class=\"k\"class/span span class=\"nc\"AsStr/spanspan class=\"p\"(/spanspan class=\"nb\"object/spanspan class=\"p\"):/span\n    span class=\"n\"import_from_mixin/spanspan class=\"p\"(/spanspan class=\"n\"BF/spanspan class=\"p\")/span\n    span class=\"k\"def/span span class=\"nf\"unit/spanspan class=\"p\"(/spanspan class=\"bp\"self/spanspan class=\"p\"):/span span class=\"k\"return/span span class=\"s2\"\"\"/span\n    span class=\"k\"def/span span class=\"nf\"join/spanspan class=\"p\"(/spanspan class=\"bp\"self/spanspan class=\"p\",/span span class=\"n\"l/spanspan class=\"p\",/span span class=\"n\"r/spanspan class=\"p\"):/span span class=\"k\"return/span span class=\"n\"l/span span class=\"o\"+/span span class=\"n\"r/span\n    span class=\"k\"def/span span class=\"nf\"plus/spanspan class=\"p\"(/spanspan class=\"bp\"self/spanspan class=\"p\",/span span class=\"n\"i/spanspan class=\"p\"):/span span class=\"k\"return/span span class=\"s1\"'+'/span span class=\"o\"*/span span class=\"n\"i/span span class=\"k\"if/span span class=\"n\"i/span span class=\"o\"gt;/span span class=\"mi\"0/span span class=\"k\"else/span span class=\"s1\"'-'/span span class=\"o\"*/span span class=\"o\"-/spanspan class=\"n\"i/span\n    span class=\"k\"def/span span class=\"nf\"right/spanspan class=\"p\"(/spanspan class=\"bp\"self/spanspan class=\"p\",/span span class=\"n\"i/spanspan class=\"p\"):/span span class=\"k\"return/span span class=\"s1\"'gt;'/span span class=\"o\"*/span span class=\"n\"i/span span class=\"k\"if/span span class=\"n\"i/span span class=\"o\"gt;/span span class=\"mi\"0/span span class=\"k\"else/span span class=\"s1\"'lt;'/span span class=\"o\"*/span span class=\"o\"-/spanspan class=\"n\"i/span\n    span class=\"k\"def/span span class=\"nf\"loop/spanspan class=\"p\"(/spanspan class=\"bp\"self/spanspan class=\"p\",/span span class=\"n\"bfs/spanspan class=\"p\"):/span span class=\"k\"return/span span class=\"s1\"'['/span span class=\"o\"+/span span class=\"n\"bfs/span span class=\"o\"+/span span class=\"s1\"']'/span\n    span class=\"k\"def/span span class=\"nf\"input/spanspan class=\"p\"(/spanspan class=\"bp\"self/spanspan class=\"p\"):/span span class=\"k\"return/span span class=\"s1\"','/span\n    span class=\"k\"def/span span class=\"nf\"output/spanspan class=\"p\"(/spanspan class=\"bp\"self/spanspan class=\"p\"):/span span class=\"k\"return/span span class=\"s1\"'.'/span\n/pre/div\n\npVia coderlib.objectmodel.import_from_mixin/code, no stressing with covariance of\nreturn types is required. Instead, we shift from a Java-esque view of classes\nand objects, to an OCaml-ish view of prebuilt classes and constructors.\ncodeAsStr/code is monomorphic, and any caller of it will have to create their own\ncovariance somehow. For example, here are the first few lines of the parsing\nfunction:/p\ndiv class=\"code\"pre class=\"code literal-block\"span class=\"nd\"@specialize/spanspan class=\"o\"./spanspan class=\"n\"argtype/spanspan class=\"p\"(/spanspan class=\"mi\"1/spanspan class=\"p\")/span\nspan class=\"k\"def/span span class=\"nf\"parse/spanspan class=\"p\"(/spanspan class=\"n\"s/spanspan class=\"p\",/span span class=\"n\"domain/spanspan class=\"p\"):/span\n    span class=\"n\"ops/span span class=\"o\"=/span span class=\"p\"[/spanspan class=\"n\"domain/spanspan class=\"o\"./spanspan class=\"n\"unit/spanspan class=\"p\"()]/span\n    span class=\"c1\"# Parser elided to preserve the reader's attention/span\n/pre/div\n\npBy invoking coderlib.objectmodel.specialize.argtype/code, we make copies of the\nparsing function, up to one per call site, based on our choice of semantic\ndomain. a href=\"https://okmij.org/ftp/tagless-final/\"Oleg/a calls these \"symantics\"\nbut I prefer \"domain\" in code. Also, note how the parsing stack starts with\nthe unit of the monoid, which corresponds to the empty input string; the\nparser will repeatedly use the monoidal join to build up a parsed expression\nwithout inspecting it. Here's a small taste of that:/p\ndiv class=\"code\"pre class=\"code literal-block\"span class=\"k\"while/span span class=\"n\"i/span span class=\"o\"lt;/span span class=\"nb\"len/spanspan class=\"p\"(/spanspan class=\"n\"s/spanspan class=\"p\"):/span\n    span class=\"n\"char/span span class=\"o\"=/span span class=\"n\"s/spanspan class=\"p\"[/spanspan class=\"n\"i/spanspan class=\"p\"]/span\n    span class=\"k\"if/span span class=\"n\"char/span span class=\"o\"==/span span class=\"s1\"'+'/spanspan class=\"p\":/span span class=\"n\"ops/spanspan class=\"p\"[/spanspan class=\"o\"-/spanspan class=\"mi\"1/spanspan class=\"p\"]/span span class=\"o\"=/span span class=\"n\"domain/spanspan class=\"o\"./spanspan class=\"n\"join/spanspan class=\"p\"(/spanspan class=\"n\"ops/spanspan class=\"p\"[/spanspan class=\"o\"-/spanspan class=\"mi\"1/spanspan class=\"p\"],/span span class=\"n\"domain/spanspan class=\"o\"./spanspan class=\"n\"plus/spanspan class=\"p\"(/spanspan class=\"mi\"1/spanspan class=\"p\"))/span\n    span class=\"k\"elif/span span class=\"n\"char/span span class=\"o\"==/span span class=\"s1\"'-'/spanspan class=\"p\":/span span class=\"n\"ops/spanspan class=\"p\"[/spanspan class=\"o\"-/spanspan class=\"mi\"1/spanspan class=\"p\"]/span span class=\"o\"=/span span class=\"n\"domain/spanspan class=\"o\"./spanspan class=\"n\"join/spanspan class=\"p\"(/spanspan class=\"n\"ops/spanspan class=\"p\"[/spanspan class=\"o\"-/spanspan class=\"mi\"1/spanspan class=\"p\"],/span span class=\"n\"domain/spanspan class=\"o\"./spanspan class=\"n\"plus/spanspan class=\"p\"(/spanspan class=\"o\"-/spanspan class=\"mi\"1/spanspan class=\"p\"))/span\n    span class=\"c1\"# and so on/span\n/pre/div\n\npThe reader may feel justifiably mystified; what breaks if we don't add these\nmagic annotations? Well, the translator will throw codeUnionError/code because the\nlow-level types don't match. RPython only wants to make one copy of functions\nlike codeparse()/code in its low-level representation, and each copy of codeparse()/code\nwill be compiled to monomorphic machine code. In this interpreter, in order to\nsupport parsing to an optimized string and also parsing to an evaluator, we\nneed two copies of codeparse()/code. strongIt is okay to not fully understand this at\nfirst./strong/p\nh4 id=\"composing-interfaces\"Composing Interfaces/h4\npEarlier, we noted that an interpreter can optionally optimize input programs\nafter parsing. To support this, we'll precompose a a href=\"https://en.wikipedia.org/wiki/Peephole_optimization\"peephole\noptimizer/a onto an\narbitrary domain. We could also postcompose with a parser instead, but that\nsounds more difficult. Here are the relevant parts:/p\ndiv class=\"code\"pre class=\"code literal-block\"span class=\"k\"def/span span class=\"nf\"makePeephole/spanspan class=\"p\"(/spanspan class=\"bp\"cls/spanspan class=\"p\"):/span\n    span class=\"n\"domain/span span class=\"o\"=/span span class=\"bp\"cls/spanspan class=\"p\"()/span\n    span class=\"k\"def/span span class=\"nf\"stripDomain/spanspan class=\"p\"(/spanspan class=\"n\"bfs/spanspan class=\"p\"):/span span class=\"k\"return/span span class=\"n\"domain/spanspan class=\"o\"./spanspan class=\"n\"joinList/spanspan class=\"p\"([/spanspan class=\"n\"t/spanspan class=\"p\"[/spanspan class=\"mi\"0/spanspan class=\"p\"]/span span class=\"k\"for/span span class=\"n\"t/span span class=\"ow\"in/span span class=\"n\"bfs/spanspan class=\"p\"])/span\n    span class=\"k\"class/span span class=\"nc\"Peephole/spanspan class=\"p\"(/spanspan class=\"nb\"object/spanspan class=\"p\"):/span\n        span class=\"n\"import_from_mixin/spanspan class=\"p\"(/spanspan class=\"n\"BF/spanspan class=\"p\")/span\n        span class=\"k\"def/span span class=\"nf\"unit/spanspan class=\"p\"(/spanspan class=\"bp\"self/spanspan class=\"p\"):/span span class=\"k\"return/span span class=\"p\"[]/span\n        span class=\"k\"def/span span class=\"nf\"join/spanspan class=\"p\"(/spanspan class=\"bp\"self/spanspan class=\"p\",/span span class=\"n\"l/spanspan class=\"p\",/span span class=\"n\"r/spanspan class=\"p\"):/span span class=\"k\"return/span span class=\"n\"l/span span class=\"o\"+/span span class=\"n\"r/span\n        span class=\"c1\"# Actual definition elided... for now.../span\n    span class=\"k\"return/span span class=\"n\"Peephole/spanspan class=\"p\",/span span class=\"n\"stripDomain/span\n/pre/div\n\npDon't worry about the actual optimization yet. What's important here is the\npattern of initialization of semantic domains. codemakePeephole/code is an\na href=\"https://en.wikipedia.org/wiki/Standard_ML\"SML/a-style functor on semantic\ndomains: given a final encoding of Brainfuck, it produces another final\nencoding of Brainfuck which incorporates optimizations. The helper\ncodestripDomain/code is a finalizer which performs the extraction from the\noptimizer's domain to the underlying codecls/code that was passed in at translation\ntime. For example, let's optimize pretty-printing:/p\ndiv class=\"code\"pre class=\"code literal-block\"span class=\"n\"AsStr/spanspan class=\"p\",/span span class=\"n\"finishStr/span span class=\"o\"=/span span class=\"n\"makePeephole/spanspan class=\"p\"(/spanspan class=\"n\"AsStr/spanspan class=\"p\")/span\n/pre/div\n\npNow, it only takes one line to parse and print an optimized AST without ever\nbuilding it on the heap. To be pedantic, fragments of the output string will\nbe heap-allocated, but the AST's node structure will only ever be\nstack-allocated. Further, to be shallow, the parser is written to prevent\nmalicious input from causing a stack overflow, and this forces it to maintain\na heap-allocated RPython list of intermediate operations inside loops./p\ndiv class=\"code\"pre class=\"code literal-block\"span class=\"nb\"print/span span class=\"n\"finishStr/spanspan class=\"p\"(/spanspan class=\"n\"parse/spanspan class=\"p\"(/spanspan class=\"n\"text/spanspan class=\"p\",/span span class=\"n\"AsStr/spanspan class=\"p\"()))/span\n/pre/div\n\nh3 id=\"performance\"Performance/h3\npBut is it fast? Yes. It's faster than the prior version, which was\ninitial-encoded, and also faster than Andrew Brown's classic version (a href=\"https://pypy.org/posts/2011/04/tutorial-writing-interpreter-with-pypy-3785910476193156295.html\"part\n1/a,\na href=\"https://pypy.org/posts/2011/04/tutorial-part-2-adding-jit-8121732841568309472.html\"part\n2/a).\nSince Brown's interpreter does not perform much optimization, we will focus on\nhow final encoding can outperform initial encoding./p\nh4 id=\"jit\"JIT/h4\npFirst, why is it faster than the same interpreter with initial encoding? Well,\nit still has initial encoding from the JIT's perspective! There is an codeOp/code\nclass with a hierarchy of subclasses implementing individual behaviors. A\nsincere tagless-final student, or those who remember a href=\"https://pyvideo.org/pycon-us-2012/stop-writing-classes.html\"Stop Writing Classes\n(2012, Pycon\nUS)/a, will\nrecognize that the following classes could be plain functions, and should\nthink of the classes as a concession to RPython's lack of support for lambdas\nwith closures rather than an initial encoding. We aren't ever going to\ndirectly typecheck any codeOp/code, but the JIT will generate typechecking guards\nanyway, so we effectively get a fully-promoted AST inlined into each JIT\ntrace. First, some simple behaviors:/p\ndiv class=\"code\"pre class=\"code literal-block\"span class=\"k\"class/span span class=\"nc\"Op/spanspan class=\"p\"(/spanspan class=\"nb\"object/spanspan class=\"p\"):/span span class=\"n\"_immutable_/span span class=\"o\"=/span span class=\"kc\"True/span\n\nspan class=\"k\"class/span span class=\"nc\"_Input/spanspan class=\"p\"(/spanspan class=\"n\"Op/spanspan class=\"p\"):/span\n    span class=\"n\"_immutable_/span span class=\"o\"=/span span class=\"kc\"True/span\n    span class=\"k\"def/span span class=\"nf\"runOn/spanspan class=\"p\"(/spanspan class=\"bp\"self/spanspan class=\"p\",/span span class=\"n\"tape/spanspan class=\"p\",/span span class=\"n\"position/spanspan class=\"p\"):/span\n        span class=\"n\"tape/spanspan class=\"p\"[/spanspan class=\"n\"position/spanspan class=\"p\"]/span span class=\"o\"=/span span class=\"nb\"ord/spanspan class=\"p\"(/spanspan class=\"n\"os/spanspan class=\"o\"./spanspan class=\"n\"read/spanspan class=\"p\"(/spanspan class=\"mi\"0/spanspan class=\"p\",/span span class=\"mi\"1/spanspan class=\"p\")[/spanspan class=\"mi\"0/spanspan class=\"p\"])/span\n        span class=\"k\"return/span span class=\"n\"position/span\nspan class=\"n\"Input/span span class=\"o\"=/span span class=\"n\"_Input/spanspan class=\"p\"()/span\n\nspan class=\"k\"class/span span class=\"nc\"_Output/spanspan class=\"p\"(/spanspan class=\"n\"Op/spanspan class=\"p\"):/span\n    span class=\"n\"_immutable_/span span class=\"o\"=/span span class=\"kc\"True/span\n    span class=\"k\"def/span span class=\"nf\"runOn/spanspan class=\"p\"(/spanspan class=\"bp\"self/spanspan class=\"p\",/span span class=\"n\"tape/spanspan class=\"p\",/span span class=\"n\"position/spanspan class=\"p\"):/span\n        span class=\"n\"os/spanspan class=\"o\"./spanspan class=\"n\"write/spanspan class=\"p\"(/spanspan class=\"mi\"1/spanspan class=\"p\",/span span class=\"nb\"chr/spanspan class=\"p\"(/spanspan class=\"n\"tape/spanspan class=\"p\"[/spanspan class=\"n\"position/spanspan class=\"p\"]))/span\n        span class=\"k\"return/span span class=\"n\"position/span\nspan class=\"n\"Output/span span class=\"o\"=/span span class=\"n\"_Output/spanspan class=\"p\"()/span\n\nspan class=\"k\"class/span span class=\"nc\"Add/spanspan class=\"p\"(/spanspan class=\"n\"Op/spanspan class=\"p\"):/span\n    span class=\"n\"_immutable_/span span class=\"o\"=/span span class=\"kc\"True/span\n    span class=\"n\"_immutable_fields_/span span class=\"o\"=/span span class=\"s2\"\"imm\"/spanspan class=\"p\",/span\n    span class=\"k\"def/span span class=\"fm\"__init__/spanspan class=\"p\"(/spanspan class=\"bp\"self/spanspan class=\"p\",/span span class=\"n\"imm/spanspan class=\"p\"):/span span class=\"bp\"self/spanspan class=\"o\"./spanspan class=\"n\"imm/span span class=\"o\"=/span span class=\"n\"imm/span\n    span class=\"k\"def/span span class=\"nf\"runOn/spanspan class=\"p\"(/spanspan class=\"bp\"self/spanspan class=\"p\",/span span class=\"n\"tape/spanspan class=\"p\",/span span class=\"n\"position/spanspan class=\"p\"):/span\n        span class=\"n\"tape/spanspan class=\"p\"[/spanspan class=\"n\"position/spanspan class=\"p\"]/span span class=\"o\"+=/span span class=\"bp\"self/spanspan class=\"o\"./spanspan class=\"n\"imm/span\n        span class=\"k\"return/span span class=\"n\"position/span\n/pre/div\n\npThe JIT does technically have less information than before; it no longer knows\nthat a sequence of immutable operations is immutable enough to be worth\nunrolling, but a bit of coderlib.jit.unroll_safe/code fixes that:/p\ndiv class=\"code\"pre class=\"code literal-block\"span class=\"k\"class/span span class=\"nc\"Seq/spanspan class=\"p\"(/spanspan class=\"n\"Op/spanspan class=\"p\"):/span\n    span class=\"n\"_immutable_/span span class=\"o\"=/span span class=\"kc\"True/span\n    span class=\"n\"_immutable_fields_/span span class=\"o\"=/span span class=\"s2\"\"ops[*]\"/spanspan class=\"p\",/span\n    span class=\"k\"def/span span class=\"fm\"__init__/spanspan class=\"p\"(/spanspan class=\"bp\"self/spanspan class=\"p\",/span span class=\"n\"ops/spanspan class=\"p\"):/span span class=\"bp\"self/spanspan class=\"o\"./spanspan class=\"n\"ops/span span class=\"o\"=/span span class=\"n\"ops/span\n    span class=\"nd\"@unroll_safe/span\n    span class=\"k\"def/span span class=\"nf\"runOn/spanspan class=\"p\"(/spanspan class=\"bp\"self/spanspan class=\"p\",/span span class=\"n\"tape/spanspan class=\"p\",/span span class=\"n\"position/spanspan class=\"p\"):/span\n        span class=\"k\"for/span span class=\"n\"op/span span class=\"ow\"in/span span class=\"bp\"self/spanspan class=\"o\"./spanspan class=\"n\"ops/spanspan class=\"p\":/span span class=\"n\"position/span span class=\"o\"=/span span class=\"n\"op/spanspan class=\"o\"./spanspan class=\"n\"runOn/spanspan class=\"p\"(/spanspan class=\"n\"tape/spanspan class=\"p\",/span span class=\"n\"position/spanspan class=\"p\")/span\n        span class=\"k\"return/span span class=\"n\"position/span\n/pre/div\n\npFinally, the JIT entry point is at the head of each loop, just like with prior\ninterpreters. Since Brainfuck doesn't support mid-loop jumps, there's no\npenalty for only allowing merge points at the head of the loop./p\ndiv class=\"code\"pre class=\"code literal-block\"span class=\"k\"class/span span class=\"nc\"Loop/spanspan class=\"p\"(/spanspan class=\"n\"Op/spanspan class=\"p\"):/span\n    span class=\"n\"_immutable_/span span class=\"o\"=/span span class=\"kc\"True/span\n    span class=\"n\"_immutable_fields_/span span class=\"o\"=/span span class=\"s2\"\"op\"/spanspan class=\"p\",/span\n    span class=\"k\"def/span span class=\"fm\"__init__/spanspan class=\"p\"(/spanspan class=\"bp\"self/spanspan class=\"p\",/span span class=\"n\"op/spanspan class=\"p\"):/span span class=\"bp\"self/spanspan class=\"o\"./spanspan class=\"n\"op/span span class=\"o\"=/span span class=\"n\"op/span\n    span class=\"k\"def/span span class=\"nf\"runOn/spanspan class=\"p\"(/spanspan class=\"bp\"self/spanspan class=\"p\",/span span class=\"n\"tape/spanspan class=\"p\",/span span class=\"n\"position/spanspan class=\"p\"):/span\n        span class=\"n\"op/span span class=\"o\"=/span span class=\"bp\"self/spanspan class=\"o\"./spanspan class=\"n\"op/span\n        span class=\"k\"while/span span class=\"n\"tape/spanspan class=\"p\"[/spanspan class=\"n\"position/spanspan class=\"p\"]:/span\n            span class=\"n\"jitdriver/spanspan class=\"o\"./spanspan class=\"n\"jit_merge_point/spanspan class=\"p\"(/spanspan class=\"n\"op/spanspan class=\"o\"=/spanspan class=\"n\"op/spanspan class=\"p\",/span span class=\"n\"position/spanspan class=\"o\"=/spanspan class=\"n\"position/spanspan class=\"p\",/span span class=\"n\"tape/spanspan class=\"o\"=/spanspan class=\"n\"tape/spanspan class=\"p\")/span\n            span class=\"n\"position/span span class=\"o\"=/span span class=\"n\"op/spanspan class=\"o\"./spanspan class=\"n\"runOn/spanspan class=\"p\"(/spanspan class=\"n\"tape/spanspan class=\"p\",/span span class=\"n\"position/spanspan class=\"p\")/span\n        span class=\"k\"return/span span class=\"n\"position/span\n/pre/div\n\npThat's the end of the implicit challenge. There's no secret to it; just\nevaluate the AST. Here's part of the semantic domain for evaluation, as well\nas the \"functor\" to optimize it. In codeAsOps.join()/code are the emonly/em\ncodeisinstance()/code calls in the entire interpreter! This is acceptable because\ncodeSeq/code is effectively a type wrapper for an RPython list, so that a list of\noperations is also an operation; its list is initial-encoded and available for\ninspection./p\ndiv class=\"code\"pre class=\"code literal-block\"span class=\"k\"class/span span class=\"nc\"AsOps/spanspan class=\"p\"(/spanspan class=\"nb\"object/spanspan class=\"p\"):/span\n    span class=\"n\"import_from_mixin/spanspan class=\"p\"(/spanspan class=\"n\"BF/spanspan class=\"p\")/span\n    span class=\"k\"def/span span class=\"nf\"unit/spanspan class=\"p\"(/spanspan class=\"bp\"self/spanspan class=\"p\"):/span span class=\"k\"return/span span class=\"n\"Shift/spanspan class=\"p\"(/spanspan class=\"mi\"0/spanspan class=\"p\")/span\n    span class=\"k\"def/span span class=\"nf\"join/spanspan class=\"p\"(/spanspan class=\"bp\"self/spanspan class=\"p\",/span span class=\"n\"l/spanspan class=\"p\",/span span class=\"n\"r/spanspan class=\"p\"):/span\n        span class=\"k\"if/span span class=\"nb\"isinstance/spanspan class=\"p\"(/spanspan class=\"n\"l/spanspan class=\"p\",/span span class=\"n\"Seq/spanspan class=\"p\")/span span class=\"ow\"and/span span class=\"nb\"isinstance/spanspan class=\"p\"(/spanspan class=\"n\"r/spanspan class=\"p\",/span span class=\"n\"Seq/spanspan class=\"p\"):/span\n            span class=\"k\"return/span span class=\"n\"Seq/spanspan class=\"p\"(/spanspan class=\"n\"l/spanspan class=\"o\"./spanspan class=\"n\"ops/span span class=\"o\"+/span span class=\"n\"r/spanspan class=\"o\"./spanspan class=\"n\"ops/spanspan class=\"p\")/span\n        span class=\"k\"elif/span span class=\"nb\"isinstance/spanspan class=\"p\"(/spanspan class=\"n\"l/spanspan class=\"p\",/span span class=\"n\"Seq/spanspan class=\"p\"):/span span class=\"k\"return/span span class=\"n\"Seq/spanspan class=\"p\"(/spanspan class=\"n\"l/spanspan class=\"o\"./spanspan class=\"n\"ops/span span class=\"o\"+/span span class=\"p\"[/spanspan class=\"n\"r/spanspan class=\"p\"])/span\n        span class=\"k\"elif/span span class=\"nb\"isinstance/spanspan class=\"p\"(/spanspan class=\"n\"r/spanspan class=\"p\",/span span class=\"n\"Seq/spanspan class=\"p\"):/span span class=\"k\"return/span span class=\"n\"Seq/spanspan class=\"p\"([/spanspan class=\"n\"l/spanspan class=\"p\"]/span span class=\"o\"+/span span class=\"n\"r/spanspan class=\"o\"./spanspan class=\"n\"ops/spanspan class=\"p\")/span\n        span class=\"k\"return/span span class=\"n\"Seq/spanspan class=\"p\"([/spanspan class=\"n\"l/spanspan class=\"p\",/span span class=\"n\"r/spanspan class=\"p\"])/span\n    span class=\"c1\"# Other methods elided!/span\n\nspan class=\"n\"AsOps/spanspan class=\"p\",/span span class=\"n\"finishOps/span span class=\"o\"=/span span class=\"n\"makePeephole/spanspan class=\"p\"(/spanspan class=\"n\"AsOps/spanspan class=\"p\")/span\n/pre/div\n\npAnd finally here is the actual top-level code to evaluate the input program.\nAs before, once everything is composed, the actual invocation only takes one\nline./p\ndiv class=\"code\"pre class=\"code literal-block\"span class=\"n\"tape/span span class=\"o\"=/span span class=\"nb\"bytearray/spanspan class=\"p\"(/spanspan class=\"s2\"\"/spanspan class=\"se\"\\x00/spanspan class=\"s2\"\"/span span class=\"o\"*/span span class=\"n\"cells/spanspan class=\"p\")/span\nspan class=\"n\"finishOps/spanspan class=\"p\"(/spanspan class=\"n\"parse/spanspan class=\"p\"(/spanspan class=\"n\"text/spanspan class=\"p\",/span span class=\"n\"AsOps/spanspan class=\"p\"()))/spanspan class=\"o\"./spanspan class=\"n\"runOn/spanspan class=\"p\"(/spanspan class=\"n\"tape/spanspan class=\"p\",/span span class=\"mi\"0/spanspan class=\"p\")/span\n/pre/div\n\nh4 id=\"peephole-optimization\"Peephole Optimization/h4\npOur peephole optimizer is an a href=\"https://en.wikipedia.org/wiki/Abstract_interpretation\"abstract\ninterpreter/a with one\ninstruction of lookahead/rewrite buffer. It implements the aforementioned\nalgebraic laws of the Brainfuck monoid. It also implements idiom recognition\nfor loops. First, the abstract interpreter. The abstract domain has six\nelements:/p\ndiv class=\"code\"pre class=\"code literal-block\"span class=\"k\"class/span span class=\"nc\"AbstractDomain/spanspan class=\"p\"(/spanspan class=\"nb\"object/spanspan class=\"p\"):/span span class=\"k\"pass/span\nspan class=\"n\"meh/spanspan class=\"p\",/span span class=\"n\"aLoop/spanspan class=\"p\",/span span class=\"n\"aZero/spanspan class=\"p\",/span span class=\"n\"theIdentity/spanspan class=\"p\",/span span class=\"n\"anAdd/spanspan class=\"p\",/span span class=\"n\"aRight/span span class=\"o\"=/span span class=\"p\"[/spanspan class=\"n\"AbstractDomain/spanspan class=\"p\"()/span span class=\"k\"for/span span class=\"n\"_/span span class=\"ow\"in/span span class=\"nb\"range/spanspan class=\"p\"(/spanspan class=\"mi\"6/spanspan class=\"p\")]/span\n/pre/div\n\npWe'll also tag everything with an integer, so that codeanAdd/code or codeaRight/code can be\nexact annotations. emThis/em is the actual codePeephole.join()/code method:/p\ndiv class=\"code\"pre class=\"code literal-block\"span class=\"k\"def/span span class=\"nf\"join/spanspan class=\"p\"(/spanspan class=\"bp\"self/spanspan class=\"p\",/span span class=\"n\"l/spanspan class=\"p\",/span span class=\"n\"r/spanspan class=\"p\"):/span\n    span class=\"k\"if/span span class=\"ow\"not/span span class=\"n\"l/spanspan class=\"p\":/span span class=\"k\"return/span span class=\"n\"r/span\n    span class=\"n\"rv/span span class=\"o\"=/span span class=\"n\"l/spanspan class=\"p\"[:]/span\n    span class=\"n\"bfHead/spanspan class=\"p\",/span span class=\"n\"adHead/spanspan class=\"p\",/span span class=\"n\"immHead/span span class=\"o\"=/span span class=\"n\"rv/spanspan class=\"o\"./spanspan class=\"n\"pop/spanspan class=\"p\"()/span\n    span class=\"k\"for/span span class=\"n\"bf/spanspan class=\"p\",/span span class=\"n\"ad/spanspan class=\"p\",/span span class=\"n\"imm/span span class=\"ow\"in/span span class=\"n\"r/spanspan class=\"p\":/span\n        span class=\"k\"if/span span class=\"n\"ad/span span class=\"ow\"is/span span class=\"n\"theIdentity/spanspan class=\"p\":/span span class=\"k\"continue/span\n        span class=\"k\"elif/span span class=\"n\"adHead/span span class=\"ow\"is/span span class=\"n\"aLoop/span span class=\"ow\"and/span span class=\"n\"ad/span span class=\"ow\"is/span span class=\"n\"aLoop/spanspan class=\"p\":/span span class=\"k\"continue/span\n        span class=\"k\"elif/span span class=\"n\"adHead/span span class=\"ow\"is/span span class=\"n\"theIdentity/spanspan class=\"p\":/span\n            span class=\"n\"bfHead/spanspan class=\"p\",/span span class=\"n\"adHead/spanspan class=\"p\",/span span class=\"n\"immHead/span span class=\"o\"=/span span class=\"n\"bf/spanspan class=\"p\",/span span class=\"n\"ad/spanspan class=\"p\",/span span class=\"n\"imm/span\n        span class=\"k\"elif/span span class=\"n\"adHead/span span class=\"ow\"is/span span class=\"n\"anAdd/span span class=\"ow\"and/span span class=\"n\"ad/span span class=\"ow\"is/span span class=\"n\"aZero/spanspan class=\"p\":/span\n            span class=\"n\"bfHead/spanspan class=\"p\",/span span class=\"n\"adHead/spanspan class=\"p\",/span span class=\"n\"immHead/span span class=\"o\"=/span span class=\"n\"bf/spanspan class=\"p\",/span span class=\"n\"ad/spanspan class=\"p\",/span span class=\"n\"imm/span\n        span class=\"k\"elif/span span class=\"n\"adHead/span span class=\"ow\"is/span span class=\"n\"anAdd/span span class=\"ow\"and/span span class=\"n\"ad/span span class=\"ow\"is/span span class=\"n\"anAdd/spanspan class=\"p\":/span\n            span class=\"n\"immHead/span span class=\"o\"+=/span span class=\"n\"imm/span\n            span class=\"k\"if/span span class=\"n\"immHead/spanspan class=\"p\":/span span class=\"n\"bfHead/span span class=\"o\"=/span span class=\"n\"domain/spanspan class=\"o\"./spanspan class=\"n\"plus/spanspan class=\"p\"(/spanspan class=\"n\"immHead/spanspan class=\"p\")/span\n            span class=\"k\"elif/span span class=\"n\"rv/spanspan class=\"p\":/span span class=\"n\"bfHead/spanspan class=\"p\",/span span class=\"n\"adHead/spanspan class=\"p\",/span span class=\"n\"immHead/span span class=\"o\"=/span span class=\"n\"rv/spanspan class=\"o\"./spanspan class=\"n\"pop/spanspan class=\"p\"()/span\n            span class=\"k\"else/spanspan class=\"p\":/span\n                span class=\"n\"bfHead/span span class=\"o\"=/span span class=\"n\"domain/spanspan class=\"o\"./spanspan class=\"n\"unit/spanspan class=\"p\"()/span\n                span class=\"n\"adHead/span span class=\"o\"=/span span class=\"n\"theIdentity/span\n        span class=\"k\"elif/span span class=\"n\"adHead/span span class=\"ow\"is/span span class=\"n\"aRight/span span class=\"ow\"and/span span class=\"n\"ad/span span class=\"ow\"is/span span class=\"n\"aRight/spanspan class=\"p\":/span\n            span class=\"n\"immHead/span span class=\"o\"+=/span span class=\"n\"imm/span\n            span class=\"k\"if/span span class=\"n\"immHead/spanspan class=\"p\":/span span class=\"n\"bfHead/span span class=\"o\"=/span span class=\"n\"domain/spanspan class=\"o\"./spanspan class=\"n\"right/spanspan class=\"p\"(/spanspan class=\"n\"immHead/spanspan class=\"p\")/span\n            span class=\"k\"elif/span span class=\"n\"rv/spanspan class=\"p\":/span span class=\"n\"bfHead/spanspan class=\"p\",/span span class=\"n\"adHead/spanspan class=\"p\",/span span class=\"n\"immHead/span span class=\"o\"=/span span class=\"n\"rv/spanspan class=\"o\"./spanspan class=\"n\"pop/spanspan class=\"p\"()/span\n            span class=\"k\"else/spanspan class=\"p\":/span\n                span class=\"n\"bfHead/span span class=\"o\"=/span span class=\"n\"domain/spanspan class=\"o\"./spanspan class=\"n\"unit/spanspan class=\"p\"()/span\n                span class=\"n\"adHead/span span class=\"o\"=/span span class=\"n\"theIdentity/span\n        span class=\"k\"else/spanspan class=\"p\":/span\n            span class=\"n\"rv/spanspan class=\"o\"./spanspan class=\"n\"append/spanspan class=\"p\"((/spanspan class=\"n\"bfHead/spanspan class=\"p\",/span span class=\"n\"adHead/spanspan class=\"p\",/span span class=\"n\"immHead/spanspan class=\"p\"))/span\n            span class=\"n\"bfHead/spanspan class=\"p\",/span span class=\"n\"adHead/spanspan class=\"p\",/span span class=\"n\"immHead/span span class=\"o\"=/span span class=\"n\"bf/spanspan class=\"p\",/span span class=\"n\"ad/spanspan class=\"p\",/span span class=\"n\"imm/span\n    span class=\"n\"rv/spanspan class=\"o\"./spanspan class=\"n\"append/spanspan class=\"p\"((/spanspan class=\"n\"bfHead/spanspan class=\"p\",/span span class=\"n\"adHead/spanspan class=\"p\",/span span class=\"n\"immHead/spanspan class=\"p\"))/span\n    span class=\"k\"return/span span class=\"n\"rv/span\n/pre/div\n\npIf this were to get much longer, then a href=\"https://pypy.org/posts/2024/10/jit-peephole-dsl.html\"implementing a\nDSL/a would be worth it,\nbut this is a short-enough method to inline. The abstract interpretation is\nassumed by induction for the left-hand side of the join, save for the final\ninstruction, which is loaded into a rewrite register. Each instruction on the\nright-hand side is inspected exactly once. The logic for codeanAdd/code followed by\ncodeanAdd/code is exactly the same as for codeaRight/code followed by codeaRight/code because they\nboth have underlying a href=\"https://en.wikipedia.org/wiki/Abelian_group\"Abelian\ngroups/a given by the integers.\nThe rewrite register is carefully pushed onto and popped off from the\nleft-hand side in order to cancel out codetheIdentity/code, which itself is merely a\nunifier for codeanAdd/code or codeaRight/code of 0./p\npNote that we generate a lot of garbage. For example, parsing a string of emn/em\n'+' characters will cause the peephole optimizer to allocate emn/em instances of\nthe underlying codedomain.plus()/code action, from codedomain.plus(1)/code up to\ncodedomain.plus(n)/code. An older initial-encoded version of this interpreter used\na href=\"https://en.wikipedia.org/wiki/Hash_consing\"hash consing/a to avoid ever\nbuilding an op more than once, even loops. It appears more efficient to\ngenerate lots of immutable garbage than to repeatedly hash inputs and search\nmutable hash tables, at least for optimizing Brainfuck incrementally during\nparsing./p\npFinally, let's look at idiom recognition. RPython lists are initial-coded, so\nwe can dispatch based on the length of the list, and then inspect the abstract\ndomains of each action./p\ndiv class=\"code\"pre class=\"code literal-block\"span class=\"k\"def/span span class=\"nf\"isConstAdd/spanspan class=\"p\"(/spanspan class=\"n\"bf/spanspan class=\"p\",/span span class=\"n\"i/spanspan class=\"p\"):/span span class=\"k\"return/span span class=\"n\"bf/spanspan class=\"p\"[/spanspan class=\"mi\"1/spanspan class=\"p\"]/span span class=\"ow\"is/span span class=\"n\"anAdd/span span class=\"ow\"and/span span class=\"n\"bf/spanspan class=\"p\"[/spanspan class=\"mi\"2/spanspan class=\"p\"]/span span class=\"o\"==/span span class=\"n\"i/span\n\nspan class=\"k\"def/span span class=\"nf\"oppositeShifts/spanspan class=\"p\"(/spanspan class=\"n\"bf1/spanspan class=\"p\",/span span class=\"n\"bf2/spanspan class=\"p\"):/span\n    span class=\"k\"return/span span class=\"n\"bf1/spanspan class=\"p\"[/spanspan class=\"mi\"1/spanspan class=\"p\"]/span span class=\"ow\"is/span span class=\"n\"bf2/spanspan class=\"p\"[/spanspan class=\"mi\"1/spanspan class=\"p\"]/span span class=\"ow\"is/span span class=\"n\"aRight/span span class=\"ow\"and/span span class=\"n\"bf1/spanspan class=\"p\"[/spanspan class=\"mi\"2/spanspan class=\"p\"]/span span class=\"o\"==/span span class=\"o\"-/spanspan class=\"n\"bf2/spanspan class=\"p\"[/spanspan class=\"mi\"2/spanspan class=\"p\"]/span\n\nspan class=\"k\"def/span span class=\"nf\"oppositeShifts2/spanspan class=\"p\"(/spanspan class=\"n\"bf1/spanspan class=\"p\",/span span class=\"n\"bf2/spanspan class=\"p\",/span span class=\"n\"bf3/spanspan class=\"p\"):/span\n    span class=\"k\"return/span span class=\"p\"(/spanspan class=\"n\"bf1/spanspan class=\"p\"[/spanspan class=\"mi\"1/spanspan class=\"p\"]/span span class=\"ow\"is/span span class=\"n\"bf2/spanspan class=\"p\"[/spanspan class=\"mi\"1/spanspan class=\"p\"]/span span class=\"ow\"is/span span class=\"n\"bf3/spanspan class=\"p\"[/spanspan class=\"mi\"1/spanspan class=\"p\"]/span span class=\"ow\"is/span span class=\"n\"aRight/span span class=\"ow\"and/span\n            span class=\"n\"bf1/spanspan class=\"p\"[/spanspan class=\"mi\"2/spanspan class=\"p\"]/span span class=\"o\"+/span span class=\"n\"bf2/spanspan class=\"p\"[/spanspan class=\"mi\"2/spanspan class=\"p\"]/span span class=\"o\"+/span span class=\"n\"bf3/spanspan class=\"p\"[/spanspan class=\"mi\"2/spanspan class=\"p\"]/span span class=\"o\"==/span span class=\"mi\"0/spanspan class=\"p\")/span\n\nspan class=\"k\"def/span span class=\"nf\"loop/spanspan class=\"p\"(/spanspan class=\"bp\"self/spanspan class=\"p\",/span span class=\"n\"bfs/spanspan class=\"p\"):/span\n    span class=\"k\"if/span span class=\"nb\"len/spanspan class=\"p\"(/spanspan class=\"n\"bfs/spanspan class=\"p\")/span span class=\"o\"==/span span class=\"mi\"1/spanspan class=\"p\":/span\n        span class=\"n\"bf/spanspan class=\"p\",/span span class=\"n\"ad/spanspan class=\"p\",/span span class=\"n\"imm/span span class=\"o\"=/span span class=\"n\"bfs/spanspan class=\"p\"[/spanspan class=\"mi\"0/spanspan class=\"p\"]/span\n        span class=\"k\"if/span span class=\"n\"ad/span span class=\"ow\"is/span span class=\"n\"anAdd/span span class=\"ow\"and/span span class=\"n\"imm/span span class=\"ow\"in/span span class=\"p\"(/spanspan class=\"mi\"1/spanspan class=\"p\",/span span class=\"o\"-/spanspan class=\"mi\"1/spanspan class=\"p\"):/span\n            span class=\"k\"return/span span class=\"p\"[(/spanspan class=\"n\"domain/spanspan class=\"o\"./spanspan class=\"n\"zero/spanspan class=\"p\"(),/span span class=\"n\"aZero/spanspan class=\"p\",/span span class=\"mi\"0/spanspan class=\"p\")]/span\n    span class=\"k\"elif/span span class=\"nb\"len/spanspan class=\"p\"(/spanspan class=\"n\"bfs/spanspan class=\"p\")/span span class=\"o\"==/span span class=\"mi\"4/spanspan class=\"p\":/span\n        span class=\"k\"if/span span class=\"p\"(/spanspan class=\"n\"isConstAdd/spanspan class=\"p\"(/spanspan class=\"n\"bfs/spanspan class=\"p\"[/spanspan class=\"mi\"0/spanspan class=\"p\"],/span span class=\"o\"-/spanspan class=\"mi\"1/spanspan class=\"p\")/span span class=\"ow\"and/span\n            span class=\"n\"bfs/spanspan class=\"p\"[/spanspan class=\"mi\"2/spanspan class=\"p\"][/spanspan class=\"mi\"1/spanspan class=\"p\"]/span span class=\"ow\"is/span span class=\"n\"anAdd/span span class=\"ow\"and/span\n            span class=\"n\"oppositeShifts/spanspan class=\"p\"(/spanspan class=\"n\"bfs/spanspan class=\"p\"[/spanspan class=\"mi\"1/spanspan class=\"p\"],/span span class=\"n\"bfs/spanspan class=\"p\"[/spanspan class=\"mi\"3/spanspan class=\"p\"])):/span\n            span class=\"k\"return/span span class=\"p\"[(/spanspan class=\"n\"domain/spanspan class=\"o\"./spanspan class=\"n\"scalemove/spanspan class=\"p\"(/spanspan class=\"n\"bfs/spanspan class=\"p\"[/spanspan class=\"mi\"1/spanspan class=\"p\"][/spanspan class=\"mi\"2/spanspan class=\"p\"],/span span class=\"n\"bfs/spanspan class=\"p\"[/spanspan class=\"mi\"2/spanspan class=\"p\"][/spanspan class=\"mi\"2/spanspan class=\"p\"]),/span span class=\"n\"aLoop/spanspan class=\"p\",/span span class=\"mi\"0/spanspan class=\"p\")]/span\n        span class=\"k\"if/span span class=\"p\"(/spanspan class=\"n\"isConstAdd/spanspan class=\"p\"(/spanspan class=\"n\"bfs/spanspan class=\"p\"[/spanspan class=\"mi\"3/spanspan class=\"p\"],/span span class=\"o\"-/spanspan class=\"mi\"1/spanspan class=\"p\")/span span class=\"ow\"and/span\n            span class=\"n\"bfs/spanspan class=\"p\"[/spanspan class=\"mi\"1/spanspan class=\"p\"][/spanspan class=\"mi\"1/spanspan class=\"p\"]/span span class=\"ow\"is/span span class=\"n\"anAdd/span span class=\"ow\"and/span\n            span class=\"n\"oppositeShifts/spanspan class=\"p\"(/spanspan class=\"n\"bfs/spanspan class=\"p\"[/spanspan class=\"mi\"0/spanspan class=\"p\"],/span span class=\"n\"bfs/spanspan class=\"p\"[/spanspan class=\"mi\"2/spanspan class=\"p\"])):/span\n            span class=\"k\"return/span span class=\"p\"[(/spanspan class=\"n\"domain/spanspan class=\"o\"./spanspan class=\"n\"scalemove/spanspan class=\"p\"(/spanspan class=\"n\"bfs/spanspan class=\"p\"[/spanspan class=\"mi\"0/spanspan class=\"p\"][/spanspan class=\"mi\"2/spanspan class=\"p\"],/span span class=\"n\"bfs/spanspan class=\"p\"[/spanspan class=\"mi\"1/spanspan class=\"p\"][/spanspan class=\"mi\"2/spanspan class=\"p\"]),/span span class=\"n\"aLoop/spanspan class=\"p\",/span span class=\"mi\"0/spanspan class=\"p\")]/span\n    span class=\"k\"elif/span span class=\"nb\"len/spanspan class=\"p\"(/spanspan class=\"n\"bfs/spanspan class=\"p\")/span span class=\"o\"==/span span class=\"mi\"6/spanspan class=\"p\":/span\n        span class=\"k\"if/span span class=\"p\"(/spanspan class=\"n\"isConstAdd/spanspan class=\"p\"(/spanspan class=\"n\"bfs/spanspan class=\"p\"[/spanspan class=\"mi\"0/spanspan class=\"p\"],/span span class=\"o\"-/spanspan class=\"mi\"1/spanspan class=\"p\")/span span class=\"ow\"and/span\n            span class=\"n\"bfs/spanspan class=\"p\"[/spanspan class=\"mi\"2/spanspan class=\"p\"][/spanspan class=\"mi\"1/spanspan class=\"p\"]/span span class=\"ow\"is/span span class=\"n\"bfs/spanspan class=\"p\"[/spanspan class=\"mi\"4/spanspan class=\"p\"][/spanspan class=\"mi\"1/spanspan class=\"p\"]/span span class=\"ow\"is/span span class=\"n\"anAdd/span span class=\"ow\"and/span\n            span class=\"n\"oppositeShifts2/spanspan class=\"p\"(/spanspan class=\"n\"bfs/spanspan class=\"p\"[/spanspan class=\"mi\"1/spanspan class=\"p\"],/span span class=\"n\"bfs/spanspan class=\"p\"[/spanspan class=\"mi\"3/spanspan class=\"p\"],/span span class=\"n\"bfs/spanspan class=\"p\"[/spanspan class=\"mi\"5/spanspan class=\"p\"])):/span\n            span class=\"k\"return/span span class=\"p\"[(/spanspan class=\"n\"domain/spanspan class=\"o\"./spanspan class=\"n\"scalemove2/spanspan class=\"p\"(/spanspan class=\"n\"bfs/spanspan class=\"p\"[/spanspan class=\"mi\"1/spanspan class=\"p\"][/spanspan class=\"mi\"2/spanspan class=\"p\"],/span span class=\"n\"bfs/spanspan class=\"p\"[/spanspan class=\"mi\"2/spanspan class=\"p\"][/spanspan class=\"mi\"2/spanspan class=\"p\"],/span\n                                       span class=\"n\"bfs/spanspan class=\"p\"[/spanspan class=\"mi\"1/spanspan class=\"p\"][/spanspan class=\"mi\"2/spanspan class=\"p\"]/span span class=\"o\"+/span span class=\"n\"bfs/spanspan class=\"p\"[/spanspan class=\"mi\"3/spanspan class=\"p\"][/spanspan class=\"mi\"2/spanspan class=\"p\"],/span\n                                       span class=\"n\"bfs/spanspan class=\"p\"[/spanspan class=\"mi\"4/spanspan class=\"p\"][/spanspan class=\"mi\"2/spanspan class=\"p\"]),/span span class=\"n\"aLoop/spanspan class=\"p\",/span span class=\"mi\"0/spanspan class=\"p\")]/span\n        span class=\"k\"if/span span class=\"p\"(/spanspan class=\"n\"isConstAdd/spanspan class=\"p\"(/spanspan class=\"n\"bfs/spanspan class=\"p\"[/spanspan class=\"mi\"5/spanspan class=\"p\"],/span span class=\"o\"-/spanspan class=\"mi\"1/spanspan class=\"p\")/span span class=\"ow\"and/span\n            span class=\"n\"bfs/spanspan class=\"p\"[/spanspan class=\"mi\"1/spanspan class=\"p\"][/spanspan class=\"mi\"1/spanspan class=\"p\"]/span span class=\"ow\"is/span span class=\"n\"bfs/spanspan class=\"p\"[/spanspan class=\"mi\"3/spanspan class=\"p\"][/spanspan class=\"mi\"1/spanspan class=\"p\"]/span span class=\"ow\"is/span span class=\"n\"anAdd/span span class=\"ow\"and/span\n            span class=\"n\"oppositeShifts2/spanspan class=\"p\"(/spanspan class=\"n\"bfs/spanspan class=\"p\"[/spanspan class=\"mi\"0/spanspan class=\"p\"],/span span class=\"n\"bfs/spanspan class=\"p\"[/spanspan class=\"mi\"2/spanspan class=\"p\"],/span span class=\"n\"bfs/spanspan class=\"p\"[/spanspan class=\"mi\"4/spanspan class=\"p\"])):/span\n            span class=\"k\"return/span span class=\"p\"[(/spanspan class=\"n\"domain/spanspan class=\"o\"./spanspan class=\"n\"scalemove2/spanspan class=\"p\"(/spanspan class=\"n\"bfs/spanspan class=\"p\"[/spanspan class=\"mi\"0/spanspan class=\"p\"][/spanspan class=\"mi\"2/spanspan class=\"p\"],/span span class=\"n\"bfs/spanspan class=\"p\"[/spanspan class=\"mi\"1/spanspan class=\"p\"][/spanspan class=\"mi\"2/spanspan class=\"p\"],/span\n                                       span class=\"n\"bfs/spanspan class=\"p\"[/spanspan class=\"mi\"0/spanspan class=\"p\"][/spanspan class=\"mi\"2/spanspan class=\"p\"]/span span class=\"o\"+/span span class=\"n\"bfs/spanspan class=\"p\"[/spanspan class=\"mi\"2/spanspan class=\"p\"][/spanspan class=\"mi\"2/spanspan class=\"p\"],/span\n                                       span class=\"n\"bfs/spanspan class=\"p\"[/spanspan class=\"mi\"3/spanspan class=\"p\"][/spanspan class=\"mi\"2/spanspan class=\"p\"]),/span span class=\"n\"aLoop/spanspan class=\"p\",/span span class=\"mi\"0/spanspan class=\"p\")]/span\n    span class=\"k\"return/span span class=\"p\"[(/spanspan class=\"n\"domain/spanspan class=\"o\"./spanspan class=\"n\"loop/spanspan class=\"p\"(/spanspan class=\"n\"stripDomain/spanspan class=\"p\"(/spanspan class=\"n\"bfs/spanspan class=\"p\")),/span span class=\"n\"aLoop/spanspan class=\"p\",/span span class=\"mi\"0/spanspan class=\"p\")]/span\n/pre/div\n\npThis ends the bonus question. How do we optimize an unknown semantic domain?\nWe must maintain an abstract context which describes elements of the domain.\nIn initial encoding, we ask an AST about itself. In final encoding, we already\nknow everything relevant about the AST./p\npThe careful reader will see that I didn't really answer that opening question\nin the JIT section. Because the JIT still ranges over the same operations as\nbefore, it can't really be slower; but why is it now faster? Because the\noptimizer is now slightly better in a few edge cases. It performs the same\noptimizations as before, but the rigor of abstract interpretation causes it to\nemit slightly better operations to the JIT backend./p\npConcretely, improving the optimizer can shorten pretty-printed programs. The\na href=\"https://bbgauge.info/\"Busy Beaver Gauge/a measures the length of programs\nwhich search for solutions to mathematical problems. After implementing and\ndebugging the final-encoded interpreter, I found that two of my entries on the\na href=\"https://bbgauge.info/brainfuck.html\"Busy Beaver Gauge for Brainfuck/a had\nbecome shorter by about 2%. (Most other entries are already hand-optimized\naccording to the standard algebra and have no optimization opportunities.)/p\nh3 id=\"discussion\"Discussion/h3\npGiven that initial and final encodings are equivalent, and noting that\nRPython's toolchain is written to prefer initial encodings, what did we\nactually gain? Did we gain anything?/p\npOne obvious downside to final encoding in RPython is interpreter size. The\nexample interpreter shown here is a rewrite of an initial-encoded interpreter\nwhich can be seen\na href=\"https://github.com/rpypkgs/rpypkgs/blob/659c8a26d428a1e04fdff614b28e464a50d4647b/bf/bf.py\"here/a\nfor comparison. Final encoding adds about 20% more code in this case./p\npFinal encoding is not necessarily more code than initial encoding, though. All\nAST encodings in interpreters are subject to the a href=\"https://en.wikipedia.org/wiki/Expression_problem\"Expression\nProblem/a, which states that\nthere is generally a quadratic amount of code required to implement multiple\nbehaviors for an AST with multiple types of nodes; specifically, emn/em behaviors\nfor emm/em types of nodes require emn/em  emm/em methods. Initial encodings improve the\ncost of adding new types of nodes; final encodings improve the cost of adding\nnew behaviors. Final encoding may tend to win in large codebases for mature\nlanguages, where the language does not change often but new behaviors are added\nfrequently and maintained for long periods./p\npOptimizations in final encoding require a bit of planning. The\nabstract-interpretation approach is solid but relies upon the monoid and its\nalgebraic laws. In the worst case, an entire class hierarchy could be required\nto encode the abstraction./p\npIt is remarkable to find stronga 2% improvement in residual program size/strong merely\nby reimplementing an optimizer as an abstract interpreter respecting the\nalgebraic laws. This could be the most important lesson for compiler\nengineers, if it happens to generalize./p\npFinal encoding was popularized via the tagless-final movement in OCaml and\nScala, including famously in a series of tutorials by a href=\"https://okmij.org/ftp/tagless-final/\"Kiselyov et\nal/a. A \"tag\", in this jargon, is a\nruntime identifier for an object's type or class; a tagless encoding\neffectively doesn't allow codeisinstance()/code at all. In the above presentation,\ntags could be hacked in, but were not materially relevant to most steps. Tags\nwere required for the final evaluation step, though, and the tagless-final\ninsight is that certain type systems can express type-safe evaluation without\nthose tags. We won't go further in this direction because tags also\ncommunicate valuable information to the JIT./p\nh4 id=\"summarizing-table\"Summarizing Table/h4\ntable\nthead\ntr\nthInitial Encoding/th\nthFinal Encoding/th\n/tr\n/thead\ntbody\ntr\ntdhierarchy of classes/td\ntdsignature of interfaces/td\n/tr\ntr\ntdclass constructors/td\ntdmethod calls/td\n/tr\ntr\ntdbuilt on the heap/td\ntdbuilt on the stack/td\n/tr\ntr\ntdtraversals allocate stack/td\ntdtraversals allocate heap/td\n/tr\ntr\ntdtags are available with codeisinstance()/code/td\ntdtags are only available through hacks/td\n/tr\ntr\ntdcost of adding a new AST node: one class/td\ntdcost of adding a new AST node: one method on every other class/td\n/tr\ntr\ntdcost of adding a new behavior: one method on every other class/td\ntdcost of adding a new behavior: one class/td\n/tr\n/tbody\n/table\nh3 id=\"credits\"Credits/h3\npThanks to folks in code#pypy/code on Libera Chat: arigato for the idea, larstiq for\npushing me to write it up, and cfbolz and mattip for reviewing and finding\nmistakes. The original IRC discussion leading to this blog post is available\na href=\"https://gist.github.com/MostAwesomeDude/fd86ad2d2e38af7aa67b6e548aabe008\"here/a./p\npThis interpreter is part of the a href=\"https://github.com/rpypkgs/rpypkgs\"rpypkgs/a\nsuite, a Nix flake for RPython interpreters. Readers with Nix installed can\nrun this interpreter directly from the flake:/p\ndiv class=\"code\"pre class=\"code literal-block\"$span class=\"w\" /spannix-prefetch-urlspan class=\"w\" /spanhttps://github.com/MG-K/pypy-tutorial-ko/raw/refs/heads/master/mandel.b\n$span class=\"w\" /spannixspan class=\"w\" /spanrunspan class=\"w\" /spangithub:rpypkgs/rpypkgs#bfspan class=\"w\" /span--span class=\"w\" /span/nix/store/ngnphbap9ncvz41d0fkvdh61n7j2bg21-mandel.b\n/pre/div",
      "link": "https://www.pypy.org/posts/2024/11/guest-post-final-encoding-in-rpython.html",
      "links": [],
      "published": "2024-11-14T08:42:36+00:00",
      "summary": "",
      "title": "Guest Post: Final Encoding in RPython Interpreters"
    },
    {
      "author": "CF Bolz-Tereick",
      "content": [
        {
          "type": "text/html",
          "value": "pAs is probably apparent from the sequence of blog posts about the topic in the\nlast year, I have been thinking about and working on integer optimizations in the JIT\ncompiler a lot. This work was mainly motivated by a class=\"reference external\" href=\"https://docs.pydrofoil.org/en/latest/\"Pydrofoil/a, where integer\noperations matter a lot more than for your typical Python program./p\npIn this post I'll describe my most recent change, which is a new small domain\nspecific language that I implemented to specify peephole optimizations on\ninteger operations in the JIT.\nIt uses pattern matching to specify how (sequences of) integer operations\nshould be simplified and optimized. The rules are then compiled to\nRPython code that then becomes part of the JIT's optimization passes./p\npTo make it less likely to introduce incorrect optimizations into the JIT, the\nrules are automatically proven correct with Z3 as part of the build process (for\na more hands-on intro to how that works you can look at the a class=\"reference external\" href=\"https://pypy.org/posts/2024/08/toy-knownbits.html#proving-correctness-of-the-transfer-functions-with-z3\"knownbits/a post).\nIn this blog post I want to motivate why I introduced the DSL and give an\nintroduction to how it works./p\nsection id=\"motivation\"\nh2Motivation/h2\npThis summer, after I wrote my a class=\"reference external\" href=\"https://www.pypy.org/posts/2024/07/mining-jit-traces-missing-optimizations-z3.html\"scripts to mine JIT traces for missed optimization/a\nopportunities, I started implementing a few of the integer peephole rewrite that\nthe script identified. Unfortunately, doing so led to the problem that the way\nwe express these rewrites up to now is very imperative and verbose. Here's a\nsnippet of RPython code that shows some rewrites for integer multiplication\n(look at the comments to see what the different parts actually do). You don't\nneed to understand the code in detail, but basically it's in very imperative\nstyle and there's quite a lot of boilerplate./p\ndiv class=\"code\"pre class=\"code python\"a id=\"rest_code_7d5885c533384778ba70ebd63601716c-1\" name=\"rest_code_7d5885c533384778ba70ebd63601716c-1\" href=\"https://www.pypy.org/posts/2024/10/jit-peephole-dsl.html#rest_code_7d5885c533384778ba70ebd63601716c-1\"/aspan class=\"k\"def/span span class=\"nf\"optimize_INT_MUL/spanspan class=\"p\"(/spanspan class=\"bp\"self/spanspan class=\"p\",/span span class=\"n\"op/spanspan class=\"p\"):/span\na id=\"rest_code_7d5885c533384778ba70ebd63601716c-2\" name=\"rest_code_7d5885c533384778ba70ebd63601716c-2\" href=\"https://www.pypy.org/posts/2024/10/jit-peephole-dsl.html#rest_code_7d5885c533384778ba70ebd63601716c-2\"/a    span class=\"n\"arg0/span span class=\"o\"=/span span class=\"n\"get_box_replacement/spanspan class=\"p\"(/spanspan class=\"n\"op/spanspan class=\"o\"./spanspan class=\"n\"getarg/spanspan class=\"p\"(/spanspan class=\"mi\"0/spanspan class=\"p\"))/span\na id=\"rest_code_7d5885c533384778ba70ebd63601716c-3\" name=\"rest_code_7d5885c533384778ba70ebd63601716c-3\" href=\"https://www.pypy.org/posts/2024/10/jit-peephole-dsl.html#rest_code_7d5885c533384778ba70ebd63601716c-3\"/a    span class=\"n\"b0/span span class=\"o\"=/span span class=\"bp\"self/spanspan class=\"o\"./spanspan class=\"n\"getintbound/spanspan class=\"p\"(/spanspan class=\"n\"arg0/spanspan class=\"p\")/span\na id=\"rest_code_7d5885c533384778ba70ebd63601716c-4\" name=\"rest_code_7d5885c533384778ba70ebd63601716c-4\" href=\"https://www.pypy.org/posts/2024/10/jit-peephole-dsl.html#rest_code_7d5885c533384778ba70ebd63601716c-4\"/a    span class=\"n\"arg1/span span class=\"o\"=/span span class=\"n\"get_box_replacement/spanspan class=\"p\"(/spanspan class=\"n\"op/spanspan class=\"o\"./spanspan class=\"n\"getarg/spanspan class=\"p\"(/spanspan class=\"mi\"1/spanspan class=\"p\"))/span\na id=\"rest_code_7d5885c533384778ba70ebd63601716c-5\" name=\"rest_code_7d5885c533384778ba70ebd63601716c-5\" href=\"https://www.pypy.org/posts/2024/10/jit-peephole-dsl.html#rest_code_7d5885c533384778ba70ebd63601716c-5\"/a    span class=\"n\"b1/span span class=\"o\"=/span span class=\"bp\"self/spanspan class=\"o\"./spanspan class=\"n\"getintbound/spanspan class=\"p\"(/spanspan class=\"n\"arg1/spanspan class=\"p\")/span\na id=\"rest_code_7d5885c533384778ba70ebd63601716c-6\" name=\"rest_code_7d5885c533384778ba70ebd63601716c-6\" href=\"https://www.pypy.org/posts/2024/10/jit-peephole-dsl.html#rest_code_7d5885c533384778ba70ebd63601716c-6\"/a\na id=\"rest_code_7d5885c533384778ba70ebd63601716c-7\" name=\"rest_code_7d5885c533384778ba70ebd63601716c-7\" href=\"https://www.pypy.org/posts/2024/10/jit-peephole-dsl.html#rest_code_7d5885c533384778ba70ebd63601716c-7\"/a    span class=\"k\"if/span span class=\"n\"b0/spanspan class=\"o\"./spanspan class=\"n\"known_eq_const/spanspan class=\"p\"(/spanspan class=\"mi\"1/spanspan class=\"p\"):/span\na id=\"rest_code_7d5885c533384778ba70ebd63601716c-8\" name=\"rest_code_7d5885c533384778ba70ebd63601716c-8\" href=\"https://www.pypy.org/posts/2024/10/jit-peephole-dsl.html#rest_code_7d5885c533384778ba70ebd63601716c-8\"/a        span class=\"c1\"# 1 * x == x/span\na id=\"rest_code_7d5885c533384778ba70ebd63601716c-9\" name=\"rest_code_7d5885c533384778ba70ebd63601716c-9\" href=\"https://www.pypy.org/posts/2024/10/jit-peephole-dsl.html#rest_code_7d5885c533384778ba70ebd63601716c-9\"/a        span class=\"bp\"self/spanspan class=\"o\"./spanspan class=\"n\"make_equal_to/spanspan class=\"p\"(/spanspan class=\"n\"op/spanspan class=\"p\",/span span class=\"n\"arg1/spanspan class=\"p\")/span\na id=\"rest_code_7d5885c533384778ba70ebd63601716c-10\" name=\"rest_code_7d5885c533384778ba70ebd63601716c-10\" href=\"https://www.pypy.org/posts/2024/10/jit-peephole-dsl.html#rest_code_7d5885c533384778ba70ebd63601716c-10\"/a    span class=\"k\"elif/span span class=\"n\"b1/spanspan class=\"o\"./spanspan class=\"n\"known_eq_const/spanspan class=\"p\"(/spanspan class=\"mi\"1/spanspan class=\"p\"):/span\na id=\"rest_code_7d5885c533384778ba70ebd63601716c-11\" name=\"rest_code_7d5885c533384778ba70ebd63601716c-11\" href=\"https://www.pypy.org/posts/2024/10/jit-peephole-dsl.html#rest_code_7d5885c533384778ba70ebd63601716c-11\"/a        span class=\"c1\"# x * 1 == x/span\na id=\"rest_code_7d5885c533384778ba70ebd63601716c-12\" name=\"rest_code_7d5885c533384778ba70ebd63601716c-12\" href=\"https://www.pypy.org/posts/2024/10/jit-peephole-dsl.html#rest_code_7d5885c533384778ba70ebd63601716c-12\"/a        span class=\"bp\"self/spanspan class=\"o\"./spanspan class=\"n\"make_equal_to/spanspan class=\"p\"(/spanspan class=\"n\"op/spanspan class=\"p\",/span span class=\"n\"arg0/spanspan class=\"p\")/span\na id=\"rest_code_7d5885c533384778ba70ebd63601716c-13\" name=\"rest_code_7d5885c533384778ba70ebd63601716c-13\" href=\"https://www.pypy.org/posts/2024/10/jit-peephole-dsl.html#rest_code_7d5885c533384778ba70ebd63601716c-13\"/a    span class=\"k\"elif/span span class=\"n\"b0/spanspan class=\"o\"./spanspan class=\"n\"known_eq_const/spanspan class=\"p\"(/spanspan class=\"mi\"0/spanspan class=\"p\")/span span class=\"ow\"or/span span class=\"n\"b1/spanspan class=\"o\"./spanspan class=\"n\"known_eq_const/spanspan class=\"p\"(/spanspan class=\"mi\"0/spanspan class=\"p\"):/span\na id=\"rest_code_7d5885c533384778ba70ebd63601716c-14\" name=\"rest_code_7d5885c533384778ba70ebd63601716c-14\" href=\"https://www.pypy.org/posts/2024/10/jit-peephole-dsl.html#rest_code_7d5885c533384778ba70ebd63601716c-14\"/a        span class=\"c1\"# 0 * x == x * 0 == 0/span\na id=\"rest_code_7d5885c533384778ba70ebd63601716c-15\" name=\"rest_code_7d5885c533384778ba70ebd63601716c-15\" href=\"https://www.pypy.org/posts/2024/10/jit-peephole-dsl.html#rest_code_7d5885c533384778ba70ebd63601716c-15\"/a        span class=\"bp\"self/spanspan class=\"o\"./spanspan class=\"n\"make_constant_int/spanspan class=\"p\"(/spanspan class=\"n\"op/spanspan class=\"p\",/span span class=\"mi\"0/spanspan class=\"p\")/span\na id=\"rest_code_7d5885c533384778ba70ebd63601716c-16\" name=\"rest_code_7d5885c533384778ba70ebd63601716c-16\" href=\"https://www.pypy.org/posts/2024/10/jit-peephole-dsl.html#rest_code_7d5885c533384778ba70ebd63601716c-16\"/a    span class=\"k\"else/spanspan class=\"p\":/span\na id=\"rest_code_7d5885c533384778ba70ebd63601716c-17\" name=\"rest_code_7d5885c533384778ba70ebd63601716c-17\" href=\"https://www.pypy.org/posts/2024/10/jit-peephole-dsl.html#rest_code_7d5885c533384778ba70ebd63601716c-17\"/a        span class=\"k\"for/span span class=\"n\"lhs/spanspan class=\"p\",/span span class=\"n\"rhs/span span class=\"ow\"in/span span class=\"p\"[(/spanspan class=\"n\"arg0/spanspan class=\"p\",/span span class=\"n\"arg1/spanspan class=\"p\"),/span span class=\"p\"(/spanspan class=\"n\"arg1/spanspan class=\"p\",/span span class=\"n\"arg0/spanspan class=\"p\")]:/span\na id=\"rest_code_7d5885c533384778ba70ebd63601716c-18\" name=\"rest_code_7d5885c533384778ba70ebd63601716c-18\" href=\"https://www.pypy.org/posts/2024/10/jit-peephole-dsl.html#rest_code_7d5885c533384778ba70ebd63601716c-18\"/a            span class=\"n\"lh_info/span span class=\"o\"=/span span class=\"bp\"self/spanspan class=\"o\"./spanspan class=\"n\"getintbound/spanspan class=\"p\"(/spanspan class=\"n\"lhs/spanspan class=\"p\")/span\na id=\"rest_code_7d5885c533384778ba70ebd63601716c-19\" name=\"rest_code_7d5885c533384778ba70ebd63601716c-19\" href=\"https://www.pypy.org/posts/2024/10/jit-peephole-dsl.html#rest_code_7d5885c533384778ba70ebd63601716c-19\"/a            span class=\"k\"if/span span class=\"n\"lh_info/spanspan class=\"o\"./spanspan class=\"n\"is_constant/spanspan class=\"p\"():/span\na id=\"rest_code_7d5885c533384778ba70ebd63601716c-20\" name=\"rest_code_7d5885c533384778ba70ebd63601716c-20\" href=\"https://www.pypy.org/posts/2024/10/jit-peephole-dsl.html#rest_code_7d5885c533384778ba70ebd63601716c-20\"/a                span class=\"n\"x/span span class=\"o\"=/span span class=\"n\"lh_info/spanspan class=\"o\"./spanspan class=\"n\"get_constant_int/spanspan class=\"p\"()/span\na id=\"rest_code_7d5885c533384778ba70ebd63601716c-21\" name=\"rest_code_7d5885c533384778ba70ebd63601716c-21\" href=\"https://www.pypy.org/posts/2024/10/jit-peephole-dsl.html#rest_code_7d5885c533384778ba70ebd63601716c-21\"/a                span class=\"k\"if/span span class=\"n\"x/span span class=\"o\"amp;/span span class=\"p\"(/spanspan class=\"n\"x/span span class=\"o\"-/span span class=\"mi\"1/spanspan class=\"p\")/span span class=\"o\"==/span span class=\"mi\"0/spanspan class=\"p\":/span\na id=\"rest_code_7d5885c533384778ba70ebd63601716c-22\" name=\"rest_code_7d5885c533384778ba70ebd63601716c-22\" href=\"https://www.pypy.org/posts/2024/10/jit-peephole-dsl.html#rest_code_7d5885c533384778ba70ebd63601716c-22\"/a                    span class=\"c1\"# x * (2 ** c) == x lt;lt; c/span\na id=\"rest_code_7d5885c533384778ba70ebd63601716c-23\" name=\"rest_code_7d5885c533384778ba70ebd63601716c-23\" href=\"https://www.pypy.org/posts/2024/10/jit-peephole-dsl.html#rest_code_7d5885c533384778ba70ebd63601716c-23\"/a                    span class=\"n\"new_rhs/span span class=\"o\"=/span span class=\"n\"ConstInt/spanspan class=\"p\"(/spanspan class=\"n\"highest_bit/spanspan class=\"p\"(/spanspan class=\"n\"lh_info/spanspan class=\"o\"./spanspan class=\"n\"get_constant_int/spanspan class=\"p\"()))/span\na id=\"rest_code_7d5885c533384778ba70ebd63601716c-24\" name=\"rest_code_7d5885c533384778ba70ebd63601716c-24\" href=\"https://www.pypy.org/posts/2024/10/jit-peephole-dsl.html#rest_code_7d5885c533384778ba70ebd63601716c-24\"/a                    span class=\"n\"op/span span class=\"o\"=/span span class=\"bp\"self/spanspan class=\"o\"./spanspan class=\"n\"replace_op_with/spanspan class=\"p\"(/spanspan class=\"n\"op/spanspan class=\"p\",/span span class=\"n\"rop/spanspan class=\"o\"./spanspan class=\"n\"INT_LSHIFT/spanspan class=\"p\",/span span class=\"n\"args/spanspan class=\"o\"=/spanspan class=\"p\"[/spanspan class=\"n\"rhs/spanspan class=\"p\",/span span class=\"n\"new_rhs/spanspan class=\"p\"])/span\na id=\"rest_code_7d5885c533384778ba70ebd63601716c-25\" name=\"rest_code_7d5885c533384778ba70ebd63601716c-25\" href=\"https://www.pypy.org/posts/2024/10/jit-peephole-dsl.html#rest_code_7d5885c533384778ba70ebd63601716c-25\"/a                    span class=\"bp\"self/spanspan class=\"o\"./spanspan class=\"n\"optimizer/spanspan class=\"o\"./spanspan class=\"n\"send_extra_operation/spanspan class=\"p\"(/spanspan class=\"n\"op/spanspan class=\"p\")/span\na id=\"rest_code_7d5885c533384778ba70ebd63601716c-26\" name=\"rest_code_7d5885c533384778ba70ebd63601716c-26\" href=\"https://www.pypy.org/posts/2024/10/jit-peephole-dsl.html#rest_code_7d5885c533384778ba70ebd63601716c-26\"/a                    span class=\"k\"return/span\na id=\"rest_code_7d5885c533384778ba70ebd63601716c-27\" name=\"rest_code_7d5885c533384778ba70ebd63601716c-27\" href=\"https://www.pypy.org/posts/2024/10/jit-peephole-dsl.html#rest_code_7d5885c533384778ba70ebd63601716c-27\"/a                span class=\"k\"elif/span span class=\"n\"x/span span class=\"o\"==/span span class=\"o\"-/spanspan class=\"mi\"1/spanspan class=\"p\":/span\na id=\"rest_code_7d5885c533384778ba70ebd63601716c-28\" name=\"rest_code_7d5885c533384778ba70ebd63601716c-28\" href=\"https://www.pypy.org/posts/2024/10/jit-peephole-dsl.html#rest_code_7d5885c533384778ba70ebd63601716c-28\"/a                    span class=\"c1\"# x * -1 == -x/span\na id=\"rest_code_7d5885c533384778ba70ebd63601716c-29\" name=\"rest_code_7d5885c533384778ba70ebd63601716c-29\" href=\"https://www.pypy.org/posts/2024/10/jit-peephole-dsl.html#rest_code_7d5885c533384778ba70ebd63601716c-29\"/a                    span class=\"n\"op/span span class=\"o\"=/span span class=\"bp\"self/spanspan class=\"o\"./spanspan class=\"n\"replace_op_with/spanspan class=\"p\"(/spanspan class=\"n\"op/spanspan class=\"p\",/span span class=\"n\"rop/spanspan class=\"o\"./spanspan class=\"n\"INT_NEG/spanspan class=\"p\",/span span class=\"n\"args/spanspan class=\"o\"=/spanspan class=\"p\"[/spanspan class=\"n\"rhs/spanspan class=\"p\"])/span\na id=\"rest_code_7d5885c533384778ba70ebd63601716c-30\" name=\"rest_code_7d5885c533384778ba70ebd63601716c-30\" href=\"https://www.pypy.org/posts/2024/10/jit-peephole-dsl.html#rest_code_7d5885c533384778ba70ebd63601716c-30\"/a                    span class=\"bp\"self/spanspan class=\"o\"./spanspan class=\"n\"optimizer/spanspan class=\"o\"./spanspan class=\"n\"send_extra_operation/spanspan class=\"p\"(/spanspan class=\"n\"op/spanspan class=\"p\")/span\na id=\"rest_code_7d5885c533384778ba70ebd63601716c-31\" name=\"rest_code_7d5885c533384778ba70ebd63601716c-31\" href=\"https://www.pypy.org/posts/2024/10/jit-peephole-dsl.html#rest_code_7d5885c533384778ba70ebd63601716c-31\"/a                    span class=\"k\"return/span\na id=\"rest_code_7d5885c533384778ba70ebd63601716c-32\" name=\"rest_code_7d5885c533384778ba70ebd63601716c-32\" href=\"https://www.pypy.org/posts/2024/10/jit-peephole-dsl.html#rest_code_7d5885c533384778ba70ebd63601716c-32\"/a            span class=\"k\"else/spanspan class=\"p\":/span\na id=\"rest_code_7d5885c533384778ba70ebd63601716c-33\" name=\"rest_code_7d5885c533384778ba70ebd63601716c-33\" href=\"https://www.pypy.org/posts/2024/10/jit-peephole-dsl.html#rest_code_7d5885c533384778ba70ebd63601716c-33\"/a                span class=\"c1\"# x * (1 lt;lt; y) == x lt;lt; y/span\na id=\"rest_code_7d5885c533384778ba70ebd63601716c-34\" name=\"rest_code_7d5885c533384778ba70ebd63601716c-34\" href=\"https://www.pypy.org/posts/2024/10/jit-peephole-dsl.html#rest_code_7d5885c533384778ba70ebd63601716c-34\"/a                span class=\"n\"shiftop/span span class=\"o\"=/span span class=\"bp\"self/spanspan class=\"o\"./spanspan class=\"n\"optimizer/spanspan class=\"o\"./spanspan class=\"n\"as_operation/spanspan class=\"p\"(/spanspan class=\"n\"get_box_replacement/spanspan class=\"p\"(/spanspan class=\"n\"lhs/spanspan class=\"p\"),/span span class=\"n\"rop/spanspan class=\"o\"./spanspan class=\"n\"INT_LSHIFT/spanspan class=\"p\")/span\na id=\"rest_code_7d5885c533384778ba70ebd63601716c-35\" name=\"rest_code_7d5885c533384778ba70ebd63601716c-35\" href=\"https://www.pypy.org/posts/2024/10/jit-peephole-dsl.html#rest_code_7d5885c533384778ba70ebd63601716c-35\"/a                span class=\"k\"if/span span class=\"n\"shiftop/span span class=\"ow\"is/span span class=\"kc\"None/spanspan class=\"p\":/span\na id=\"rest_code_7d5885c533384778ba70ebd63601716c-36\" name=\"rest_code_7d5885c533384778ba70ebd63601716c-36\" href=\"https://www.pypy.org/posts/2024/10/jit-peephole-dsl.html#rest_code_7d5885c533384778ba70ebd63601716c-36\"/a                    span class=\"k\"continue/span\na id=\"rest_code_7d5885c533384778ba70ebd63601716c-37\" name=\"rest_code_7d5885c533384778ba70ebd63601716c-37\" href=\"https://www.pypy.org/posts/2024/10/jit-peephole-dsl.html#rest_code_7d5885c533384778ba70ebd63601716c-37\"/a                span class=\"k\"if/span span class=\"ow\"not/span span class=\"n\"shiftop/spanspan class=\"o\"./spanspan class=\"n\"getarg/spanspan class=\"p\"(/spanspan class=\"mi\"0/spanspan class=\"p\")/spanspan class=\"o\"./spanspan class=\"n\"is_constant/spanspan class=\"p\"()/span span class=\"ow\"or/span span class=\"n\"shiftop/spanspan class=\"o\"./spanspan class=\"n\"getarg/spanspan class=\"p\"(/spanspan class=\"mi\"0/spanspan class=\"p\")/spanspan class=\"o\"./spanspan class=\"n\"getint/spanspan class=\"p\"()/span span class=\"o\"!=/span span class=\"mi\"1/spanspan class=\"p\":/span\na id=\"rest_code_7d5885c533384778ba70ebd63601716c-38\" name=\"rest_code_7d5885c533384778ba70ebd63601716c-38\" href=\"https://www.pypy.org/posts/2024/10/jit-peephole-dsl.html#rest_code_7d5885c533384778ba70ebd63601716c-38\"/a                    span class=\"k\"continue/span\na id=\"rest_code_7d5885c533384778ba70ebd63601716c-39\" name=\"rest_code_7d5885c533384778ba70ebd63601716c-39\" href=\"https://www.pypy.org/posts/2024/10/jit-peephole-dsl.html#rest_code_7d5885c533384778ba70ebd63601716c-39\"/a                span class=\"n\"shiftvar/span span class=\"o\"=/span span class=\"n\"get_box_replacement/spanspan class=\"p\"(/spanspan class=\"n\"shiftop/spanspan class=\"o\"./spanspan class=\"n\"getarg/spanspan class=\"p\"(/spanspan class=\"mi\"1/spanspan class=\"p\"))/span\na id=\"rest_code_7d5885c533384778ba70ebd63601716c-40\" name=\"rest_code_7d5885c533384778ba70ebd63601716c-40\" href=\"https://www.pypy.org/posts/2024/10/jit-peephole-dsl.html#rest_code_7d5885c533384778ba70ebd63601716c-40\"/a                span class=\"n\"shiftbound/span span class=\"o\"=/span span class=\"bp\"self/spanspan class=\"o\"./spanspan class=\"n\"getintbound/spanspan class=\"p\"(/spanspan class=\"n\"shiftvar/spanspan class=\"p\")/span\na id=\"rest_code_7d5885c533384778ba70ebd63601716c-41\" name=\"rest_code_7d5885c533384778ba70ebd63601716c-41\" href=\"https://www.pypy.org/posts/2024/10/jit-peephole-dsl.html#rest_code_7d5885c533384778ba70ebd63601716c-41\"/a                span class=\"k\"if/span span class=\"n\"shiftbound/spanspan class=\"o\"./spanspan class=\"n\"known_nonnegative/spanspan class=\"p\"()/span span class=\"ow\"and/span span class=\"n\"shiftbound/spanspan class=\"o\"./spanspan class=\"n\"known_lt_const/spanspan class=\"p\"(/spanspan class=\"n\"LONG_BIT/spanspan class=\"p\"):/span\na id=\"rest_code_7d5885c533384778ba70ebd63601716c-42\" name=\"rest_code_7d5885c533384778ba70ebd63601716c-42\" href=\"https://www.pypy.org/posts/2024/10/jit-peephole-dsl.html#rest_code_7d5885c533384778ba70ebd63601716c-42\"/a                    span class=\"n\"op/span span class=\"o\"=/span span class=\"bp\"self/spanspan class=\"o\"./spanspan class=\"n\"replace_op_with/spanspan class=\"p\"(/span\na id=\"rest_code_7d5885c533384778ba70ebd63601716c-43\" name=\"rest_code_7d5885c533384778ba70ebd63601716c-43\" href=\"https://www.pypy.org/posts/2024/10/jit-peephole-dsl.html#rest_code_7d5885c533384778ba70ebd63601716c-43\"/a                            span class=\"n\"op/spanspan class=\"p\",/span span class=\"n\"rop/spanspan class=\"o\"./spanspan class=\"n\"INT_LSHIFT/spanspan class=\"p\",/span span class=\"n\"args/spanspan class=\"o\"=/spanspan class=\"p\"[/spanspan class=\"n\"rhs/spanspan class=\"p\",/span span class=\"n\"shiftvar/spanspan class=\"p\"])/span\na id=\"rest_code_7d5885c533384778ba70ebd63601716c-44\" name=\"rest_code_7d5885c533384778ba70ebd63601716c-44\" href=\"https://www.pypy.org/posts/2024/10/jit-peephole-dsl.html#rest_code_7d5885c533384778ba70ebd63601716c-44\"/a                    span class=\"bp\"self/spanspan class=\"o\"./spanspan class=\"n\"optimizer/spanspan class=\"o\"./spanspan class=\"n\"send_extra_operation/spanspan class=\"p\"(/spanspan class=\"n\"op/spanspan class=\"p\")/span\na id=\"rest_code_7d5885c533384778ba70ebd63601716c-45\" name=\"rest_code_7d5885c533384778ba70ebd63601716c-45\" href=\"https://www.pypy.org/posts/2024/10/jit-peephole-dsl.html#rest_code_7d5885c533384778ba70ebd63601716c-45\"/a                    span class=\"k\"return/span\na id=\"rest_code_7d5885c533384778ba70ebd63601716c-46\" name=\"rest_code_7d5885c533384778ba70ebd63601716c-46\" href=\"https://www.pypy.org/posts/2024/10/jit-peephole-dsl.html#rest_code_7d5885c533384778ba70ebd63601716c-46\"/a        span class=\"k\"return/span span class=\"bp\"self/spanspan class=\"o\"./spanspan class=\"n\"emit/spanspan class=\"p\"(/spanspan class=\"n\"op/spanspan class=\"p\")/span\n/pre/div\npAdding more rules to these functions is very tedious and gets super confusing\nwhen the functions get bigger. In addition I am always worried about making\nmistakes when writing this kind of code, and there is no feedback at all about\nwhich of these rules are actually applied a lot in real programs./p\npTherefore I decided to write a small domain specific language with the goal of\nexpressing these rules in a more declarative way. In the rest of the post I'll\ndescribe the DSL (most of that description is adapted from the a class=\"reference external\" href=\"https://rpython.readthedocs.io/en/latest/jit/ruleopt.html\"documentation/a\nabout it that I wrote)./p\n/section\nsection id=\"the-peephole-rule-dsl\"\nh2The Peephole Rule DSL/h2\nsection id=\"simple-transformation-rules\"\nh3Simple transformation rules/h3\npThe rules in the DSL specify how integer operation can be transformed into\ncheaper other integer operations. A rule always consists of a name, a pattern,\nand a target. Here's a simple rule:/p\npre class=\"literal-block\"add_zero: int_add(x, 0)\n    =gt; x/pre\npThe name of the rule is code class=\"docutils literal\"add_zero/code. It matches operations in the trace of the\nform code class=\"docutils literal\"int_add(x, 0)/code, where code class=\"docutils literal\"x/code will match anything and code class=\"docutils literal\"0/code will match only the\nconstant zero. After the code class=\"docutils literal\"=gt;/code arrow is the target of the rewrite, i.e. what the\noperation is rewritten to, in this case code class=\"docutils literal\"x/code./p\npThe rule language has a list of which of the operations are commutative, so code class=\"docutils literal\"add_zero/code\nwill also optimize code class=\"docutils literal\"int_add(0, x)/code to code class=\"docutils literal\"x/code./p\npVariables in the pattern can repeat:/p\npre class=\"literal-block\"sub_x_x: int_sub(x, x)\n    =gt; 0/pre\npThis rule matches against code class=\"docutils literal\"int_sub/code operations where the two arguments are the\nsame (either the same box, or the same constant)./p\npHere's a rule with a more complicated pattern:/p\npre class=\"literal-block\"sub_add: int_sub(int_add(x, y), y)\n    =gt; x/pre\npThis pattern matches code class=\"docutils literal\"int_sub/code operations, where the first argument was\nproduced by an code class=\"docutils literal\"int_add/code operation. In addition, one of the arguments of the\naddition has to be the same as the second argument of the subtraction./p\npThe constants code class=\"docutils literal\"MININT/code, code class=\"docutils literal\"MAXINT/code and code class=\"docutils literal\"LONG_BIT/code (which is either 32 or 64,\ndepending on which platform the JIT is built for) can be used in rules, they\nbehave like writing numbers but allow bit-width-independent formulations:/p\npre class=\"literal-block\"is_true_and_minint: int_is_true(int_and(x, MININT))\n    =gt; int_lt(x, 0)/pre\npIt is also possible to have a pattern where some arguments needs to be a\nconstant, without specifying which constant. Those patterns look like this:/p\npre class=\"literal-block\"sub_add_consts: int_sub(int_add(x, C1), C2) # incomplete\n    # more goes here\n    =gt; int_sub(x, C)/pre\npVariables in the pattern that start with a code class=\"docutils literal\"C/code match against constants only.\nHowever, in this current form the rule is incomplete, because the variable code class=\"docutils literal\"C/code\nthat is being used in the target operation is not defined anywhere. We will see\nhow to compute it in the next section./p\n/section\nsection id=\"computing-constants-and-other-intermediate-results\"\nh3Computing constants and other intermediate results/h3\npSometimes it is necessary to compute intermediate results that are used in the\ntarget operation. To do that, there can be extra assignments between the rule head\nand the rule target.:/p\npre class=\"literal-block\"sub_add_consts: int_sub(int_add(x, C1), C2) # incomplete\n    C = C1 + C2\n    =gt; int_sub(x, C)/pre\npThe right hand side of such an assignment is a subset of Python syntax,\nsupporting arithmetic using code class=\"docutils literal\"+/code, code class=\"docutils literal\"-/code, code class=\"docutils literal\"*/code, and certain helper functions.\nHowever, the syntax allows you to be explicit about unsignedness for some\noperations. E.g. code class=\"docutils literal\"gt;gt;u/code exists for unsigned right shifts (and I plan to add\ncode class=\"docutils literal\"gt;u/code, code class=\"docutils literal\"gt;=u/code, code class=\"docutils literal\"lt;u/code, code class=\"docutils literal\"lt;=u/code for comparisons)./p\npHere's an example of a rule that uses code class=\"docutils literal\"gt;gt;u/code:/p\npre class=\"literal-block\"urshift_lshift_x_c_c: uint_rshift(int_lshift(x, C), C)\n    mask = (-1 lt;lt; C) gt;gt;u C\n    =gt; int_and(x, mask)/pre\n/section\nsection id=\"checks\"\nh3Checks/h3\npSome rewrites are only true under certain conditions. For example,\ncode class=\"docutils literal\"int_eq(x, 1)/code can be rewritten to code class=\"docutils literal\"x/code, if code class=\"docutils literal\"x/code is known to store a boolean value. This can\nbe expressed with emchecks/em:/p\npre class=\"literal-block\"eq_one: int_eq(x, 1)\n    check x.is_bool()\n    =gt; x/pre\npA check is followed by a boolean expression. The variables from the pattern can\nbe used as code class=\"docutils literal\"IntBound/code instances in checks (and also in assignments) to find out\nwhat the abstract interpretation of the JIT knows about the value of a trace variable\n(code class=\"docutils literal\"IntBound/code is the name of the abstract domain that the JIT uses for integers,\ndespite the fact that it also stores a class=\"reference external\" href=\"https://www.pypy.org/posts/2024/08/toy-knownbits.html\"knownbits/a information nowadays)./p\npHere's another example:/p\npre class=\"literal-block\"mul_lshift: int_mul(x, int_lshift(1, y))\n    check y.known_ge_const(0) and y.known_le_const(LONG_BIT)\n    =gt; int_lshift(x, y)/pre\npIt expresses that code class=\"docutils literal\"x * (1 lt;lt; y)/code can be rewritten to code class=\"docutils literal\"x lt;lt; y/code but checks that\ncode class=\"docutils literal\"y/code is known to be between code class=\"docutils literal\"0/code and code class=\"docutils literal\"LONG_BIT/code./p\npChecks and assignments can be repeated and combined with each other:/p\npre class=\"literal-block\"mul_pow2_const: int_mul(x, C)\n    check C gt; 0 and C amp; (C - 1) == 0\n    shift = highest_bit(C)\n    =gt; int_lshift(x, shift)/pre\npIn addition to calling methods on code class=\"docutils literal\"IntBound/code instances, it's also possible to\naccess their attributes, like in this rule:/p\npre class=\"literal-block\"and_x_c_in_range: int_and(x, C)\n    check x.lower gt;= 0 and x.upper lt;= C amp; ~(C + 1)\n    =gt; x/pre\n/section\nsection id=\"rule-ordering-and-liveness\"\nh3Rule Ordering and Liveness/h3\npThe generated optimizer code will give preference to applying rules that\nproduce a constant or a variable as a rewrite result. Only if none of those\nmatch do rules that produce new result operations get applied. For example, the\nrules code class=\"docutils literal\"sub_x_x/code and code class=\"docutils literal\"sub_add/code are tried before trying code class=\"docutils literal\"sub_add_consts/code,\nbecause the former two rules optimize to a constant and a variable\nrespectively, while the latter produces a new operation as the result./p\npThe rule code class=\"docutils literal\"sub_add_consts/code has a possible problem, which is that if the\nintermediate result of the code class=\"docutils literal\"int_add/code operation in the rule head is used by\nsome other operations, then the code class=\"docutils literal\"sub_add_consts/code rule does not actually\nreduce the number of operations (and might actually make things slightly worse\ndue to increased register pressure). However, currently it would be extremely\nhard to take that kind of information into account in the optimization pass of\nthe JIT, so we optimistically apply the rules anyway./p\n/section\nsection id=\"checking-rule-coverage\"\nh3Checking rule coverage/h3\npEvery rewrite rule should have at least one unit test where it triggers. To\nensure this, the a class=\"reference external\" href=\"https://github.com/pypy/pypy/blob/d92d0bfd38318ede1cbaadadafd77da69d431fad/rpython/jit/metainterp/optimizeopt/test/test_optimizeintbound.py\"unit test file that mainly checks integer optimizations/a in the\nJIT has an assert at the end of a test run, that every rule fired at least once./p\n/section\nsection id=\"printing-rule-statistics\"\nh3Printing rule statistics/h3\npThe JIT can print statistics about which rule fired how often in the\ncode class=\"docutils literal\"span class=\"pre\"jit-intbounds-stats/span/code logging category, using the a class=\"reference external\" href=\"https://rpython.readthedocs.io/en/latest/logging.html\"PYPYLOG/a mechanism. For\nexample, to print the category to stdout at the end of program execution, run\nPyPy like this:/p\npre class=\"literal-block\"PYPYLOG=jit-intbounds-stats:- pypy .../pre\npThe output of that will look something like this:/p\npre class=\"literal-block\"int_add\n    add_reassoc_consts 2514\n    add_zero 107008\nint_sub\n    sub_zero 31519\n    sub_from_zero 523\n    sub_x_x 3153\n    sub_add_consts 159\n    sub_add 55\n    sub_sub_x_c_c 1752\n    sub_sub_c_x_c 0\n    sub_xor_x_y_y 0\n    sub_or_x_y_y 0\nint_mul\n    mul_zero 0\n    mul_one 110\n    mul_minus_one 0\n    mul_pow2_const 1456\n    mul_lshift 0\n.../pre\n/section\nsection id=\"termination-and-confluence\"\nh3Termination and Confluence/h3\npRight now there are unfortunately no checks that the rules actually rewrite\noperations towards \"simpler\" forms. There is no cost model, and also nothing\nthat prevents you from writing a rule like this:/p\npre class=\"literal-block\"neg_complication: int_neg(x) # leads to infinite rewrites\n    =gt; int_mul(-1, x)/pre\npDoing this would lead to endless rewrites if there is also another rule that\nturns multiplication with -1 into negation./p\npThere is also no checking for a class=\"reference external\" href=\"https://en.wikipedia.org/wiki/Confluence_(abstract_rewriting)\"confluence/a (yet?), i.e. the property that all\nrewrites starting from the same input trace always lead to the same output\ntrace, no matter in which order the rules are applied./p\n/section\nsection id=\"proofs\"\nh3Proofs/h3\npIt is very easy to write a peephole rule that is not correct in all corner\ncases. Therefore all the rules are proven correct with Z3 before compiled into\nactual JIT code, by default. When the proof fails, a (hopefully minimal)\ncounterexample is printed. The counterexample consists of values for all the\ninputs that fulfil the checks, values for the intermediate expressions, and\nthen two emdifferent/em values for the source and the target operations./p\npE.g. if we try to add the incorrect rule:/p\npre class=\"literal-block\"mul_is_add: int_mul(a, b)\n    =gt; int_add(a, b)/pre\npWe get the following counterexample as output:/p\npre class=\"literal-block\"Could not prove correctness of rule 'mul_is_add'\nin line 1\ncounterexample given by Z3:\ncounterexample values:\na: 0\nb: 1\noperation int_mul(a, b) with Z3 formula a*b\nhas counterexample result vale: 0\nBUT\ntarget expression: int_add(a, b) with Z3 formula a + b\nhas counterexample value: 1/pre\npIf we add conditions, they are taken into account and the counterexample will\nfulfil the conditions:/p\npre class=\"literal-block\"mul_is_add: int_mul(a, b)\n    check a.known_gt_const(1) and b.known_gt_const(2)\n    =gt; int_add(a, b)/pre\npThis leads to the following counterexample:/p\npre class=\"literal-block\"Could not prove correctness of rule 'mul_is_add'\nin line 46\ncounterexample given by Z3:\ncounterexample values:\na: 2\nb: 3\noperation int_mul(a, b) with Z3 formula a*b\nhas counterexample result vale: 6\nBUT\ntarget expression: int_add(a, b) with Z3 formula a + b\nhas counterexample value: 5/pre\npSome code class=\"docutils literal\"IntBound/code methods cannot be used in Z3 proofs because their a class=\"reference external\" href=\"https://www.pypy.org/posts/2024/08/toy-knownbits.html#cases-where-this-style-of-z3-proof-doesnt-work).\"control\nflow is too complex/a. If that is the case, they can have Z3-equivalent\nformulations defined (in every case this is done, it's a potential proof hole if\nthe Z3 friendly reformulation and the real implementation differ from each\nother, therefore extra care is required to make very sure they are equivalent)./p\npIt's possible to skip the proof of individual rules entirely by adding\ncode class=\"docutils literal\"SORRY_Z3/code to its body (but we should try not to do that too often):/p\npre class=\"literal-block\"eq_different_knownbits: int_eq(x, y)\n    SORRY_Z3\n    check x.known_ne(y)\n    =gt; 0/pre\n/section\nsection id=\"checking-for-satisfiability\"\nh3Checking for satisfiability/h3\npIn addition to checking whether the rule yields a correct optimization, we also\ncheck whether the rule can ever apply. This ensures that there are emsome/em\nruntime values that would fulfil all the checks in a rule. Here's an example of\na rule violating this:/p\npre class=\"literal-block\"never_applies: int_is_true(x)\n    check x.known_lt_const(0) and x.known_gt_const(0) # impossible condition, always False\n    =gt; x/pre\npRight now the error messages if this goes wrong are not completely easy to\nunderstand. I hope to be able to improve this later:/p\npre class=\"literal-block\"Rule 'never_applies' cannot ever apply\nin line 1\nZ3 did not manage to find values for variables x such that the following condition becomes True:\nAnd(x lt;= x_upper,\n    x_lower lt;= x,\n    If(x_upper lt; 0, x_lower gt; 0, x_upper lt; 0))/pre\n/section\nsection id=\"implementation-notes\"\nh3Implementation Notes/h3\npThe implementation of the DSL is done in a relatively ad-hoc manner. It is\nparsed using a class=\"reference external\" href=\"https://rply.readthedocs.io/\"rply/a, there's a small type checker that tries to find common\nproblems in how the rules are written. Z3 is used via the Python API, like in\nthe previous blog posts that are using it. The\npattern matching RPython code is generated using an approach inspired by Luc\nMaranget's paper a class=\"reference external\" href=\"http://moscova.inria.fr/~maranget/papers/ml05e-maranget.pdf\"Compiling Pattern Matching to Good Decision Trees/a. See\na class=\"reference external\" href=\"https://compiler.club/compiling-pattern-matching/\"this blog post/a for an approachable introduction./p\n/section\n/section\nsection id=\"conclusion\"\nh2Conclusion/h2\npNow that I've described the DSL, here are the rules that are equivalent to the\nimperative code in the motivation section:/p\npre class=\"literal-block\"mul_zero: int_mul(x, 0)\n    =gt; 0\n\nmul_one: int_mul(x, 1)\n    =gt; x\n\nmul_minus_one: int_mul(x, -1)\n    =gt; int_neg(x)\n\nmul_pow2_const: int_mul(x, C)\n    check C gt; 0 and C amp; (C - 1) == 0\n    shift = highest_bit(C)\n    =gt; int_lshift(x, shift)\n\nmul_lshift: int_mul(x, int_lshift(1, y))\n    check y.known_ge_const(0) and y.known_le_const(LONG_BIT)\n    =gt; int_lshift(x, y)/pre\npThe current status of the DSL is that it got merged to PyPy's main branch. I\nrewrote a part of the integer rewrites a class=\"reference external\" href=\"https://github.com/pypy/pypy/blob/d92d0bfd38318ede1cbaadadafd77da69d431fad/rpython/jit/metainterp/ruleopt/real.rules\"into the DSL/a, but some are still in the\nold imperative style (mostly for complicated reasons, the easily ported ones are\nall done). Since I've only been porting optimizations that had existed prior to\nthe existence of the DSL, performance numbers of benchmarks didn't change./p\npThere are a number of features that are still missing and some possible\nextensions that I plan to work on in the future:/p\nul class=\"simple\"\nlipAll the integer operations that the DSL handles so far are the variants that\ndo not check for overflow (or where overflow was proven to be impossible to\nhappen). In regular Python code the overflow-checking variants citeint_add_ovf/cite\netc are much more common, but the DSL doesn't support them yet. I plan to fix\nthis, but don't completely understand how the correctness proofs for them\nshould be done correctly./p/li\nlipA related problem is that I don't understand what it means for a rewrite to be\ncorrect if some of the operations are only defined for a subset of the input\nvalues. E.g. division isn't defined if the divisor is zero. In theory, a\ndivision operation in the trace should always be preceded by a check that the\ndivisor isn't zero. But sometimes other optimization move the check around and\nthe connection to the division gets lost or muddled. What optimizations can we\nstill safely perform on the division? There's lots of prior work on this\nquestion, but I still don't understand what the correct approach in our\ncontext would be./p/li\nlipOrdering comparisons like code class=\"docutils literal\"int_lt/code, code class=\"docutils literal\"int_le/code and their unsigned variants are\nnot ported to the DSL yet. Comparisons are an area where the JIT is not super\ngood yet at optimizing away operations. This is a pretty big topic and I've\nstarted a project with Nico Rittinghaus to try to improve the situation a bit\nmore generally./p/li\nlipA more advanced direction of work would be to implement a simplified form of\na class=\"reference external\" href=\"https://egraphs-good.github.io/\"e-graphs/a (or a class=\"reference external\" href=\"https://vimeo.com/843540328\"ae-graphs/a). The JIT has like half of an e-graph data\nstructure already, and we probably can't afford a full one in terms of compile\ntime costs, but maybe we can have two thirds or something?/p/li\n/ul\n/section\nsection id=\"acknowledgements\"\nh2Acknowledgements/h2\npThank you to a class=\"reference external\" href=\"https://bernsteinbear.com/\"Max Bernstein/a and a class=\"reference external\" href=\"https://martinfriedrichberger.net/\"Martin Berger/a for super helpful feedback on\ndrafts of the post!/p\n/section"
        }
      ],
      "description": "pAs is probably apparent from the sequence of blog posts about the topic in the\nlast year, I have been thinking about and working on integer optimizations in the JIT\ncompiler a lot. This work was mainly motivated by a class=\"reference external\" href=\"https://docs.pydrofoil.org/en/latest/\"Pydrofoil/a, where integer\noperations matter a lot more than for your typical Python program./p\npIn this post I'll describe my most recent change, which is a new small domain\nspecific language that I implemented to specify peephole optimizations on\ninteger operations in the JIT.\nIt uses pattern matching to specify how (sequences of) integer operations\nshould be simplified and optimized. The rules are then compiled to\nRPython code that then becomes part of the JIT's optimization passes./p\npTo make it less likely to introduce incorrect optimizations into the JIT, the\nrules are automatically proven correct with Z3 as part of the build process (for\na more hands-on intro to how that works you can look at the a class=\"reference external\" href=\"https://pypy.org/posts/2024/08/toy-knownbits.html#proving-correctness-of-the-transfer-functions-with-z3\"knownbits/a post).\nIn this blog post I want to motivate why I introduced the DSL and give an\nintroduction to how it works./p\nsection id=\"motivation\"\nh2Motivation/h2\npThis summer, after I wrote my a class=\"reference external\" href=\"https://www.pypy.org/posts/2024/07/mining-jit-traces-missing-optimizations-z3.html\"scripts to mine JIT traces for missed optimization/a\nopportunities, I started implementing a few of the integer peephole rewrite that\nthe script identified. Unfortunately, doing so led to the problem that the way\nwe express these rewrites up to now is very imperative and verbose. Here's a\nsnippet of RPython code that shows some rewrites for integer multiplication\n(look at the comments to see what the different parts actually do). You don't\nneed to understand the code in detail, but basically it's in very imperative\nstyle and there's quite a lot of boilerplate./p\ndiv class=\"code\"pre class=\"code python\"a id=\"rest_code_7d5885c533384778ba70ebd63601716c-1\" name=\"rest_code_7d5885c533384778ba70ebd63601716c-1\" href=\"https://www.pypy.org/posts/2024/10/jit-peephole-dsl.html#rest_code_7d5885c533384778ba70ebd63601716c-1\"/aspan class=\"k\"def/span span class=\"nf\"optimize_INT_MUL/spanspan class=\"p\"(/spanspan class=\"bp\"self/spanspan class=\"p\",/span span class=\"n\"op/spanspan class=\"p\"):/span\na id=\"rest_code_7d5885c533384778ba70ebd63601716c-2\" name=\"rest_code_7d5885c533384778ba70ebd63601716c-2\" href=\"https://www.pypy.org/posts/2024/10/jit-peephole-dsl.html#rest_code_7d5885c533384778ba70ebd63601716c-2\"/a    span class=\"n\"arg0/span span class=\"o\"=/span span class=\"n\"get_box_replacement/spanspan class=\"p\"(/spanspan class=\"n\"op/spanspan class=\"o\"./spanspan class=\"n\"getarg/spanspan class=\"p\"(/spanspan class=\"mi\"0/spanspan class=\"p\"))/span\na id=\"rest_code_7d5885c533384778ba70ebd63601716c-3\" name=\"rest_code_7d5885c533384778ba70ebd63601716c-3\" href=\"https://www.pypy.org/posts/2024/10/jit-peephole-dsl.html#rest_code_7d5885c533384778ba70ebd63601716c-3\"/a    span class=\"n\"b0/span span class=\"o\"=/span span class=\"bp\"self/spanspan class=\"o\"./spanspan class=\"n\"getintbound/spanspan class=\"p\"(/spanspan class=\"n\"arg0/spanspan class=\"p\")/span\na id=\"rest_code_7d5885c533384778ba70ebd63601716c-4\" name=\"rest_code_7d5885c533384778ba70ebd63601716c-4\" href=\"https://www.pypy.org/posts/2024/10/jit-peephole-dsl.html#rest_code_7d5885c533384778ba70ebd63601716c-4\"/a    span class=\"n\"arg1/span span class=\"o\"=/span span class=\"n\"get_box_replacement/spanspan class=\"p\"(/spanspan class=\"n\"op/spanspan class=\"o\"./spanspan class=\"n\"getarg/spanspan class=\"p\"(/spanspan class=\"mi\"1/spanspan class=\"p\"))/span\na id=\"rest_code_7d5885c533384778ba70ebd63601716c-5\" name=\"rest_code_7d5885c533384778ba70ebd63601716c-5\" href=\"https://www.pypy.org/posts/2024/10/jit-peephole-dsl.html#rest_code_7d5885c533384778ba70ebd63601716c-5\"/a    span class=\"n\"b1/span span class=\"o\"=/span span class=\"bp\"self/spanspan class=\"o\"./spanspan class=\"n\"getintbound/spanspan class=\"p\"(/spanspan class=\"n\"arg1/spanspan class=\"p\")/span\na id=\"rest_code_7d5885c533384778ba70ebd63601716c-6\" name=\"rest_code_7d5885c533384778ba70ebd63601716c-6\" href=\"https://www.pypy.org/posts/2024/10/jit-peephole-dsl.html#rest_code_7d5885c533384778ba70ebd63601716c-6\"/a\na id=\"rest_code_7d5885c533384778ba70ebd63601716c-7\" name=\"rest_code_7d5885c533384778ba70ebd63601716c-7\" href=\"https://www.pypy.org/posts/2024/10/jit-peephole-dsl.html#rest_code_7d5885c533384778ba70ebd63601716c-7\"/a    span class=\"k\"if/span span class=\"n\"b0/spanspan class=\"o\"./spanspan class=\"n\"known_eq_const/spanspan class=\"p\"(/spanspan class=\"mi\"1/spanspan class=\"p\"):/span\na id=\"rest_code_7d5885c533384778ba70ebd63601716c-8\" name=\"rest_code_7d5885c533384778ba70ebd63601716c-8\" href=\"https://www.pypy.org/posts/2024/10/jit-peephole-dsl.html#rest_code_7d5885c533384778ba70ebd63601716c-8\"/a        span class=\"c1\"# 1 * x == x/span\na id=\"rest_code_7d5885c533384778ba70ebd63601716c-9\" name=\"rest_code_7d5885c533384778ba70ebd63601716c-9\" href=\"https://www.pypy.org/posts/2024/10/jit-peephole-dsl.html#rest_code_7d5885c533384778ba70ebd63601716c-9\"/a        span class=\"bp\"self/spanspan class=\"o\"./spanspan class=\"n\"make_equal_to/spanspan class=\"p\"(/spanspan class=\"n\"op/spanspan class=\"p\",/span span class=\"n\"arg1/spanspan class=\"p\")/span\na id=\"rest_code_7d5885c533384778ba70ebd63601716c-10\" name=\"rest_code_7d5885c533384778ba70ebd63601716c-10\" href=\"https://www.pypy.org/posts/2024/10/jit-peephole-dsl.html#rest_code_7d5885c533384778ba70ebd63601716c-10\"/a    span class=\"k\"elif/span span class=\"n\"b1/spanspan class=\"o\"./spanspan class=\"n\"known_eq_const/spanspan class=\"p\"(/spanspan class=\"mi\"1/spanspan class=\"p\"):/span\na id=\"rest_code_7d5885c533384778ba70ebd63601716c-11\" name=\"rest_code_7d5885c533384778ba70ebd63601716c-11\" href=\"https://www.pypy.org/posts/2024/10/jit-peephole-dsl.html#rest_code_7d5885c533384778ba70ebd63601716c-11\"/a        span class=\"c1\"# x * 1 == x/span\na id=\"rest_code_7d5885c533384778ba70ebd63601716c-12\" name=\"rest_code_7d5885c533384778ba70ebd63601716c-12\" href=\"https://www.pypy.org/posts/2024/10/jit-peephole-dsl.html#rest_code_7d5885c533384778ba70ebd63601716c-12\"/a        span class=\"bp\"self/spanspan class=\"o\"./spanspan class=\"n\"make_equal_to/spanspan class=\"p\"(/spanspan class=\"n\"op/spanspan class=\"p\",/span span class=\"n\"arg0/spanspan class=\"p\")/span\na id=\"rest_code_7d5885c533384778ba70ebd63601716c-13\" name=\"rest_code_7d5885c533384778ba70ebd63601716c-13\" href=\"https://www.pypy.org/posts/2024/10/jit-peephole-dsl.html#rest_code_7d5885c533384778ba70ebd63601716c-13\"/a    span class=\"k\"elif/span span class=\"n\"b0/spanspan class=\"o\"./spanspan class=\"n\"known_eq_const/spanspan class=\"p\"(/spanspan class=\"mi\"0/spanspan class=\"p\")/span span class=\"ow\"or/span span class=\"n\"b1/spanspan class=\"o\"./spanspan class=\"n\"known_eq_const/spanspan class=\"p\"(/spanspan class=\"mi\"0/spanspan class=\"p\"):/span\na id=\"rest_code_7d5885c533384778ba70ebd63601716c-14\" name=\"rest_code_7d5885c533384778ba70ebd63601716c-14\" href=\"https://www.pypy.org/posts/2024/10/jit-peephole-dsl.html#rest_code_7d5885c533384778ba70ebd63601716c-14\"/a        span class=\"c1\"# 0 * x == x * 0 == 0/span\na id=\"rest_code_7d5885c533384778ba70ebd63601716c-15\" name=\"rest_code_7d5885c533384778ba70ebd63601716c-15\" href=\"https://www.pypy.org/posts/2024/10/jit-peephole-dsl.html#rest_code_7d5885c533384778ba70ebd63601716c-15\"/a        span class=\"bp\"self/spanspan class=\"o\"./spanspan class=\"n\"make_constant_int/spanspan class=\"p\"(/spanspan class=\"n\"op/spanspan class=\"p\",/span span class=\"mi\"0/spanspan class=\"p\")/span\na id=\"rest_code_7d5885c533384778ba70ebd63601716c-16\" name=\"rest_code_7d5885c533384778ba70ebd63601716c-16\" href=\"https://www.pypy.org/posts/2024/10/jit-peephole-dsl.html#rest_code_7d5885c533384778ba70ebd63601716c-16\"/a    span class=\"k\"else/spanspan class=\"p\":/span\na id=\"rest_code_7d5885c533384778ba70ebd63601716c-17\" name=\"rest_code_7d5885c533384778ba70ebd63601716c-17\" href=\"https://www.pypy.org/posts/2024/10/jit-peephole-dsl.html#rest_code_7d5885c533384778ba70ebd63601716c-17\"/a        span class=\"k\"for/span span class=\"n\"lhs/spanspan class=\"p\",/span span class=\"n\"rhs/span span class=\"ow\"in/span span class=\"p\"[(/spanspan class=\"n\"arg0/spanspan class=\"p\",/span span class=\"n\"arg1/spanspan class=\"p\"),/span span class=\"p\"(/spanspan class=\"n\"arg1/spanspan class=\"p\",/span span class=\"n\"arg0/spanspan class=\"p\")]:/span\na id=\"rest_code_7d5885c533384778ba70ebd63601716c-18\" name=\"rest_code_7d5885c533384778ba70ebd63601716c-18\" href=\"https://www.pypy.org/posts/2024/10/jit-peephole-dsl.html#rest_code_7d5885c533384778ba70ebd63601716c-18\"/a            span class=\"n\"lh_info/span span class=\"o\"=/span span class=\"bp\"self/spanspan class=\"o\"./spanspan class=\"n\"getintbound/spanspan class=\"p\"(/spanspan class=\"n\"lhs/spanspan class=\"p\")/span\na id=\"rest_code_7d5885c533384778ba70ebd63601716c-19\" name=\"rest_code_7d5885c533384778ba70ebd63601716c-19\" href=\"https://www.pypy.org/posts/2024/10/jit-peephole-dsl.html#rest_code_7d5885c533384778ba70ebd63601716c-19\"/a            span class=\"k\"if/span span class=\"n\"lh_info/spanspan class=\"o\"./spanspan class=\"n\"is_constant/spanspan class=\"p\"():/span\na id=\"rest_code_7d5885c533384778ba70ebd63601716c-20\" name=\"rest_code_7d5885c533384778ba70ebd63601716c-20\" href=\"https://www.pypy.org/posts/2024/10/jit-peephole-dsl.html#rest_code_7d5885c533384778ba70ebd63601716c-20\"/a                span class=\"n\"x/span span class=\"o\"=/span span class=\"n\"lh_info/spanspan class=\"o\"./spanspan class=\"n\"get_constant_int/spanspan class=\"p\"()/span\na id=\"rest_code_7d5885c533384778ba70ebd63601716c-21\" name=\"rest_code_7d5885c533384778ba70ebd63601716c-21\" href=\"https://www.pypy.org/posts/2024/10/jit-peephole-dsl.html#rest_code_7d5885c533384778ba70ebd63601716c-21\"/a                span class=\"k\"if/span span class=\"n\"x/span span class=\"o\"amp;/span span class=\"p\"(/spanspan class=\"n\"x/span span class=\"o\"-/span span class=\"mi\"1/spanspan class=\"p\")/span span class=\"o\"==/span span class=\"mi\"0/spanspan class=\"p\":/span\na id=\"rest_code_7d5885c533384778ba70ebd63601716c-22\" name=\"rest_code_7d5885c533384778ba70ebd63601716c-22\" href=\"https://www.pypy.org/posts/2024/10/jit-peephole-dsl.html#rest_code_7d5885c533384778ba70ebd63601716c-22\"/a                    span class=\"c1\"# x * (2 ** c) == x lt;lt; c/span\na id=\"rest_code_7d5885c533384778ba70ebd63601716c-23\" name=\"rest_code_7d5885c533384778ba70ebd63601716c-23\" href=\"https://www.pypy.org/posts/2024/10/jit-peephole-dsl.html#rest_code_7d5885c533384778ba70ebd63601716c-23\"/a                    span class=\"n\"new_rhs/span span class=\"o\"=/span span class=\"n\"ConstInt/spanspan class=\"p\"(/spanspan class=\"n\"highest_bit/spanspan class=\"p\"(/spanspan class=\"n\"lh_info/spanspan class=\"o\"./spanspan class=\"n\"get_constant_int/spanspan class=\"p\"()))/span\na id=\"rest_code_7d5885c533384778ba70ebd63601716c-24\" name=\"rest_code_7d5885c533384778ba70ebd63601716c-24\" href=\"https://www.pypy.org/posts/2024/10/jit-peephole-dsl.html#rest_code_7d5885c533384778ba70ebd63601716c-24\"/a                    span class=\"n\"op/span span class=\"o\"=/span span class=\"bp\"self/spanspan class=\"o\"./spanspan class=\"n\"replace_op_with/spanspan class=\"p\"(/spanspan class=\"n\"op/spanspan class=\"p\",/span span class=\"n\"rop/spanspan class=\"o\"./spanspan class=\"n\"INT_LSHIFT/spanspan class=\"p\",/span span class=\"n\"args/spanspan class=\"o\"=/spanspan class=\"p\"[/spanspan class=\"n\"rhs/spanspan class=\"p\",/span span class=\"n\"new_rhs/spanspan class=\"p\"])/span\na id=\"rest_code_7d5885c533384778ba70ebd63601716c-25\" name=\"rest_code_7d5885c533384778ba70ebd63601716c-25\" href=\"https://www.pypy.org/posts/2024/10/jit-peephole-dsl.html#rest_code_7d5885c533384778ba70ebd63601716c-25\"/a                    span class=\"bp\"self/spanspan class=\"o\"./spanspan class=\"n\"optimizer/spanspan class=\"o\"./spanspan class=\"n\"send_extra_operation/spanspan class=\"p\"(/spanspan class=\"n\"op/spanspan class=\"p\")/span\na id=\"rest_code_7d5885c533384778ba70ebd63601716c-26\" name=\"rest_code_7d5885c533384778ba70ebd63601716c-26\" href=\"https://www.pypy.org/posts/2024/10/jit-peephole-dsl.html#rest_code_7d5885c533384778ba70ebd63601716c-26\"/a                    span class=\"k\"return/span\na id=\"rest_code_7d5885c533384778ba70ebd63601716c-27\" name=\"rest_code_7d5885c533384778ba70ebd63601716c-27\" href=\"https://www.pypy.org/posts/2024/10/jit-peephole-dsl.html#rest_code_7d5885c533384778ba70ebd63601716c-27\"/a                span class=\"k\"elif/span span class=\"n\"x/span span class=\"o\"==/span span class=\"o\"-/spanspan class=\"mi\"1/spanspan class=\"p\":/span\na id=\"rest_code_7d5885c533384778ba70ebd63601716c-28\" name=\"rest_code_7d5885c533384778ba70ebd63601716c-28\" href=\"https://www.pypy.org/posts/2024/10/jit-peephole-dsl.html#rest_code_7d5885c533384778ba70ebd63601716c-28\"/a                    span class=\"c1\"# x * -1 == -x/span\na id=\"rest_code_7d5885c533384778ba70ebd63601716c-29\" name=\"rest_code_7d5885c533384778ba70ebd63601716c-29\" href=\"https://www.pypy.org/posts/2024/10/jit-peephole-dsl.html#rest_code_7d5885c533384778ba70ebd63601716c-29\"/a                    span class=\"n\"op/span span class=\"o\"=/span span class=\"bp\"self/spanspan class=\"o\"./spanspan class=\"n\"replace_op_with/spanspan class=\"p\"(/spanspan class=\"n\"op/spanspan class=\"p\",/span span class=\"n\"rop/spanspan class=\"o\"./spanspan class=\"n\"INT_NEG/spanspan class=\"p\",/span span class=\"n\"args/spanspan class=\"o\"=/spanspan class=\"p\"[/spanspan class=\"n\"rhs/spanspan class=\"p\"])/span\na id=\"rest_code_7d5885c533384778ba70ebd63601716c-30\" name=\"rest_code_7d5885c533384778ba70ebd63601716c-30\" href=\"https://www.pypy.org/posts/2024/10/jit-peephole-dsl.html#rest_code_7d5885c533384778ba70ebd63601716c-30\"/a                    span class=\"bp\"self/spanspan class=\"o\"./spanspan class=\"n\"optimizer/spanspan class=\"o\"./spanspan class=\"n\"send_extra_operation/spanspan class=\"p\"(/spanspan class=\"n\"op/spanspan class=\"p\")/span\na id=\"rest_code_7d5885c533384778ba70ebd63601716c-31\" name=\"rest_code_7d5885c533384778ba70ebd63601716c-31\" href=\"https://www.pypy.org/posts/2024/10/jit-peephole-dsl.html#rest_code_7d5885c533384778ba70ebd63601716c-31\"/a                    span class=\"k\"return/span\na id=\"rest_code_7d5885c533384778ba70ebd63601716c-32\" name=\"rest_code_7d5885c533384778ba70ebd63601716c-32\" href=\"https://www.pypy.org/posts/2024/10/jit-peephole-dsl.html#rest_code_7d5885c533384778ba70ebd63601716c-32\"/a            span class=\"k\"else/spanspan class=\"p\":/span\na id=\"rest_code_7d5885c533384778ba70ebd63601716c-33\" name=\"rest_code_7d5885c533384778ba70ebd63601716c-33\" href=\"https://www.pypy.org/posts/2024/10/jit-peephole-dsl.html#rest_code_7d5885c533384778ba70ebd63601716c-33\"/a                span class=\"c1\"# x * (1 lt;lt; y) == x lt;lt; y/span\na id=\"rest_code_7d5885c533384778ba70ebd63601716c-34\" name=\"rest_code_7d5885c533384778ba70ebd63601716c-34\" href=\"https://www.pypy.org/posts/2024/10/jit-peephole-dsl.html#rest_code_7d5885c533384778ba70ebd63601716c-34\"/a                span class=\"n\"shiftop/span span class=\"o\"=/span span class=\"bp\"self/spanspan class=\"o\"./spanspan class=\"n\"optimizer/spanspan class=\"o\"./spanspan class=\"n\"as_operation/spanspan class=\"p\"(/spanspan class=\"n\"get_box_replacement/spanspan class=\"p\"(/spanspan class=\"n\"lhs/spanspan class=\"p\"),/span span class=\"n\"rop/spanspan class=\"o\"./spanspan class=\"n\"INT_LSHIFT/spanspan class=\"p\")/span\na id=\"rest_code_7d5885c533384778ba70ebd63601716c-35\" name=\"rest_code_7d5885c533384778ba70ebd63601716c-35\" href=\"https://www.pypy.org/posts/2024/10/jit-peephole-dsl.html#rest_code_7d5885c533384778ba70ebd63601716c-35\"/a                span class=\"k\"if/span span class=\"n\"shiftop/span span class=\"ow\"is/span span class=\"kc\"None/spanspan class=\"p\":/span\na id=\"rest_code_7d5885c533384778ba70ebd63601716c-36\" name=\"rest_code_7d5885c533384778ba70ebd63601716c-36\" href=\"https://www.pypy.org/posts/2024/10/jit-peephole-dsl.html#rest_code_7d5885c533384778ba70ebd63601716c-36\"/a                    span class=\"k\"continue/span\na id=\"rest_code_7d5885c533384778ba70ebd63601716c-37\" name=\"rest_code_7d5885c533384778ba70ebd63601716c-37\" href=\"https://www.pypy.org/posts/2024/10/jit-peephole-dsl.html#rest_code_7d5885c533384778ba70ebd63601716c-37\"/a                span class=\"k\"if/span span class=\"ow\"not/span span class=\"n\"shiftop/spanspan class=\"o\"./spanspan class=\"n\"getarg/spanspan class=\"p\"(/spanspan class=\"mi\"0/spanspan class=\"p\")/spanspan class=\"o\"./spanspan class=\"n\"is_constant/spanspan class=\"p\"()/span span class=\"ow\"or/span span class=\"n\"shiftop/spanspan class=\"o\"./spanspan class=\"n\"getarg/spanspan class=\"p\"(/spanspan class=\"mi\"0/spanspan class=\"p\")/spanspan class=\"o\"./spanspan class=\"n\"getint/spanspan class=\"p\"()/span span class=\"o\"!=/span span class=\"mi\"1/spanspan class=\"p\":/span\na id=\"rest_code_7d5885c533384778ba70ebd63601716c-38\" name=\"rest_code_7d5885c533384778ba70ebd63601716c-38\" href=\"https://www.pypy.org/posts/2024/10/jit-peephole-dsl.html#rest_code_7d5885c533384778ba70ebd63601716c-38\"/a                    span class=\"k\"continue/span\na id=\"rest_code_7d5885c533384778ba70ebd63601716c-39\" name=\"rest_code_7d5885c533384778ba70ebd63601716c-39\" href=\"https://www.pypy.org/posts/2024/10/jit-peephole-dsl.html#rest_code_7d5885c533384778ba70ebd63601716c-39\"/a                span class=\"n\"shiftvar/span span class=\"o\"=/span span class=\"n\"get_box_replacement/spanspan class=\"p\"(/spanspan class=\"n\"shiftop/spanspan class=\"o\"./spanspan class=\"n\"getarg/spanspan class=\"p\"(/spanspan class=\"mi\"1/spanspan class=\"p\"))/span\na id=\"rest_code_7d5885c533384778ba70ebd63601716c-40\" name=\"rest_code_7d5885c533384778ba70ebd63601716c-40\" href=\"https://www.pypy.org/posts/2024/10/jit-peephole-dsl.html#rest_code_7d5885c533384778ba70ebd63601716c-40\"/a                span class=\"n\"shiftbound/span span class=\"o\"=/span span class=\"bp\"self/spanspan class=\"o\"./spanspan class=\"n\"getintbound/spanspan class=\"p\"(/spanspan class=\"n\"shiftvar/spanspan class=\"p\")/span\na id=\"rest_code_7d5885c533384778ba70ebd63601716c-41\" name=\"rest_code_7d5885c533384778ba70ebd63601716c-41\" href=\"https://www.pypy.org/posts/2024/10/jit-peephole-dsl.html#rest_code_7d5885c533384778ba70ebd63601716c-41\"/a                span class=\"k\"if/span span class=\"n\"shiftbound/spanspan class=\"o\"./spanspan class=\"n\"known_nonnegative/spanspan class=\"p\"()/span span class=\"ow\"and/span span class=\"n\"shiftbound/spanspan class=\"o\"./spanspan class=\"n\"known_lt_const/spanspan class=\"p\"(/spanspan class=\"n\"LONG_BIT/spanspan class=\"p\"):/span\na id=\"rest_code_7d5885c533384778ba70ebd63601716c-42\" name=\"rest_code_7d5885c533384778ba70ebd63601716c-42\" href=\"https://www.pypy.org/posts/2024/10/jit-peephole-dsl.html#rest_code_7d5885c533384778ba70ebd63601716c-42\"/a                    span class=\"n\"op/span span class=\"o\"=/span span class=\"bp\"self/spanspan class=\"o\"./spanspan class=\"n\"replace_op_with/spanspan class=\"p\"(/span\na id=\"rest_code_7d5885c533384778ba70ebd63601716c-43\" name=\"rest_code_7d5885c533384778ba70ebd63601716c-43\" href=\"https://www.pypy.org/posts/2024/10/jit-peephole-dsl.html#rest_code_7d5885c533384778ba70ebd63601716c-43\"/a                            span class=\"n\"op/spanspan class=\"p\",/span span class=\"n\"rop/spanspan class=\"o\"./spanspan class=\"n\"INT_LSHIFT/spanspan class=\"p\",/span span class=\"n\"args/spanspan class=\"o\"=/spanspan class=\"p\"[/spanspan class=\"n\"rhs/spanspan class=\"p\",/span span class=\"n\"shiftvar/spanspan class=\"p\"])/span\na id=\"rest_code_7d5885c533384778ba70ebd63601716c-44\" name=\"rest_code_7d5885c533384778ba70ebd63601716c-44\" href=\"https://www.pypy.org/posts/2024/10/jit-peephole-dsl.html#rest_code_7d5885c533384778ba70ebd63601716c-44\"/a                    span class=\"bp\"self/spanspan class=\"o\"./spanspan class=\"n\"optimizer/spanspan class=\"o\"./spanspan class=\"n\"send_extra_operation/spanspan class=\"p\"(/spanspan class=\"n\"op/spanspan class=\"p\")/span\na id=\"rest_code_7d5885c533384778ba70ebd63601716c-45\" name=\"rest_code_7d5885c533384778ba70ebd63601716c-45\" href=\"https://www.pypy.org/posts/2024/10/jit-peephole-dsl.html#rest_code_7d5885c533384778ba70ebd63601716c-45\"/a                    span class=\"k\"return/span\na id=\"rest_code_7d5885c533384778ba70ebd63601716c-46\" name=\"rest_code_7d5885c533384778ba70ebd63601716c-46\" href=\"https://www.pypy.org/posts/2024/10/jit-peephole-dsl.html#rest_code_7d5885c533384778ba70ebd63601716c-46\"/a        span class=\"k\"return/span span class=\"bp\"self/spanspan class=\"o\"./spanspan class=\"n\"emit/spanspan class=\"p\"(/spanspan class=\"n\"op/spanspan class=\"p\")/span\n/pre/div\npAdding more rules to these functions is very tedious and gets super confusing\nwhen the functions get bigger. In addition I am always worried about making\nmistakes when writing this kind of code, and there is no feedback at all about\nwhich of these rules are actually applied a lot in real programs./p\npTherefore I decided to write a small domain specific language with the goal of\nexpressing these rules in a more declarative way. In the rest of the post I'll\ndescribe the DSL (most of that description is adapted from the a class=\"reference external\" href=\"https://rpython.readthedocs.io/en/latest/jit/ruleopt.html\"documentation/a\nabout it that I wrote)./p\n/section\nsection id=\"the-peephole-rule-dsl\"\nh2The Peephole Rule DSL/h2\nsection id=\"simple-transformation-rules\"\nh3Simple transformation rules/h3\npThe rules in the DSL specify how integer operation can be transformed into\ncheaper other integer operations. A rule always consists of a name, a pattern,\nand a target. Here's a simple rule:/p\npre class=\"literal-block\"add_zero: int_add(x, 0)\n    =gt; x/pre\npThe name of the rule is code class=\"docutils literal\"add_zero/code. It matches operations in the trace of the\nform code class=\"docutils literal\"int_add(x, 0)/code, where code class=\"docutils literal\"x/code will match anything and code class=\"docutils literal\"0/code will match only the\nconstant zero. After the code class=\"docutils literal\"=gt;/code arrow is the target of the rewrite, i.e. what the\noperation is rewritten to, in this case code class=\"docutils literal\"x/code./p\npThe rule language has a list of which of the operations are commutative, so code class=\"docutils literal\"add_zero/code\nwill also optimize code class=\"docutils literal\"int_add(0, x)/code to code class=\"docutils literal\"x/code./p\npVariables in the pattern can repeat:/p\npre class=\"literal-block\"sub_x_x: int_sub(x, x)\n    =gt; 0/pre\npThis rule matches against code class=\"docutils literal\"int_sub/code operations where the two arguments are the\nsame (either the same box, or the same constant)./p\npHere's a rule with a more complicated pattern:/p\npre class=\"literal-block\"sub_add: int_sub(int_add(x, y), y)\n    =gt; x/pre\npThis pattern matches code class=\"docutils literal\"int_sub/code operations, where the first argument was\nproduced by an code class=\"docutils literal\"int_add/code operation. In addition, one of the arguments of the\naddition has to be the same as the second argument of the subtraction./p\npThe constants code class=\"docutils literal\"MININT/code, code class=\"docutils literal\"MAXINT/code and code class=\"docutils literal\"LONG_BIT/code (which is either 32 or 64,\ndepending on which platform the JIT is built for) can be used in rules, they\nbehave like writing numbers but allow bit-width-independent formulations:/p\npre class=\"literal-block\"is_true_and_minint: int_is_true(int_and(x, MININT))\n    =gt; int_lt(x, 0)/pre\npIt is also possible to have a pattern where some arguments needs to be a\nconstant, without specifying which constant. Those patterns look like this:/p\npre class=\"literal-block\"sub_add_consts: int_sub(int_add(x, C1), C2) # incomplete\n    # more goes here\n    =gt; int_sub(x, C)/pre\npVariables in the pattern that start with a code class=\"docutils literal\"C/code match against constants only.\nHowever, in this current form the rule is incomplete, because the variable code class=\"docutils literal\"C/code\nthat is being used in the target operation is not defined anywhere. We will see\nhow to compute it in the next section./p\n/section\nsection id=\"computing-constants-and-other-intermediate-results\"\nh3Computing constants and other intermediate results/h3\npSometimes it is necessary to compute intermediate results that are used in the\ntarget operation. To do that, there can be extra assignments between the rule head\nand the rule target.:/p\npre class=\"literal-block\"sub_add_consts: int_sub(int_add(x, C1), C2) # incomplete\n    C = C1 + C2\n    =gt; int_sub(x, C)/pre\npThe right hand side of such an assignment is a subset of Python syntax,\nsupporting arithmetic using code class=\"docutils literal\"+/code, code class=\"docutils literal\"-/code, code class=\"docutils literal\"*/code, and certain helper functions.\nHowever, the syntax allows you to be explicit about unsignedness for some\noperations. E.g. code class=\"docutils literal\"gt;gt;u/code exists for unsigned right shifts (and I plan to add\ncode class=\"docutils literal\"gt;u/code, code class=\"docutils literal\"gt;=u/code, code class=\"docutils literal\"lt;u/code, code class=\"docutils literal\"lt;=u/code for comparisons)./p\npHere's an example of a rule that uses code class=\"docutils literal\"gt;gt;u/code:/p\npre class=\"literal-block\"urshift_lshift_x_c_c: uint_rshift(int_lshift(x, C), C)\n    mask = (-1 lt;lt; C) gt;gt;u C\n    =gt; int_and(x, mask)/pre\n/section\nsection id=\"checks\"\nh3Checks/h3\npSome rewrites are only true under certain conditions. For example,\ncode class=\"docutils literal\"int_eq(x, 1)/code can be rewritten to code class=\"docutils literal\"x/code, if code class=\"docutils literal\"x/code is known to store a boolean value. This can\nbe expressed with emchecks/em:/p\npre class=\"literal-block\"eq_one: int_eq(x, 1)\n    check x.is_bool()\n    =gt; x/pre\npA check is followed by a boolean expression. The variables from the pattern can\nbe used as code class=\"docutils literal\"IntBound/code instances in checks (and also in assignments) to find out\nwhat the abstract interpretation of the JIT knows about the value of a trace variable\n(code class=\"docutils literal\"IntBound/code is the name of the abstract domain that the JIT uses for integers,\ndespite the fact that it also stores a class=\"reference external\" href=\"https://www.pypy.org/posts/2024/08/toy-knownbits.html\"knownbits/a information nowadays)./p\npHere's another example:/p\npre class=\"literal-block\"mul_lshift: int_mul(x, int_lshift(1, y))\n    check y.known_ge_const(0) and y.known_le_const(LONG_BIT)\n    =gt; int_lshift(x, y)/pre\npIt expresses that code class=\"docutils literal\"x * (1 lt;lt; y)/code can be rewritten to code class=\"docutils literal\"x lt;lt; y/code but checks that\ncode class=\"docutils literal\"y/code is known to be between code class=\"docutils literal\"0/code and code class=\"docutils literal\"LONG_BIT/code./p\npChecks and assignments can be repeated and combined with each other:/p\npre class=\"literal-block\"mul_pow2_const: int_mul(x, C)\n    check C gt; 0 and C amp; (C - 1) == 0\n    shift = highest_bit(C)\n    =gt; int_lshift(x, shift)/pre\npIn addition to calling methods on code class=\"docutils literal\"IntBound/code instances, it's also possible to\naccess their attributes, like in this rule:/p\npre class=\"literal-block\"and_x_c_in_range: int_and(x, C)\n    check x.lower gt;= 0 and x.upper lt;= C amp; ~(C + 1)\n    =gt; x/pre\n/section\nsection id=\"rule-ordering-and-liveness\"\nh3Rule Ordering and Liveness/h3\npThe generated optimizer code will give preference to applying rules that\nproduce a constant or a variable as a rewrite result. Only if none of those\nmatch do rules that produce new result operations get applied. For example, the\nrules code class=\"docutils literal\"sub_x_x/code and code class=\"docutils literal\"sub_add/code are tried before trying code class=\"docutils literal\"sub_add_consts/code,\nbecause the former two rules optimize to a constant and a variable\nrespectively, while the latter produces a new operation as the result./p\npThe rule code class=\"docutils literal\"sub_add_consts/code has a possible problem, which is that if the\nintermediate result of the code class=\"docutils literal\"int_add/code operation in the rule head is used by\nsome other operations, then the code class=\"docutils literal\"sub_add_consts/code rule does not actually\nreduce the number of operations (and might actually make things slightly worse\ndue to increased register pressure). However, currently it would be extremely\nhard to take that kind of information into account in the optimization pass of\nthe JIT, so we optimistically apply the rules anyway./p\n/section\nsection id=\"checking-rule-coverage\"\nh3Checking rule coverage/h3\npEvery rewrite rule should have at least one unit test where it triggers. To\nensure this, the a class=\"reference external\" href=\"https://github.com/pypy/pypy/blob/d92d0bfd38318ede1cbaadadafd77da69d431fad/rpython/jit/metainterp/optimizeopt/test/test_optimizeintbound.py\"unit test file that mainly checks integer optimizations/a in the\nJIT has an assert at the end of a test run, that every rule fired at least once./p\n/section\nsection id=\"printing-rule-statistics\"\nh3Printing rule statistics/h3\npThe JIT can print statistics about which rule fired how often in the\ncode class=\"docutils literal\"span class=\"pre\"jit-intbounds-stats/span/code logging category, using the a class=\"reference external\" href=\"https://rpython.readthedocs.io/en/latest/logging.html\"PYPYLOG/a mechanism. For\nexample, to print the category to stdout at the end of program execution, run\nPyPy like this:/p\npre class=\"literal-block\"PYPYLOG=jit-intbounds-stats:- pypy .../pre\npThe output of that will look something like this:/p\npre class=\"literal-block\"int_add\n    add_reassoc_consts 2514\n    add_zero 107008\nint_sub\n    sub_zero 31519\n    sub_from_zero 523\n    sub_x_x 3153\n    sub_add_consts 159\n    sub_add 55\n    sub_sub_x_c_c 1752\n    sub_sub_c_x_c 0\n    sub_xor_x_y_y 0\n    sub_or_x_y_y 0\nint_mul\n    mul_zero 0\n    mul_one 110\n    mul_minus_one 0\n    mul_pow2_const 1456\n    mul_lshift 0\n.../pre\n/section\nsection id=\"termination-and-confluence\"\nh3Termination and Confluence/h3\npRight now there are unfortunately no checks that the rules actually rewrite\noperations towards \"simpler\" forms. There is no cost model, and also nothing\nthat prevents you from writing a rule like this:/p\npre class=\"literal-block\"neg_complication: int_neg(x) # leads to infinite rewrites\n    =gt; int_mul(-1, x)/pre\npDoing this would lead to endless rewrites if there is also another rule that\nturns multiplication with -1 into negation./p\npThere is also no checking for a class=\"reference external\" href=\"https://en.wikipedia.org/wiki/Confluence_(abstract_rewriting)\"confluence/a (yet?), i.e. the property that all\nrewrites starting from the same input trace always lead to the same output\ntrace, no matter in which order the rules are applied./p\n/section\nsection id=\"proofs\"\nh3Proofs/h3\npIt is very easy to write a peephole rule that is not correct in all corner\ncases. Therefore all the rules are proven correct with Z3 before compiled into\nactual JIT code, by default. When the proof fails, a (hopefully minimal)\ncounterexample is printed. The counterexample consists of values for all the\ninputs that fulfil the checks, values for the intermediate expressions, and\nthen two emdifferent/em values for the source and the target operations./p\npE.g. if we try to add the incorrect rule:/p\npre class=\"literal-block\"mul_is_add: int_mul(a, b)\n    =gt; int_add(a, b)/pre\npWe get the following counterexample as output:/p\npre class=\"literal-block\"Could not prove correctness of rule 'mul_is_add'\nin line 1\ncounterexample given by Z3:\ncounterexample values:\na: 0\nb: 1\noperation int_mul(a, b) with Z3 formula a*b\nhas counterexample result vale: 0\nBUT\ntarget expression: int_add(a, b) with Z3 formula a + b\nhas counterexample value: 1/pre\npIf we add conditions, they are taken into account and the counterexample will\nfulfil the conditions:/p\npre class=\"literal-block\"mul_is_add: int_mul(a, b)\n    check a.known_gt_const(1) and b.known_gt_const(2)\n    =gt; int_add(a, b)/pre\npThis leads to the following counterexample:/p\npre class=\"literal-block\"Could not prove correctness of rule 'mul_is_add'\nin line 46\ncounterexample given by Z3:\ncounterexample values:\na: 2\nb: 3\noperation int_mul(a, b) with Z3 formula a*b\nhas counterexample result vale: 6\nBUT\ntarget expression: int_add(a, b) with Z3 formula a + b\nhas counterexample value: 5/pre\npSome code class=\"docutils literal\"IntBound/code methods cannot be used in Z3 proofs because their a class=\"reference external\" href=\"https://www.pypy.org/posts/2024/08/toy-knownbits.html#cases-where-this-style-of-z3-proof-doesnt-work).\"control\nflow is too complex/a. If that is the case, they can have Z3-equivalent\nformulations defined (in every case this is done, it's a potential proof hole if\nthe Z3 friendly reformulation and the real implementation differ from each\nother, therefore extra care is required to make very sure they are equivalent)./p\npIt's possible to skip the proof of individual rules entirely by adding\ncode class=\"docutils literal\"SORRY_Z3/code to its body (but we should try not to do that too often):/p\npre class=\"literal-block\"eq_different_knownbits: int_eq(x, y)\n    SORRY_Z3\n    check x.known_ne(y)\n    =gt; 0/pre\n/section\nsection id=\"checking-for-satisfiability\"\nh3Checking for satisfiability/h3\npIn addition to checking whether the rule yields a correct optimization, we also\ncheck whether the rule can ever apply. This ensures that there are emsome/em\nruntime values that would fulfil all the checks in a rule. Here's an example of\na rule violating this:/p\npre class=\"literal-block\"never_applies: int_is_true(x)\n    check x.known_lt_const(0) and x.known_gt_const(0) # impossible condition, always False\n    =gt; x/pre\npRight now the error messages if this goes wrong are not completely easy to\nunderstand. I hope to be able to improve this later:/p\npre class=\"literal-block\"Rule 'never_applies' cannot ever apply\nin line 1\nZ3 did not manage to find values for variables x such that the following condition becomes True:\nAnd(x lt;= x_upper,\n    x_lower lt;= x,\n    If(x_upper lt; 0, x_lower gt; 0, x_upper lt; 0))/pre\n/section\nsection id=\"implementation-notes\"\nh3Implementation Notes/h3\npThe implementation of the DSL is done in a relatively ad-hoc manner. It is\nparsed using a class=\"reference external\" href=\"https://rply.readthedocs.io/\"rply/a, there's a small type checker that tries to find common\nproblems in how the rules are written. Z3 is used via the Python API, like in\nthe previous blog posts that are using it. The\npattern matching RPython code is generated using an approach inspired by Luc\nMaranget's paper a class=\"reference external\" href=\"http://moscova.inria.fr/~maranget/papers/ml05e-maranget.pdf\"Compiling Pattern Matching to Good Decision Trees/a. See\na class=\"reference external\" href=\"https://compiler.club/compiling-pattern-matching/\"this blog post/a for an approachable introduction./p\n/section\n/section\nsection id=\"conclusion\"\nh2Conclusion/h2\npNow that I've described the DSL, here are the rules that are equivalent to the\nimperative code in the motivation section:/p\npre class=\"literal-block\"mul_zero: int_mul(x, 0)\n    =gt; 0\n\nmul_one: int_mul(x, 1)\n    =gt; x\n\nmul_minus_one: int_mul(x, -1)\n    =gt; int_neg(x)\n\nmul_pow2_const: int_mul(x, C)\n    check C gt; 0 and C amp; (C - 1) == 0\n    shift = highest_bit(C)\n    =gt; int_lshift(x, shift)\n\nmul_lshift: int_mul(x, int_lshift(1, y))\n    check y.known_ge_const(0) and y.known_le_const(LONG_BIT)\n    =gt; int_lshift(x, y)/pre\npThe current status of the DSL is that it got merged to PyPy's main branch. I\nrewrote a part of the integer rewrites a class=\"reference external\" href=\"https://github.com/pypy/pypy/blob/d92d0bfd38318ede1cbaadadafd77da69d431fad/rpython/jit/metainterp/ruleopt/real.rules\"into the DSL/a, but some are still in the\nold imperative style (mostly for complicated reasons, the easily ported ones are\nall done). Since I've only been porting optimizations that had existed prior to\nthe existence of the DSL, performance numbers of benchmarks didn't change./p\npThere are a number of features that are still missing and some possible\nextensions that I plan to work on in the future:/p\nul class=\"simple\"\nlipAll the integer operations that the DSL handles so far are the variants that\ndo not check for overflow (or where overflow was proven to be impossible to\nhappen). In regular Python code the overflow-checking variants citeint_add_ovf/cite\netc are much more common, but the DSL doesn't support them yet. I plan to fix\nthis, but don't completely understand how the correctness proofs for them\nshould be done correctly./p/li\nlipA related problem is that I don't understand what it means for a rewrite to be\ncorrect if some of the operations are only defined for a subset of the input\nvalues. E.g. division isn't defined if the divisor is zero. In theory, a\ndivision operation in the trace should always be preceded by a check that the\ndivisor isn't zero. But sometimes other optimization move the check around and\nthe connection to the division gets lost or muddled. What optimizations can we\nstill safely perform on the division? There's lots of prior work on this\nquestion, but I still don't understand what the correct approach in our\ncontext would be./p/li\nlipOrdering comparisons like code class=\"docutils literal\"int_lt/code, code class=\"docutils literal\"int_le/code and their unsigned variants are\nnot ported to the DSL yet. Comparisons are an area where the JIT is not super\ngood yet at optimizing away operations. This is a pretty big topic and I've\nstarted a project with Nico Rittinghaus to try to improve the situation a bit\nmore generally./p/li\nlipA more advanced direction of work would be to implement a simplified form of\na class=\"reference external\" href=\"https://egraphs-good.github.io/\"e-graphs/a (or a class=\"reference external\" href=\"https://vimeo.com/843540328\"ae-graphs/a). The JIT has like half of an e-graph data\nstructure already, and we probably can't afford a full one in terms of compile\ntime costs, but maybe we can have two thirds or something?/p/li\n/ul\n/section\nsection id=\"acknowledgements\"\nh2Acknowledgements/h2\npThank you to a class=\"reference external\" href=\"https://bernsteinbear.com/\"Max Bernstein/a and a class=\"reference external\" href=\"https://martinfriedrichberger.net/\"Martin Berger/a for super helpful feedback on\ndrafts of the post!/p\n/section",
      "link": "https://www.pypy.org/posts/2024/10/jit-peephole-dsl.html",
      "links": [],
      "published": "2024-10-23T15:00:00+00:00",
      "summary": "",
      "title": "A DSL for Peephole Transformation Rules of Integer Operations in the PyPy JIT"
    },
    {
      "author": "The PyPy Team",
      "content": [
        {
          "type": "text/html",
          "value": "pThe PyPy project is always happy to hear about industrial use  and deployments\nof PyPy. For the a href=\"https://www.pypy.org/posts/2024/03/fixing-bug-incremental-gc.html\"GC bug\nfinding/a\ntask earlier this year, we collaborated with PortaOne and we're super happy\nthat Serhii Titov, head of the QA department at PortaOne, was up to writing\nthis guest post to describe their use and experience with the project./p\nhr\nh3 id=\"what-does-portaone-do\"What does PortaOne do?/h3\npWe at a href=\"https://www.portaone.com/\"PortaOne Inc./a allow telecom operators to\nlaunch new services (or provide existing services more efficiently) using our\nVoIP platform (PortaSIP) and our real-time charging system (PortaBilling),\nwhich provides additional features for cloud PBX, such as call transfer,\nqueues, interactive voice response (IVR) and more. At this moment our support\nteam manages several thousand servers with our software installed in 100\ncountries, through which over 500 telecommunication service providers connect\nmillions of end users every day. The unique thing about PortaOne is that we\nsupply the source code of our product to our customers - something unheard of\nin the telecom world! Thus we attract \"telco innovators\", who use our APIs to\nbuild around the system and the source code to create unique tweaks of\nfunctionality, which produces amazing products./p\npAt the core of PortaSIP is the middle-ware component (the proper name for it is\n\"B2BUA\", but that probably does not say much to anyone outside of experts in\nVoIP), which implements the actual handling of SIP calls, messages, etc. and\nall added features (for instance, trying to send a call via telco operators\nthrough which the cost per minute is lower). It has to be fast (since even a\nsmall delay in establishing a call is noticed by a customer), reliable\n(everyone hates when a call drops or cannot be completed) and yet easily\nexpandable with new functionality. This is why we decided to use Python as\nopposed to C/C++ or similar programming languages, which are often used in\ntelecom equipment./p\npThe B2BUA component is a batch of similar Python processes that are looped\ninside a\na href=\"https://docs.python.org/3.10/library/asyncore.html\"codeasyncore.dispatcher/code/a\nwrapper. The load balancing between these Python processes is done by our\nstateless SIP proxy server written in C++. All our sockets are served by this\nB2BUA. We have our custom client-wrappers around codepymysql/code, coderedis/code,\ncodecassandra-driver/code and coderequests/code to communicate with external services. Some\nof the Python processes use a href=\"https://cffi.readthedocs.io/en/stable/\"codecffi/code/a\nwrappers around C-code to improve their performance (examples: an Oracle DB\ndriver, a client to a radius server, a custom C logger)./p\npThe I/O operations that block the main thread of the Python processes are\nprocessed in sub-threads. We have custom wrappers  around codethreading.Thread/code\nand also codeasyncore.dispatcher/code. The results of such operations are returned to\nthe main thread./p\nh3 id=\"improving-our-performance-with-pypy\"Improving our performance with PyPy/h3\npWe started with CPython and then in 2014 switched to PyPy because it was\nfaster. Here's an exact quote from our first testing notes: \"PyPy gives\nsignificant performance boost, ~50%\". Nowadays, after years of changes in all\nthe software involved, PyPy still gives us +50% boost compared to CPython./p\npTaking care of real time traffic for so many people around the globe is\nsomething we're really proud of. I hope the PyPy team can be proud of it as\nwell, as the PyPy product is a part of this solution./p\nh3 id=\"finding-a-garbage-collector-bug-stage-1-the-gc-hooks\"Finding a garbage collector bug: stage 1, the GC hooks/h3\npHowever our path with PyPy wasn't perfectly smooth. There were very rare cases\nof crashes on PyPy that we weren't able to catch. That's because to make\ncoredump useful we needed to switch to PyPy with debug, but we cannot let it\nrun in that mode on a production system for an extended period of time, and we\ndid not have any STR (steps-to-reproduce) to make PyPy crash again in our lab.\nThat's why we kept (and still keep) both interpreters installed just in case,\nand we would switch to CPython if we noticed it happening./p\npAt the time of updating PyPy from 3.5 to 3.6 our QA started noticing those\ncrashes more often, but we still had no luck with STR or collecting proper\ncoredumps with debug symbols. Then it became even worse after our development\nplayed with the a href=\"https://doc.pypy.org/en/latest/gc_info.html\"Garbage Collector's\noptions/a to increase performance\nof our middleware component. The crashes started to affect our regular\nperformance testing (controlled by QA manager Yevhenii Bovda). At that point it\nwas decided that we can no longer live like that and so we started an intense\ninvestigation./p\npDuring the first stage of our investigation (following the best practice of\ntroubleshooting) we narrowed down the issue as much as we could. So, it was not\nour code, it was definitely somewhere in PyPy. Eventually our SIP software\nengineer a href=\"https://github.com/Yevhenii-Yatchenko\"Yevhenii Yatchenko/a found out\nthat this bug is connected with the use of our a href=\"https://doc.pypy.org/en/latest/gc_info.html#gc-hooks\"custom hooks in the\nGC/a. Yevhenii created\nticket a href=\"https://github.com/pypy/pypy/issues/4899\"#4899/a and within 2-3 days we\ngot a fix from a a href=\"https://github.com/cfbolz\"member of the PyPy team/a, in true open-source fashion./p\nh3 id=\"finding-a-garbage-collector-bug-stage-2-the-real-bug\"Finding a garbage collector bug: stage 2, the real bug/h3\npThen came stage 2. In parallel with the previous ticket, Yevhenii created\na href=\"https://github.com/pypy/pypy/issues/4900\"#4900/a that we still see failing\nwith coredumps quite often, and they are not connected to GC custom hooks. In a\nnutshell, it took us dozens of back and forward emails, three Zoom sessions and\nfour versions of a patch to solve the issue. During the last iteration we got a\nnew set of options to try and a new version of the patch. Surprisingly, that\nhelped! What a relief! So, the next logical step was to remove all debug\noptions and run PyPy only with the patch. Unfortunately, it started to fail\nagain and we came to the obvious conclusion that what will help us is not a\npatch, but one of options we were testing out. At that point we found out that\na href=\"https://doc.pypy.org/en/latest/gc_info.html#environment-variables\"codePYPY_GC_MAX_PINNED=0/code/a\nis a necessary and sufficient condition to solve our issue. This points to\nanother bug in the garbage collector, somehow related to object pinning./p\npHere's our current state: we have to add codePYPY_GC_MAX_PINNED=0/code, but we do not\nface the crashes anymore./p\nh3 id=\"conclusion-and-next-steps\"Conclusion and next steps/h3\npGratitude is extended to Carl for his invaluable assistance in resolving the\nnasty bugss, because it seems we're the only ones who suffered from the last\none and we really did not want to fall back to CPython due to its performance\ndisadvantage./p\npSerhii Titov, head of the QA department at PortaOne Inc./p\npP.S. If you are a perfectionist and at this point you have mixed feelings and\nyou are still bothered by the question \"But there might still be a bug in the\nGC, what about that?\" - Carl has some ideas about it and he will sort it out\n(we will help with the testing/verification part)./p"
        }
      ],
      "description": "pThe PyPy project is always happy to hear about industrial use  and deployments\nof PyPy. For the a href=\"https://www.pypy.org/posts/2024/03/fixing-bug-incremental-gc.html\"GC bug\nfinding/a\ntask earlier this year, we collaborated with PortaOne and we're super happy\nthat Serhii Titov, head of the QA department at PortaOne, was up to writing\nthis guest post to describe their use and experience with the project./p\nhr\nh3 id=\"what-does-portaone-do\"What does PortaOne do?/h3\npWe at a href=\"https://www.portaone.com/\"PortaOne Inc./a allow telecom operators to\nlaunch new services (or provide existing services more efficiently) using our\nVoIP platform (PortaSIP) and our real-time charging system (PortaBilling),\nwhich provides additional features for cloud PBX, such as call transfer,\nqueues, interactive voice response (IVR) and more. At this moment our support\nteam manages several thousand servers with our software installed in 100\ncountries, through which over 500 telecommunication service providers connect\nmillions of end users every day. The unique thing about PortaOne is that we\nsupply the source code of our product to our customers - something unheard of\nin the telecom world! Thus we attract \"telco innovators\", who use our APIs to\nbuild around the system and the source code to create unique tweaks of\nfunctionality, which produces amazing products./p\npAt the core of PortaSIP is the middle-ware component (the proper name for it is\n\"B2BUA\", but that probably does not say much to anyone outside of experts in\nVoIP), which implements the actual handling of SIP calls, messages, etc. and\nall added features (for instance, trying to send a call via telco operators\nthrough which the cost per minute is lower). It has to be fast (since even a\nsmall delay in establishing a call is noticed by a customer), reliable\n(everyone hates when a call drops or cannot be completed) and yet easily\nexpandable with new functionality. This is why we decided to use Python as\nopposed to C/C++ or similar programming languages, which are often used in\ntelecom equipment./p\npThe B2BUA component is a batch of similar Python processes that are looped\ninside a\na href=\"https://docs.python.org/3.10/library/asyncore.html\"codeasyncore.dispatcher/code/a\nwrapper. The load balancing between these Python processes is done by our\nstateless SIP proxy server written in C++. All our sockets are served by this\nB2BUA. We have our custom client-wrappers around codepymysql/code, coderedis/code,\ncodecassandra-driver/code and coderequests/code to communicate with external services. Some\nof the Python processes use a href=\"https://cffi.readthedocs.io/en/stable/\"codecffi/code/a\nwrappers around C-code to improve their performance (examples: an Oracle DB\ndriver, a client to a radius server, a custom C logger)./p\npThe I/O operations that block the main thread of the Python processes are\nprocessed in sub-threads. We have custom wrappers  around codethreading.Thread/code\nand also codeasyncore.dispatcher/code. The results of such operations are returned to\nthe main thread./p\nh3 id=\"improving-our-performance-with-pypy\"Improving our performance with PyPy/h3\npWe started with CPython and then in 2014 switched to PyPy because it was\nfaster. Here's an exact quote from our first testing notes: \"PyPy gives\nsignificant performance boost, ~50%\". Nowadays, after years of changes in all\nthe software involved, PyPy still gives us +50% boost compared to CPython./p\npTaking care of real time traffic for so many people around the globe is\nsomething we're really proud of. I hope the PyPy team can be proud of it as\nwell, as the PyPy product is a part of this solution./p\nh3 id=\"finding-a-garbage-collector-bug-stage-1-the-gc-hooks\"Finding a garbage collector bug: stage 1, the GC hooks/h3\npHowever our path with PyPy wasn't perfectly smooth. There were very rare cases\nof crashes on PyPy that we weren't able to catch. That's because to make\ncoredump useful we needed to switch to PyPy with debug, but we cannot let it\nrun in that mode on a production system for an extended period of time, and we\ndid not have any STR (steps-to-reproduce) to make PyPy crash again in our lab.\nThat's why we kept (and still keep) both interpreters installed just in case,\nand we would switch to CPython if we noticed it happening./p\npAt the time of updating PyPy from 3.5 to 3.6 our QA started noticing those\ncrashes more often, but we still had no luck with STR or collecting proper\ncoredumps with debug symbols. Then it became even worse after our development\nplayed with the a href=\"https://doc.pypy.org/en/latest/gc_info.html\"Garbage Collector's\noptions/a to increase performance\nof our middleware component. The crashes started to affect our regular\nperformance testing (controlled by QA manager Yevhenii Bovda). At that point it\nwas decided that we can no longer live like that and so we started an intense\ninvestigation./p\npDuring the first stage of our investigation (following the best practice of\ntroubleshooting) we narrowed down the issue as much as we could. So, it was not\nour code, it was definitely somewhere in PyPy. Eventually our SIP software\nengineer a href=\"https://github.com/Yevhenii-Yatchenko\"Yevhenii Yatchenko/a found out\nthat this bug is connected with the use of our a href=\"https://doc.pypy.org/en/latest/gc_info.html#gc-hooks\"custom hooks in the\nGC/a. Yevhenii created\nticket a href=\"https://github.com/pypy/pypy/issues/4899\"#4899/a and within 2-3 days we\ngot a fix from a a href=\"https://github.com/cfbolz\"member of the PyPy team/a, in true open-source fashion./p\nh3 id=\"finding-a-garbage-collector-bug-stage-2-the-real-bug\"Finding a garbage collector bug: stage 2, the real bug/h3\npThen came stage 2. In parallel with the previous ticket, Yevhenii created\na href=\"https://github.com/pypy/pypy/issues/4900\"#4900/a that we still see failing\nwith coredumps quite often, and they are not connected to GC custom hooks. In a\nnutshell, it took us dozens of back and forward emails, three Zoom sessions and\nfour versions of a patch to solve the issue. During the last iteration we got a\nnew set of options to try and a new version of the patch. Surprisingly, that\nhelped! What a relief! So, the next logical step was to remove all debug\noptions and run PyPy only with the patch. Unfortunately, it started to fail\nagain and we came to the obvious conclusion that what will help us is not a\npatch, but one of options we were testing out. At that point we found out that\na href=\"https://doc.pypy.org/en/latest/gc_info.html#environment-variables\"codePYPY_GC_MAX_PINNED=0/code/a\nis a necessary and sufficient condition to solve our issue. This points to\nanother bug in the garbage collector, somehow related to object pinning./p\npHere's our current state: we have to add codePYPY_GC_MAX_PINNED=0/code, but we do not\nface the crashes anymore./p\nh3 id=\"conclusion-and-next-steps\"Conclusion and next steps/h3\npGratitude is extended to Carl for his invaluable assistance in resolving the\nnasty bugss, because it seems we're the only ones who suffered from the last\none and we really did not want to fall back to CPython due to its performance\ndisadvantage./p\npSerhii Titov, head of the QA department at PortaOne Inc./p\npP.S. If you are a perfectionist and at this point you have mixed feelings and\nyou are still bothered by the question \"But there might still be a bug in the\nGC, what about that?\" - Carl has some ideas about it and he will sort it out\n(we will help with the testing/verification part)./p",
      "link": "https://www.pypy.org/posts/2024/08/portaone.html",
      "links": [],
      "published": "2024-08-29T09:00:00+00:00",
      "summary": "",
      "title": "Guest Post: How PortaOne uses PyPy for high-performance processing, connecting over 1B of phone calls every month"
    },
    {
      "author": "mattip",
      "content": [
        {
          "type": "text/html",
          "value": "section id=\"pypy-v7-3-17-release-of-python-2-7-and-3-10\"\nh2PyPy v7.3.17: release of python 2.7 and 3.10/h2\npThe PyPy team is proud to release version 7.3.17 of PyPy./p\npThis release includes a new a class=\"reference internal\" href=\"https://www.pypy.org/posts/2024/08/pypy-v7317-release.html#risc-v-jit-backend\"RISC-V JIT backend/a, an a class=\"reference internal\" href=\"https://www.pypy.org/posts/2024/08/pypy-v7317-release.html#improved-repl\"improved REPL/a based on\nwork by the CPython team, and a class=\"reference internal\" href=\"https://www.pypy.org/posts/2024/08/pypy-v7317-release.html#better-jit-optimizations\"better JIT optimizations/a of integer\noperations. Special shout-outs to a class=\"reference external\" href=\"https://github.com/loganchien\"Logan Chien/a for the a class=\"reference external\" href=\"https://github.com/pypy/pypy/pull/5002\"RISC-V backend\nwork/a, to a class=\"reference external\" href=\"https://github.com/nirit100\"Nico Rittinghaus/a for better integer optimization in the JIT, and\nthe CPython team that has worked on the repl./p\npThe release includes two different interpreters:/p\nul class=\"simple\"\nlipPyPy2.7, which is an interpreter supporting the syntax and the features of\nPython 2.7 including the stdlib for CPython 2.7.18+ (the code class=\"docutils literal\"+/code is for\nbackported security updates)/p/li\nlipPyPy3.10, which is an interpreter supporting the syntax and the features of\nPython 3.10, including the stdlib for CPython 3.10.14./p/li\n/ul\npThe interpreters are based on much the same codebase, thus the dual\nrelease. This is a micro release, all APIs are compatible with the other 7.3\nreleases. It follows after 7.3.16 release on April 23, 2024./p\npWe recommend updating. You can find links to download the releases here:/p\nblockquote\npa class=\"reference external\" href=\"https://pypy.org/download.html\"https://pypy.org/download.html/a/p\n/blockquote\npWe would like to thank our donors for the continued support of the PyPy\nproject. If PyPy is not quite good enough for your needs, we are available for\na class=\"reference external\" href=\"https://www.pypy.org/pypy-sponsors.html\"direct consulting/a work. If PyPy is helping you out, we would love to hear\nabout it and encourage submissions to our a class=\"reference external\" href=\"https://pypy.org/blog\"blog/a via a pull request\nto a class=\"reference external\" href=\"https://github.com/pypy/pypy.org\"https://github.com/pypy/pypy.org/a/p\npWe would also like to thank our contributors and encourage new people to join\nthe project. PyPy has many layers and we need help with all of them: bug fixes,\na class=\"reference external\" href=\"https://www.pypy.org/posts/2024/08/index.html\"PyPy/a and a class=\"reference external\" href=\"https://rpython.readthedocs.org\"RPython/a documentation improvements, or general a class=\"reference external\" href=\"https://www.pypy.org/posts/2024/08/project-ideas.html\"help/a with\nmaking RPython's JIT even better./p\npIf you are a python library maintainer and use C-extensions, please consider\nmaking a a class=\"reference external\" href=\"https://hpyproject.org/\"HPy/a / a class=\"reference external\" href=\"https://cffi.readthedocs.io\"CFFI/a / a class=\"reference external\" href=\"https://cppyy.readthedocs.io\"cppyy/a version of your library that would be performant\non PyPy. In any case, both a class=\"reference external\" href=\"https://github.com/joerick/cibuildwheel\"cibuildwheel/a and the a class=\"reference external\" href=\"https://github.com/matthew-brett/multibuild\"multibuild system/a support\nbuilding wheels for PyPy./p\nsection id=\"risc-v-backend-for-the-jit\"\nspan id=\"risc-v-jit-backend\"/spanh3RISC-V backend for the JIT/h3\npPyPy's JIT has added support for generating 64-bit RISC-V machine code at\nruntime (RV64-IMAD, specifically). So far we are not releasing binaries for any\nRISC-V platforms, but there are a class=\"reference external\" href=\"https://rpython.readthedocs.io/en/latest/riscv.html\"instructions/a on how to cross-compile binaries./p\n/section\nsection id=\"repl-improvements\"\nspan id=\"improved-repl\"/spanh3REPL Improvements/h3\npThe biggest user-visible change of the release is new features in the repl of\nPyPy3.10. CPython 3.13 has adopted and extended PyPy's pure-Python repl, adding\na number of features and fixing a number or bugs in the process. We have\nbackported and added the following features:/p\nul class=\"simple\"\nlipPrompts and tracebacks use terminal colors, as well as a class=\"reference external\" href=\"https://gist.github.com/egmontkob/eb114294efbcd5adb1944c9f3cb5feda\"terminal hyperlinks/a\nfor file names./p/li\nlipa class=\"reference external\" href=\"https://en.wikipedia.org/wiki/Bracketed-paste\"Bracketed paste/a enable pasting several lines of input into the terminal\nwithout auto-indentation getting in the way./p/li\nlipA special interactive help browser (F1), history browser (F2), explicit paste\nmode (F3)./p/li\nlipSupport for Ctrl-lt;left/rightgt; to jump over whole words at a time./p/li\n/ul\npSee the a class=\"reference external\" href=\"https://docs.python.org/3.13/whatsnew/3.13.html#a-better-interactive-interpreter\"CPython documentation for further details/a. Thanks to ukasz Langa,\nPablo Galindo Salgado and the other CPython devs involved in this work./p\n/section\nsection id=\"better-jit-optimizations-of-integer-operations\"\nspan id=\"better-jit-optimizations\"/spanh3Better JIT optimizations of integer operations/h3\npThe optimizers of PyPy's JIT have become much better at reasoning about and\noptimizing integer operations. This is done with a new a class=\"reference external\" href=\"https://pypy.org/posts/2024/08/toy-knownbits.html\"\"knownbits\" abstract\ndomain/a. In many programs that do bit-manipulation of integers, some of the\nbits of the integer variables of the program can be statically known. Here's a\nsimple example:/p\ndiv class=\"code\"pre class=\"code python\"a id=\"rest_code_fdd24c5078e54549bf7486e2ecbcad3e-1\" name=\"rest_code_fdd24c5078e54549bf7486e2ecbcad3e-1\" href=\"https://www.pypy.org/posts/2024/08/pypy-v7317-release.html#rest_code_fdd24c5078e54549bf7486e2ecbcad3e-1\"/aspan class=\"n\"x/span span class=\"o\"=/span span class=\"n\"a/span span class=\"o\"|/span span class=\"mi\"1/span\na id=\"rest_code_fdd24c5078e54549bf7486e2ecbcad3e-2\" name=\"rest_code_fdd24c5078e54549bf7486e2ecbcad3e-2\" href=\"https://www.pypy.org/posts/2024/08/pypy-v7317-release.html#rest_code_fdd24c5078e54549bf7486e2ecbcad3e-2\"/aspan class=\"o\".../span\na id=\"rest_code_fdd24c5078e54549bf7486e2ecbcad3e-3\" name=\"rest_code_fdd24c5078e54549bf7486e2ecbcad3e-3\" href=\"https://www.pypy.org/posts/2024/08/pypy-v7317-release.html#rest_code_fdd24c5078e54549bf7486e2ecbcad3e-3\"/aspan class=\"k\"if/span span class=\"n\"x/span span class=\"o\"amp;/span span class=\"mi\"1/spanspan class=\"p\":/span\na id=\"rest_code_fdd24c5078e54549bf7486e2ecbcad3e-4\" name=\"rest_code_fdd24c5078e54549bf7486e2ecbcad3e-4\" href=\"https://www.pypy.org/posts/2024/08/pypy-v7317-release.html#rest_code_fdd24c5078e54549bf7486e2ecbcad3e-4\"/a    span class=\"o\".../span\na id=\"rest_code_fdd24c5078e54549bf7486e2ecbcad3e-5\" name=\"rest_code_fdd24c5078e54549bf7486e2ecbcad3e-5\" href=\"https://www.pypy.org/posts/2024/08/pypy-v7317-release.html#rest_code_fdd24c5078e54549bf7486e2ecbcad3e-5\"/aspan class=\"k\"else/spanspan class=\"p\":/span\na id=\"rest_code_fdd24c5078e54549bf7486e2ecbcad3e-6\" name=\"rest_code_fdd24c5078e54549bf7486e2ecbcad3e-6\" href=\"https://www.pypy.org/posts/2024/08/pypy-v7317-release.html#rest_code_fdd24c5078e54549bf7486e2ecbcad3e-6\"/a    span class=\"o\".../span\n/pre/div\npWith the new abstract domain, the JIT can optimize the code class=\"docutils literal\"if/code-condition to\ncode class=\"docutils literal\"True/code, because it already knows that the lowest bit of code class=\"docutils literal\"x/code must be set.\nThis optimization applies to all Python-integers that fit into a machine word\n(PyPy optimistically picks between two different representations for code class=\"docutils literal\"int/code,\ndepending on the size of the value). Unfortunately there is very little impact\nof this change on almost all Python code, because intensive bit-manipulation is\nrare in Python. However, the change leads to significant performance\nimprovements in a class=\"reference external\" href=\"https://docs.pydrofoil.org/en/latest/\"Pydrofoil/a (the RPython-based RISC-V/ARM emulators that are\nautomatically generated from high-level a class=\"reference external\" href=\"https://github.com/rems-project/sail/\"Sail/a specifications of the respective\nISAs, and that use the RPython JIT to improve performance)./p\n/section\nsection id=\"pypy-versions-and-speed-pypy-org\"\nh3PyPy versions and speed.pypy.org/h3\npThe keen-eyed will have noticed no mention of Python version 3.9 in the\nreleases above. Typically we will maintain only one version of Python3, but due\nto PyPy3.9 support on conda-forge we maintained multiple versions from the\nfirst release of PyPy3.10 in PyPy v7.3.12 (Dec 2022). Conda-forge is\na class=\"reference external\" href=\"https://pypy.org/posts/2024/08/conda-forge-proposes-dropping-support-for-pypy.html\"sunsetting its PyPy support/a, which means we can drop PyPy3.9. Since that was\nthe major driver of benchmarks at a class=\"reference external\" href=\"https://speed.pypy.org\"https://speed.pypy.org/a, we revamped the site\nto showcase PyPy3.9, PyPy3.10, and various versions of cpython on the home\npage. For historical reasons, the \"baseline\" for comparison is still cpython\n3.7.19./p\npWe will keep the buildbots building PyPY3.9 until the end of August, these\nbuilds will still be available on the a class=\"reference external\" href=\"https://buildbot.pypy.org/nightly/\"nightly builds/a tab of the buildbot./p\n/section\nsection id=\"what-is-pypy\"\nh3What is PyPy?/h3\npPyPy is a Python interpreter, a drop-in replacement for CPython\nIt's fast (a class=\"reference external\" href=\"https://speed.pypy.org\"PyPy and CPython/a performance\ncomparison) due to its integrated tracing JIT compiler./p\npWe also welcome developers of other a class=\"reference external\" href=\"https://rpython.readthedocs.io/en/latest/examples.html\"dynamic languages/a to see what RPython\ncan do for them./p\npWe provide binary builds for:/p\nul class=\"simple\"\nlipstrongx86/strong machines on most common operating systems\n(Linux 32/64 bits, Mac OS 64 bits, Windows 64 bits)/p/li\nlip64-bit strongARM/strong machines running Linux (code class=\"docutils literal\"aarch64/code) and macos (code class=\"docutils literal\"macos_arm64/code)./p/li\n/ul\npPyPy supports Windows 32-bit, Linux PPC64 big- and little-endian, Linux ARM\n32 bit, RISC-V RV64IMAFD Linux, and s390x Linux but does not release binaries.\nPlease reach out to us if you wish to sponsor binary releases for those\nplatforms. Downstream packagers provide binary builds for debian, Fedora,\nconda, OpenBSD, FreeBSD, Gentoo, and more./p\n/section\nsection id=\"what-else-is-new\"\nh3What else is new?/h3\npFor more information about the 7.3.17 release, see the a class=\"reference external\" href=\"https://doc.pypy.org/en/latest/release-v7.3.17.html#changelog\"full changelog/a./p\npPlease update, and continue to help us make pypy better./p\npCheers,\nThe PyPy Team/p\n/section\n/section"
        }
      ],
      "description": "section id=\"pypy-v7-3-17-release-of-python-2-7-and-3-10\"\nh2PyPy v7.3.17: release of python 2.7 and 3.10/h2\npThe PyPy team is proud to release version 7.3.17 of PyPy./p\npThis release includes a new a class=\"reference internal\" href=\"https://www.pypy.org/posts/2024/08/pypy-v7317-release.html#risc-v-jit-backend\"RISC-V JIT backend/a, an a class=\"reference internal\" href=\"https://www.pypy.org/posts/2024/08/pypy-v7317-release.html#improved-repl\"improved REPL/a based on\nwork by the CPython team, and a class=\"reference internal\" href=\"https://www.pypy.org/posts/2024/08/pypy-v7317-release.html#better-jit-optimizations\"better JIT optimizations/a of integer\noperations. Special shout-outs to a class=\"reference external\" href=\"https://github.com/loganchien\"Logan Chien/a for the a class=\"reference external\" href=\"https://github.com/pypy/pypy/pull/5002\"RISC-V backend\nwork/a, to a class=\"reference external\" href=\"https://github.com/nirit100\"Nico Rittinghaus/a for better integer optimization in the JIT, and\nthe CPython team that has worked on the repl./p\npThe release includes two different interpreters:/p\nul class=\"simple\"\nlipPyPy2.7, which is an interpreter supporting the syntax and the features of\nPython 2.7 including the stdlib for CPython 2.7.18+ (the code class=\"docutils literal\"+/code is for\nbackported security updates)/p/li\nlipPyPy3.10, which is an interpreter supporting the syntax and the features of\nPython 3.10, including the stdlib for CPython 3.10.14./p/li\n/ul\npThe interpreters are based on much the same codebase, thus the dual\nrelease. This is a micro release, all APIs are compatible with the other 7.3\nreleases. It follows after 7.3.16 release on April 23, 2024./p\npWe recommend updating. You can find links to download the releases here:/p\nblockquote\npa class=\"reference external\" href=\"https://pypy.org/download.html\"https://pypy.org/download.html/a/p\n/blockquote\npWe would like to thank our donors for the continued support of the PyPy\nproject. If PyPy is not quite good enough for your needs, we are available for\na class=\"reference external\" href=\"https://www.pypy.org/pypy-sponsors.html\"direct consulting/a work. If PyPy is helping you out, we would love to hear\nabout it and encourage submissions to our a class=\"reference external\" href=\"https://pypy.org/blog\"blog/a via a pull request\nto a class=\"reference external\" href=\"https://github.com/pypy/pypy.org\"https://github.com/pypy/pypy.org/a/p\npWe would also like to thank our contributors and encourage new people to join\nthe project. PyPy has many layers and we need help with all of them: bug fixes,\na class=\"reference external\" href=\"https://www.pypy.org/posts/2024/08/index.html\"PyPy/a and a class=\"reference external\" href=\"https://rpython.readthedocs.org\"RPython/a documentation improvements, or general a class=\"reference external\" href=\"https://www.pypy.org/posts/2024/08/project-ideas.html\"help/a with\nmaking RPython's JIT even better./p\npIf you are a python library maintainer and use C-extensions, please consider\nmaking a a class=\"reference external\" href=\"https://hpyproject.org/\"HPy/a / a class=\"reference external\" href=\"https://cffi.readthedocs.io\"CFFI/a / a class=\"reference external\" href=\"https://cppyy.readthedocs.io\"cppyy/a version of your library that would be performant\non PyPy. In any case, both a class=\"reference external\" href=\"https://github.com/joerick/cibuildwheel\"cibuildwheel/a and the a class=\"reference external\" href=\"https://github.com/matthew-brett/multibuild\"multibuild system/a support\nbuilding wheels for PyPy./p\nsection id=\"risc-v-backend-for-the-jit\"\nspan id=\"risc-v-jit-backend\"/spanh3RISC-V backend for the JIT/h3\npPyPy's JIT has added support for generating 64-bit RISC-V machine code at\nruntime (RV64-IMAD, specifically). So far we are not releasing binaries for any\nRISC-V platforms, but there are a class=\"reference external\" href=\"https://rpython.readthedocs.io/en/latest/riscv.html\"instructions/a on how to cross-compile binaries./p\n/section\nsection id=\"repl-improvements\"\nspan id=\"improved-repl\"/spanh3REPL Improvements/h3\npThe biggest user-visible change of the release is new features in the repl of\nPyPy3.10. CPython 3.13 has adopted and extended PyPy's pure-Python repl, adding\na number of features and fixing a number or bugs in the process. We have\nbackported and added the following features:/p\nul class=\"simple\"\nlipPrompts and tracebacks use terminal colors, as well as a class=\"reference external\" href=\"https://gist.github.com/egmontkob/eb114294efbcd5adb1944c9f3cb5feda\"terminal hyperlinks/a\nfor file names./p/li\nlipa class=\"reference external\" href=\"https://en.wikipedia.org/wiki/Bracketed-paste\"Bracketed paste/a enable pasting several lines of input into the terminal\nwithout auto-indentation getting in the way./p/li\nlipA special interactive help browser (F1), history browser (F2), explicit paste\nmode (F3)./p/li\nlipSupport for Ctrl-lt;left/rightgt; to jump over whole words at a time./p/li\n/ul\npSee the a class=\"reference external\" href=\"https://docs.python.org/3.13/whatsnew/3.13.html#a-better-interactive-interpreter\"CPython documentation for further details/a. Thanks to ukasz Langa,\nPablo Galindo Salgado and the other CPython devs involved in this work./p\n/section\nsection id=\"better-jit-optimizations-of-integer-operations\"\nspan id=\"better-jit-optimizations\"/spanh3Better JIT optimizations of integer operations/h3\npThe optimizers of PyPy's JIT have become much better at reasoning about and\noptimizing integer operations. This is done with a new a class=\"reference external\" href=\"https://pypy.org/posts/2024/08/toy-knownbits.html\"\"knownbits\" abstract\ndomain/a. In many programs that do bit-manipulation of integers, some of the\nbits of the integer variables of the program can be statically known. Here's a\nsimple example:/p\ndiv class=\"code\"pre class=\"code python\"a id=\"rest_code_fdd24c5078e54549bf7486e2ecbcad3e-1\" name=\"rest_code_fdd24c5078e54549bf7486e2ecbcad3e-1\" href=\"https://www.pypy.org/posts/2024/08/pypy-v7317-release.html#rest_code_fdd24c5078e54549bf7486e2ecbcad3e-1\"/aspan class=\"n\"x/span span class=\"o\"=/span span class=\"n\"a/span span class=\"o\"|/span span class=\"mi\"1/span\na id=\"rest_code_fdd24c5078e54549bf7486e2ecbcad3e-2\" name=\"rest_code_fdd24c5078e54549bf7486e2ecbcad3e-2\" href=\"https://www.pypy.org/posts/2024/08/pypy-v7317-release.html#rest_code_fdd24c5078e54549bf7486e2ecbcad3e-2\"/aspan class=\"o\".../span\na id=\"rest_code_fdd24c5078e54549bf7486e2ecbcad3e-3\" name=\"rest_code_fdd24c5078e54549bf7486e2ecbcad3e-3\" href=\"https://www.pypy.org/posts/2024/08/pypy-v7317-release.html#rest_code_fdd24c5078e54549bf7486e2ecbcad3e-3\"/aspan class=\"k\"if/span span class=\"n\"x/span span class=\"o\"amp;/span span class=\"mi\"1/spanspan class=\"p\":/span\na id=\"rest_code_fdd24c5078e54549bf7486e2ecbcad3e-4\" name=\"rest_code_fdd24c5078e54549bf7486e2ecbcad3e-4\" href=\"https://www.pypy.org/posts/2024/08/pypy-v7317-release.html#rest_code_fdd24c5078e54549bf7486e2ecbcad3e-4\"/a    span class=\"o\".../span\na id=\"rest_code_fdd24c5078e54549bf7486e2ecbcad3e-5\" name=\"rest_code_fdd24c5078e54549bf7486e2ecbcad3e-5\" href=\"https://www.pypy.org/posts/2024/08/pypy-v7317-release.html#rest_code_fdd24c5078e54549bf7486e2ecbcad3e-5\"/aspan class=\"k\"else/spanspan class=\"p\":/span\na id=\"rest_code_fdd24c5078e54549bf7486e2ecbcad3e-6\" name=\"rest_code_fdd24c5078e54549bf7486e2ecbcad3e-6\" href=\"https://www.pypy.org/posts/2024/08/pypy-v7317-release.html#rest_code_fdd24c5078e54549bf7486e2ecbcad3e-6\"/a    span class=\"o\".../span\n/pre/div\npWith the new abstract domain, the JIT can optimize the code class=\"docutils literal\"if/code-condition to\ncode class=\"docutils literal\"True/code, because it already knows that the lowest bit of code class=\"docutils literal\"x/code must be set.\nThis optimization applies to all Python-integers that fit into a machine word\n(PyPy optimistically picks between two different representations for code class=\"docutils literal\"int/code,\ndepending on the size of the value). Unfortunately there is very little impact\nof this change on almost all Python code, because intensive bit-manipulation is\nrare in Python. However, the change leads to significant performance\nimprovements in a class=\"reference external\" href=\"https://docs.pydrofoil.org/en/latest/\"Pydrofoil/a (the RPython-based RISC-V/ARM emulators that are\nautomatically generated from high-level a class=\"reference external\" href=\"https://github.com/rems-project/sail/\"Sail/a specifications of the respective\nISAs, and that use the RPython JIT to improve performance)./p\n/section\nsection id=\"pypy-versions-and-speed-pypy-org\"\nh3PyPy versions and speed.pypy.org/h3\npThe keen-eyed will have noticed no mention of Python version 3.9 in the\nreleases above. Typically we will maintain only one version of Python3, but due\nto PyPy3.9 support on conda-forge we maintained multiple versions from the\nfirst release of PyPy3.10 in PyPy v7.3.12 (Dec 2022). Conda-forge is\na class=\"reference external\" href=\"https://pypy.org/posts/2024/08/conda-forge-proposes-dropping-support-for-pypy.html\"sunsetting its PyPy support/a, which means we can drop PyPy3.9. Since that was\nthe major driver of benchmarks at a class=\"reference external\" href=\"https://speed.pypy.org\"https://speed.pypy.org/a, we revamped the site\nto showcase PyPy3.9, PyPy3.10, and various versions of cpython on the home\npage. For historical reasons, the \"baseline\" for comparison is still cpython\n3.7.19./p\npWe will keep the buildbots building PyPY3.9 until the end of August, these\nbuilds will still be available on the a class=\"reference external\" href=\"https://buildbot.pypy.org/nightly/\"nightly builds/a tab of the buildbot./p\n/section\nsection id=\"what-is-pypy\"\nh3What is PyPy?/h3\npPyPy is a Python interpreter, a drop-in replacement for CPython\nIt's fast (a class=\"reference external\" href=\"https://speed.pypy.org\"PyPy and CPython/a performance\ncomparison) due to its integrated tracing JIT compiler./p\npWe also welcome developers of other a class=\"reference external\" href=\"https://rpython.readthedocs.io/en/latest/examples.html\"dynamic languages/a to see what RPython\ncan do for them./p\npWe provide binary builds for:/p\nul class=\"simple\"\nlipstrongx86/strong machines on most common operating systems\n(Linux 32/64 bits, Mac OS 64 bits, Windows 64 bits)/p/li\nlip64-bit strongARM/strong machines running Linux (code class=\"docutils literal\"aarch64/code) and macos (code class=\"docutils literal\"macos_arm64/code)./p/li\n/ul\npPyPy supports Windows 32-bit, Linux PPC64 big- and little-endian, Linux ARM\n32 bit, RISC-V RV64IMAFD Linux, and s390x Linux but does not release binaries.\nPlease reach out to us if you wish to sponsor binary releases for those\nplatforms. Downstream packagers provide binary builds for debian, Fedora,\nconda, OpenBSD, FreeBSD, Gentoo, and more./p\n/section\nsection id=\"what-else-is-new\"\nh3What else is new?/h3\npFor more information about the 7.3.17 release, see the a class=\"reference external\" href=\"https://doc.pypy.org/en/latest/release-v7.3.17.html#changelog\"full changelog/a./p\npPlease update, and continue to help us make pypy better./p\npCheers,\nThe PyPy Team/p\n/section\n/section",
      "link": "https://www.pypy.org/posts/2024/08/pypy-v7317-release.html",
      "links": [],
      "published": "2024-08-28T12:22:08+00:00",
      "summary": "",
      "title": "PyPy v7.3.17 release"
    },
    {
      "author": "mattip",
      "content": [
        {
          "type": "text/html",
          "value": "pConda-forge has kindly been providing support for PyPy since 2019. The\nconda-forge team has been very patient and generous with resources, but it\nseems the uptake of PyPy has not justified the effort. Major packages still\nare not a href=\"https://conda-forge.org/status/migration/?name=pypy38\"available on PyPy/a,\nothers find it hard to a href=\"https://github.com/conda-forge/numpy-feedstock/pull/310\"update\nversions/a. We don't\nget much feedback at all about people using PyPy, and even less about PyPy on\nconda-forge. The conda-forge team has proposed a href=\"https://github.com/conda-forge/conda-forge.github.io/pull/2259\"sunsetting\nPyPy/a going\nforward, which means current packages would remain but no new packages would be\nbuilt. If you have an opinion, you can comment on that PR, or on this blog post./p\npSince conda-forge supports PyPy3.9 but not PyPy3.10, we have continued\nreleasing PyPy3.9 even though we typically support only one version of PyPy3.\nWith the sunsetting proposal, we will not release any more updates to PyPy3.9.\nI opened a a href=\"https://github.com/orgs/pypy/discussions/4998\"poll/a about the\nintention to drop PyPy3.9. If you have an opinion, please chime in./p"
        }
      ],
      "description": "pConda-forge has kindly been providing support for PyPy since 2019. The\nconda-forge team has been very patient and generous with resources, but it\nseems the uptake of PyPy has not justified the effort. Major packages still\nare not a href=\"https://conda-forge.org/status/migration/?name=pypy38\"available on PyPy/a,\nothers find it hard to a href=\"https://github.com/conda-forge/numpy-feedstock/pull/310\"update\nversions/a. We don't\nget much feedback at all about people using PyPy, and even less about PyPy on\nconda-forge. The conda-forge team has proposed a href=\"https://github.com/conda-forge/conda-forge.github.io/pull/2259\"sunsetting\nPyPy/a going\nforward, which means current packages would remain but no new packages would be\nbuilt. If you have an opinion, you can comment on that PR, or on this blog post./p\npSince conda-forge supports PyPy3.9 but not PyPy3.10, we have continued\nreleasing PyPy3.9 even though we typically support only one version of PyPy3.\nWith the sunsetting proposal, we will not release any more updates to PyPy3.9.\nI opened a a href=\"https://github.com/orgs/pypy/discussions/4998\"poll/a about the\nintention to drop PyPy3.9. If you have an opinion, please chime in./p",
      "link": "https://www.pypy.org/posts/2024/08/conda-forge-proposes-dropping-support-for-pypy.html",
      "links": [],
      "published": "2024-08-09T06:27:41+00:00",
      "summary": "",
      "title": "Conda-forge proposes sunsetting support for PyPy"
    },
    {
      "author": "CF Bolz-Tereick",
      "content": [
        {
          "type": "text/html",
          "value": "pAfter a href=\"https://bernsteinbear.com/blog/toy-abstract-interpretation/\"Max' introduction to abstract interpretation for the toy optimizer/a in the\nlast post, I want to present a more complicated abstract domain in this post.\nThis abstract domain reasons about the individual bits of a variable in a trace.\nEvery bit can be either \"known zero\", \"known one\" or \"unknown\". The abstract\ndomain is useful for optimizing integer operations, particularly the bitwise operations.\nThe abstract domain follows quite closely the a href=\"https://github.com/torvalds/linux/blob/master/kernel/bpf/tnum.c\"tristate abstract domain of the\neBPF verifier in the Linux\nKernel/a, as\ndescribed by the paper\na href=\"https://arxiv.org/abs/2105.05398\"Sound, Precise, and Fast Abstract Interpretation with Tristate\nNumbers/a by Harishankar Vishwanathan, Matan\nShachnai, Srinivas Narayana, and Santosh Nagarakatte./p\npThe presentation in this post will still be in the context of the\na href=\"https://www.pypy.org/categories/toy-optimizer\"toy optimizer/a. We'll spend a significant part of\nthe post convincing ourselves that the abstract domain transfer functions that\nwe're writing are really correct, using both property-based testing and\nautomated proofs (again using Z3)./p\npPyPy has implemented and merged a more complicated version of the same abstract\ndomain for the \"real\" PyPy JIT. A more thorough explanation of that real world\nimplementation will follow./p\npI'd like to thank Max Bernstein and Armin Rigo for lots of great feedback on\ndrafts of this post. The PyPy implementation was mainly done by Nico\nRittinghaus and me./p\npstrongContents:/strong/p\ndiv class=\"toc\"\nul\nlia href=\"https://www.pypy.org/posts/2024/08/toy-knownbits.html#motivation\"Motivation/a/li\nlia href=\"https://www.pypy.org/posts/2024/08/toy-knownbits.html#the-knownbits-abstract-domain\"The Knownbits Abstract Domain/a/li\nlia href=\"https://www.pypy.org/posts/2024/08/toy-knownbits.html#transfer-functions\"Transfer Functions/a/li\nlia href=\"https://www.pypy.org/posts/2024/08/toy-knownbits.html#property-based-tests-with-hypothesis\"Property-based Tests with Hypothesis/a/li\nlia href=\"https://www.pypy.org/posts/2024/08/toy-knownbits.html#when-are-transfer-functions-correct-how-do-we-test-them\"When are Transfer Functions Correct? How do we test them?/a/li\nlia href=\"https://www.pypy.org/posts/2024/08/toy-knownbits.html#implementing-binary-transfer-functions\"Implementing Binary Transfer Functions/a/li\nlia href=\"https://www.pypy.org/posts/2024/08/toy-knownbits.html#addition-and-subtraction\"Addition and Subtraction/a/li\nlia href=\"https://www.pypy.org/posts/2024/08/toy-knownbits.html#proving-correctness-of-the-transfer-functions-with-z3\"Proving correctness of the transfer functions with Z3/a/li\nlia href=\"https://www.pypy.org/posts/2024/08/toy-knownbits.html#cases-where-this-style-of-z3-proof-doesnt-work\"Cases where this style of Z3 proof doesn't work/a/li\nlia href=\"https://www.pypy.org/posts/2024/08/toy-knownbits.html#making-statements-about-precision\"Making Statements about Precision/a/li\nlia href=\"https://www.pypy.org/posts/2024/08/toy-knownbits.html#using-the-abstract-domain-in-the-toy-optimizer-for-generalized-constant-folding\"Using the Abstract Domain in the Toy Optimizer for Generalized Constant Folding/a/li\nlia href=\"https://www.pypy.org/posts/2024/08/toy-knownbits.html#using-the-knownbits-domain-for-conditional-peephole-rewrites\"Using the KnownBits Domain for Conditional Peephole Rewrites/a/li\nlia href=\"https://www.pypy.org/posts/2024/08/toy-knownbits.html#conclusion\"Conclusion/a/li\n/ul\n/div\nh3 id=\"motivation\"Motivation/h3\npIn many programs that do bit-manipulation of integers, some of the bits of the\ninteger variables of the program can be statically known. Here's a simple\nexample:/p\ndiv class=\"code\"pre class=\"code literal-block\"span class=\"nv\"x/spanspan class=\"w\" /spanspan class=\"o\"=/spanspan class=\"w\" /spanspan class=\"nv\"a/spanspan class=\"w\" /spanspan class=\"o\"|/spanspan class=\"w\" /spanspan class=\"mi\"1/span\n...\nspan class=\"k\"if/spanspan class=\"w\" /spanspan class=\"nv\"x/spanspan class=\"w\" /spanspan class=\"o\"amp;/spanspan class=\"w\" /spanspan class=\"mi\"1/span:\nspan class=\"w\"    /span...\nspan class=\"k\"else/span:\nspan class=\"w\"    /span...\n/pre/div\n\npAfter the assignment codex = a | 1/code, we know that the lowest bit of codex/code must be code1/code\n(the other bits are unknown) and an optimizer could remove the condition codex amp; 1/code by\nconstant-folding it to code1/code./p\npAnother (more complicated) example is:/p\ndiv class=\"code\"pre class=\"code literal-block\"assert i amp; 0b111 == 0 # check that i is a multiple of 8\nj = i + 16\nassert j amp; 0b111 == 0\n/pre/div\n\npThis kind of code could e.g. happen in a a href=\"https://docs.pydrofoil.org/en/latest/\"CPU\nemulator/a, where codei/code and codej/code are\nintegers that represent emulated pointers, and the codeassert/codes are alignment\nchecks. The first assert implies that the lowest three bits of i must be code0/code.\nAdding 16 to such a number produces a result where the lowest three bits are\nagain all code0/code, therefore the second assert is always true. So we would like a\ncompiler to remove the second assert./p\npBoth of these will optimizations are doable with the help of the knownbits\nabstract domain that we'll discuss in the rest of the post./p\nh3 id=\"the-knownbits-abstract-domain\"The Knownbits Abstract Domain/h3\npAn abstract value of the knownbits domain needs to be able to store, for every\nbit of an integer variable in a program, whether it is known 0, known 1, or\nunknown. To represent\nthree different states, we need 2 bits, which we will call codeone/code and codeunknown/code.\nHere's the encoding:/p\ntable\nthead\ntr\nthone/th\nthunknown/th\nth align=\"right\"knownbit/th\n/tr\n/thead\ntbody\ntr\ntd0/td\ntd0/td\ntd align=\"right\"0/td\n/tr\ntr\ntd1/td\ntd0/td\ntd align=\"right\"1/td\n/tr\ntr\ntd0/td\ntd1/td\ntd align=\"right\"?/td\n/tr\ntr\ntd1/td\ntd1/td\ntd align=\"right\"illegal/td\n/tr\n/tbody\n/table\npThe codeunknown/code bit is set if we don't know the value of the bit (\"?\"), the codeone/code\nbit is set if the bit is known to be a code1/code. Since two bits are enough to encode\nfour different states, but we only need three, the combination of a set codeone/code\nbit and a set codeunknown/code is not allowed./p\npWe don't just want to encode a single bit, however. Instead, we want to do this\nfor all the bits of an integer variable. Therefore the instances of the abstract\ndomain get two integer fields codeones/code and codeunknowns/code, where each pair of\ncorresponding bits encodes the knowledge about the corresponding bit of the\ninteger variable in the program./p\npWe can start implementing a Python class that works like this:/p\ndiv class=\"code\"pre class=\"code literal-block\"span class=\"kn\"from/span span class=\"nn\"dataclasses/span span class=\"kn\"import/span span class=\"n\"dataclass/span\n\nspan class=\"nd\"@dataclass/spanspan class=\"p\"(/spanspan class=\"n\"eq/spanspan class=\"o\"=/spanspan class=\"kc\"False/spanspan class=\"p\")/span\nspan class=\"k\"class/span span class=\"nc\"KnownBits/spanspan class=\"p\":/span\n    span class=\"n\"ones/span span class=\"p\":/span span class=\"nb\"int/span\n    span class=\"n\"unknowns/span span class=\"p\":/span span class=\"nb\"int/span\n\n    span class=\"k\"def/span span class=\"nf\"__post_init__/spanspan class=\"p\"(/spanspan class=\"bp\"self/spanspan class=\"p\"):/span\n        span class=\"k\"if/span span class=\"nb\"isinstance/spanspan class=\"p\"(/spanspan class=\"bp\"self/spanspan class=\"o\"./spanspan class=\"n\"ones/spanspan class=\"p\",/span span class=\"nb\"int/spanspan class=\"p\"):/span\n            span class=\"k\"assert/span span class=\"bp\"self/spanspan class=\"o\"./spanspan class=\"n\"is_well_formed/spanspan class=\"p\"()/span\n\n    span class=\"k\"def/span span class=\"nf\"is_well_formed/spanspan class=\"p\"(/spanspan class=\"bp\"self/spanspan class=\"p\"):/span\n        span class=\"c1\"# a bit cannot be both 1 and unknown/span\n        span class=\"k\"return/span span class=\"bp\"self/spanspan class=\"o\"./spanspan class=\"n\"ones/span span class=\"o\"amp;/span span class=\"bp\"self/spanspan class=\"o\"./spanspan class=\"n\"unknowns/span span class=\"o\"==/span span class=\"mi\"0/span\n\n    span class=\"nd\"@staticmethod/span\n    span class=\"k\"def/span span class=\"nf\"from_constant/spanspan class=\"p\"(/spanspan class=\"n\"const/span span class=\"p\":/span span class=\"nb\"int/spanspan class=\"p\"):/span\nspan class=\"w\"        /spanspan class=\"sd\"\"\"\" Construct a KnownBits corresponding to a constant, where all bits/span\nspan class=\"sd\"        are known.\"\"\"/span\n        span class=\"k\"return/span span class=\"n\"KnownBits/spanspan class=\"p\"(/spanspan class=\"n\"const/spanspan class=\"p\",/span span class=\"mi\"0/spanspan class=\"p\")/span\n\n    span class=\"k\"def/span span class=\"nf\"is_constant/spanspan class=\"p\"(/spanspan class=\"bp\"self/spanspan class=\"p\"):/span\nspan class=\"w\"        /spanspan class=\"sd\"\"\"\" Check if the KnownBits instance represents a constant. \"\"\"/span\n        span class=\"c1\"# it's a constant if there are no unknowns/span\n        span class=\"k\"return/span span class=\"bp\"self/spanspan class=\"o\"./spanspan class=\"n\"unknowns/span span class=\"o\"==/span span class=\"mi\"0/span\n/pre/div\n\npWe can also add some convenience properties. Sometimes it is easier to work\nwith an integer where all the emknown/em bits are set, or one where the positions\nof all the known zeros have a set bit:/p\ndiv class=\"code\"pre class=\"code literal-block\"span class=\"k\"class/span span class=\"nc\"KnownBits/spanspan class=\"p\":/span\n    span class=\"o\".../span\n\n    span class=\"nd\"@property/span\n    span class=\"k\"def/span span class=\"nf\"knowns/spanspan class=\"p\"(/spanspan class=\"bp\"self/spanspan class=\"p\"):/span\nspan class=\"w\"        /spanspan class=\"sd\"\"\"\" return an integer where the known bits are set. \"\"\"/span\n        span class=\"c1\"# the knowns are just the unknowns, inverted/span\n        span class=\"k\"return/span span class=\"o\"~/spanspan class=\"bp\"self/spanspan class=\"o\"./spanspan class=\"n\"unknowns/span\n\n    span class=\"nd\"@property/span\n    span class=\"k\"def/span span class=\"nf\"zeros/spanspan class=\"p\"(/spanspan class=\"bp\"self/spanspan class=\"p\"):/span\nspan class=\"w\"        /spanspan class=\"sd\"\"\"\" return an integer where the places that are known zeros have a bit/span\nspan class=\"sd\"        set. \"\"\"/span\n        span class=\"c1\"# it's a 0 if it is known, but not 1/span\n        span class=\"k\"return/span span class=\"bp\"self/spanspan class=\"o\"./spanspan class=\"n\"knowns/span span class=\"o\"amp;/span span class=\"o\"~/spanspan class=\"bp\"self/spanspan class=\"o\"./spanspan class=\"n\"ones/span\n/pre/div\n\npAlso, for debugging and for writing tests we want a way to print the known bits\nin a human-readable form, and also to have a way to construct a codeKnownBits/code\ninstance from a string. It's not important to understand the details of\ncode__str__/code or codefrom_str/code for the rest of the post, so I'm putting them into a fold:/p\ndetails\nsummarycodeKnownBits/code from and to string conversions/summary\n\n\ndiv class=\"code\"pre class=\"code literal-block\"span class=\"k\"class/span span class=\"nc\"KnownBits/spanspan class=\"p\":/span\n    span class=\"o\".../span\n\n    span class=\"k\"def/span span class=\"fm\"__repr__/spanspan class=\"p\"(/spanspan class=\"bp\"self/spanspan class=\"p\"):/span\n        span class=\"k\"if/span span class=\"bp\"self/spanspan class=\"o\"./spanspan class=\"n\"is_constant/spanspan class=\"p\"():/span\n            span class=\"k\"return/span span class=\"sa\"f/spanspan class=\"s2\"\"KnownBits.from_constant(/spanspan class=\"si\"{/spanspan class=\"bp\"self/spanspan class=\"o\"./spanspan class=\"n\"ones/spanspan class=\"si\"}/spanspan class=\"s2\")\"/span\n        span class=\"k\"return/span span class=\"sa\"f/spanspan class=\"s2\"\"KnownBits(/spanspan class=\"si\"{/spanspan class=\"bp\"self/spanspan class=\"o\"./spanspan class=\"n\"ones/spanspan class=\"si\"}/spanspan class=\"s2\", /spanspan class=\"si\"{/spanspan class=\"bp\"self/spanspan class=\"o\"./spanspan class=\"n\"unknowns/spanspan class=\"si\"}/spanspan class=\"s2\")\"/span\n\n    span class=\"k\"def/span span class=\"fm\"__str__/spanspan class=\"p\"(/spanspan class=\"bp\"self/spanspan class=\"p\"):/span\n        span class=\"n\"res/span span class=\"o\"=/span span class=\"p\"[]/span\n        span class=\"n\"ones/spanspan class=\"p\",/span span class=\"n\"unknowns/span span class=\"o\"=/span span class=\"bp\"self/spanspan class=\"o\"./spanspan class=\"n\"ones/spanspan class=\"p\",/span span class=\"bp\"self/spanspan class=\"o\"./spanspan class=\"n\"unknowns/span\n        span class=\"c1\"# construct the string representation right to left/span\n        span class=\"k\"while/span span class=\"mi\"1/spanspan class=\"p\":/span\n            span class=\"k\"if/span span class=\"ow\"not/span span class=\"n\"ones/span span class=\"ow\"and/span span class=\"ow\"not/span span class=\"n\"unknowns/spanspan class=\"p\":/span\n                span class=\"k\"break/span span class=\"c1\"# we leave off the leading known 0s/span\n            span class=\"k\"if/span span class=\"n\"ones/span span class=\"o\"==/span span class=\"o\"-/spanspan class=\"mi\"1/span span class=\"ow\"and/span span class=\"ow\"not/span span class=\"n\"unknowns/spanspan class=\"p\":/span\n                span class=\"c1\"# -1 has all bits set in two's complement, so the leading/span\n                span class=\"c1\"# bits are all 1/span\n                span class=\"n\"res/spanspan class=\"o\"./spanspan class=\"n\"append/spanspan class=\"p\"(/spanspan class=\"s1\"'1'/spanspan class=\"p\")/span\n                span class=\"n\"res/spanspan class=\"o\"./spanspan class=\"n\"append/spanspan class=\"p\"(/spanspan class=\"s2\"\"...\"/spanspan class=\"p\")/span\n                span class=\"k\"break/span\n            span class=\"k\"if/span span class=\"n\"unknowns/span span class=\"o\"==/span span class=\"o\"-/spanspan class=\"mi\"1/spanspan class=\"p\":/span\n                span class=\"c1\"# -1 has all bits set in two's complement, so the leading bits/span\n                span class=\"c1\"# are all ?/span\n                span class=\"k\"assert/span span class=\"ow\"not/span span class=\"n\"ones/span\n                span class=\"n\"res/spanspan class=\"o\"./spanspan class=\"n\"append/spanspan class=\"p\"(/spanspan class=\"s2\"\"?\"/spanspan class=\"p\")/span\n                span class=\"n\"res/spanspan class=\"o\"./spanspan class=\"n\"append/spanspan class=\"p\"(/spanspan class=\"s2\"\"...\"/spanspan class=\"p\")/span\n                span class=\"k\"break/span\n            span class=\"k\"if/span span class=\"n\"unknowns/span span class=\"o\"amp;/span span class=\"mi\"1/spanspan class=\"p\":/span\n                span class=\"n\"res/spanspan class=\"o\"./spanspan class=\"n\"append/spanspan class=\"p\"(/spanspan class=\"s1\"'?'/spanspan class=\"p\")/span\n            span class=\"k\"elif/span span class=\"n\"ones/span span class=\"o\"amp;/span span class=\"mi\"1/spanspan class=\"p\":/span\n                span class=\"n\"res/spanspan class=\"o\"./spanspan class=\"n\"append/spanspan class=\"p\"(/spanspan class=\"s1\"'1'/spanspan class=\"p\")/span\n            span class=\"k\"else/spanspan class=\"p\":/span\n                span class=\"n\"res/spanspan class=\"o\"./spanspan class=\"n\"append/spanspan class=\"p\"(/spanspan class=\"s1\"'0'/spanspan class=\"p\")/span\n            span class=\"n\"ones/span span class=\"o\"gt;gt;=/span span class=\"mi\"1/span\n            span class=\"n\"unknowns/span span class=\"o\"gt;gt;=/span span class=\"mi\"1/span\n        span class=\"k\"if/span span class=\"ow\"not/span span class=\"n\"res/spanspan class=\"p\":/span\n            span class=\"n\"res/spanspan class=\"o\"./spanspan class=\"n\"append/spanspan class=\"p\"(/spanspan class=\"s1\"'0'/spanspan class=\"p\")/span\n        span class=\"n\"res/spanspan class=\"o\"./spanspan class=\"n\"reverse/spanspan class=\"p\"()/span\n        span class=\"k\"return/span span class=\"s2\"\"\"/spanspan class=\"o\"./spanspan class=\"n\"join/spanspan class=\"p\"(/spanspan class=\"n\"res/spanspan class=\"p\")/span\n\n    span class=\"nd\"@staticmethod/span\n    span class=\"k\"def/span span class=\"nf\"from_str/spanspan class=\"p\"(/spanspan class=\"n\"s/spanspan class=\"p\"):/span\nspan class=\"w\"        /spanspan class=\"sd\"\"\"\" Construct a KnownBits instance that from a string. String can start/span\nspan class=\"sd\"        with ...1 to mean that all higher bits are 1, or ...? to mean that all/span\nspan class=\"sd\"        higher bits are unknown. Otherwise it is assumed that the higher bits/span\nspan class=\"sd\"        are all 0. \"\"\"/span\n        span class=\"n\"ones/spanspan class=\"p\",/span span class=\"n\"unknowns/span span class=\"o\"=/span span class=\"mi\"0/spanspan class=\"p\",/span span class=\"mi\"0/span\n        span class=\"n\"startindex/span span class=\"o\"=/span span class=\"mi\"0/span\n        span class=\"k\"if/span span class=\"n\"s/spanspan class=\"o\"./spanspan class=\"n\"startswith/spanspan class=\"p\"(/spanspan class=\"s2\"\"...?\"/spanspan class=\"p\"):/span\n            span class=\"n\"unknowns/span span class=\"o\"=/span span class=\"o\"-/spanspan class=\"mi\"1/span\n            span class=\"n\"startindex/span span class=\"o\"=/span span class=\"mi\"4/span\n        span class=\"k\"elif/span span class=\"n\"s/spanspan class=\"o\"./spanspan class=\"n\"startswith/spanspan class=\"p\"(/spanspan class=\"s2\"\"...1\"/spanspan class=\"p\"):/span\n            span class=\"n\"ones/span span class=\"o\"=/span span class=\"o\"-/spanspan class=\"mi\"1/span\n            span class=\"n\"startindex/span span class=\"o\"=/span span class=\"mi\"4/span\n        span class=\"k\"for/span span class=\"n\"index/span span class=\"ow\"in/span span class=\"nb\"range/spanspan class=\"p\"(/spanspan class=\"n\"startindex/spanspan class=\"p\",/span span class=\"nb\"len/spanspan class=\"p\"(/spanspan class=\"n\"s/spanspan class=\"p\")):/span\n            span class=\"n\"ones/span span class=\"o\"lt;lt;=/span span class=\"mi\"1/span\n            span class=\"n\"unknowns/span span class=\"o\"lt;lt;=/span span class=\"mi\"1/span\n            span class=\"n\"c/span span class=\"o\"=/span span class=\"n\"s/spanspan class=\"p\"[/spanspan class=\"n\"index/spanspan class=\"p\"]/span\n            span class=\"k\"if/span span class=\"n\"c/span span class=\"o\"==/span span class=\"s1\"'1'/spanspan class=\"p\":/span\n                span class=\"n\"ones/span span class=\"o\"|=/span span class=\"mi\"1/span\n            span class=\"k\"elif/span span class=\"n\"c/span span class=\"o\"==/span span class=\"s1\"'?'/spanspan class=\"p\":/span\n                span class=\"n\"unknowns/span span class=\"o\"|=/span span class=\"mi\"1/span\n        span class=\"k\"return/span span class=\"n\"KnownBits/spanspan class=\"p\"(/spanspan class=\"n\"ones/spanspan class=\"p\",/span span class=\"n\"unknowns/spanspan class=\"p\")/span\n\n    span class=\"nd\"@staticmethod/span\n    span class=\"k\"def/span span class=\"nf\"all_unknown/spanspan class=\"p\"():/span\nspan class=\"w\"        /spanspan class=\"sd\"\"\"\" convenience constructor for the \"all bits unknown\" abstract value/span\nspan class=\"sd\"        \"\"\"/span\n        span class=\"k\"return/span span class=\"n\"KnownBits/spanspan class=\"o\"./spanspan class=\"n\"from_str/spanspan class=\"p\"(/spanspan class=\"s2\"\"...?\"/spanspan class=\"p\")/span\n/pre/div\n\n\n\n/details\n\npAnd here's a a href=\"https://pytest.org\"pytest/a-style unit test for codestr/code:/p\ndiv class=\"code\"pre class=\"code literal-block\"span class=\"k\"def/span span class=\"nf\"test_str/spanspan class=\"p\"():/span\n    span class=\"k\"assert/span span class=\"nb\"str/spanspan class=\"p\"(/spanspan class=\"n\"KnownBits/spanspan class=\"o\"./spanspan class=\"n\"from_constant/spanspan class=\"p\"(/spanspan class=\"mi\"0/spanspan class=\"p\"))/span span class=\"o\"==/span span class=\"s1\"'0'/span\n    span class=\"k\"assert/span span class=\"nb\"str/spanspan class=\"p\"(/spanspan class=\"n\"KnownBits/spanspan class=\"o\"./spanspan class=\"n\"from_constant/spanspan class=\"p\"(/spanspan class=\"mi\"5/spanspan class=\"p\"))/span span class=\"o\"==/span span class=\"s1\"'101'/span\n    span class=\"k\"assert/span span class=\"nb\"str/spanspan class=\"p\"(/spanspan class=\"n\"KnownBits/spanspan class=\"p\"(/spanspan class=\"mi\"5/spanspan class=\"p\",/span span class=\"mb\"0b10/spanspan class=\"p\"))/span span class=\"o\"==/span span class=\"s1\"'1?1'/span\n    span class=\"k\"assert/span span class=\"nb\"str/spanspan class=\"p\"(/spanspan class=\"n\"KnownBits/spanspan class=\"p\"(/spanspan class=\"o\"~/spanspan class=\"mb\"0b1111/spanspan class=\"p\",/span span class=\"mb\"0b10/spanspan class=\"p\"))/span span class=\"o\"==/span span class=\"s1\"'...100?0'/span\n    span class=\"k\"assert/span span class=\"nb\"str/spanspan class=\"p\"(/spanspan class=\"n\"KnownBits/spanspan class=\"p\"(/spanspan class=\"mi\"1/spanspan class=\"p\",/span span class=\"o\"~/spanspan class=\"mb\"0b1/spanspan class=\"p\"))/span span class=\"o\"==/span span class=\"s1\"'...?1'/span\n/pre/div\n\npAn instance of codeKnownBits/code represents a set of integers, namely those that match\nthe known bits stored in the instance. We can write a method codecontains/code that\ntakes a concrete codeint/code value and returns codeTrue/code if the value matches the\npattern of the known bits:/p\ndiv class=\"code\"pre class=\"code literal-block\"span class=\"k\"class/span span class=\"nc\"KnownBits/spanspan class=\"p\":/span\n    span class=\"o\".../span\n\n    span class=\"k\"def/span span class=\"nf\"contains/spanspan class=\"p\"(/spanspan class=\"bp\"self/spanspan class=\"p\",/span span class=\"n\"value/span span class=\"p\":/span span class=\"nb\"int/spanspan class=\"p\"):/span\nspan class=\"w\"        /spanspan class=\"sd\"\"\"\" Check whether the KnownBits instance contains the concrete integer/span\nspan class=\"sd\"        `value`. \"\"\"/span\n        span class=\"c1\"# check whether value matches the bit pattern. in the places where we/span\n        span class=\"c1\"# know the bits, the value must agree with ones./span\n        span class=\"k\"return/span span class=\"n\"value/span span class=\"o\"amp;/span span class=\"bp\"self/spanspan class=\"o\"./spanspan class=\"n\"knowns/span span class=\"o\"==/span span class=\"bp\"self/spanspan class=\"o\"./spanspan class=\"n\"ones/span\n/pre/div\n\npand a test:/p\ndiv class=\"code\"pre class=\"code literal-block\"span class=\"k\"def/span span class=\"nf\"test_contains/spanspan class=\"p\"():/span\n    span class=\"n\"k1/span span class=\"o\"=/span span class=\"n\"KnownBits/spanspan class=\"o\"./spanspan class=\"n\"from_str/spanspan class=\"p\"(/spanspan class=\"s1\"'1?1'/spanspan class=\"p\")/span\n    span class=\"k\"assert/span span class=\"n\"k1/spanspan class=\"o\"./spanspan class=\"n\"contains/spanspan class=\"p\"(/spanspan class=\"mb\"0b111/spanspan class=\"p\")/span\n    span class=\"k\"assert/span span class=\"n\"k1/spanspan class=\"o\"./spanspan class=\"n\"contains/spanspan class=\"p\"(/spanspan class=\"mb\"0b101/spanspan class=\"p\")/span\n    span class=\"k\"assert/span span class=\"ow\"not/span span class=\"n\"k1/spanspan class=\"o\"./spanspan class=\"n\"contains/spanspan class=\"p\"(/spanspan class=\"mb\"0b110/spanspan class=\"p\")/span\n    span class=\"k\"assert/span span class=\"ow\"not/span span class=\"n\"k1/spanspan class=\"o\"./spanspan class=\"n\"contains/spanspan class=\"p\"(/spanspan class=\"mb\"0b011/spanspan class=\"p\")/span\n\n    span class=\"n\"k2/span span class=\"o\"=/span span class=\"n\"KnownBits/spanspan class=\"o\"./spanspan class=\"n\"from_str/spanspan class=\"p\"(/spanspan class=\"s1\"'...?1'/spanspan class=\"p\")/span span class=\"c1\"# all odd numbers/span\n    span class=\"k\"for/span span class=\"n\"i/span span class=\"ow\"in/span span class=\"nb\"range/spanspan class=\"p\"(/spanspan class=\"o\"-/spanspan class=\"mi\"101/spanspan class=\"p\",/span span class=\"mi\"100/spanspan class=\"p\"):/span\n        span class=\"k\"assert/span span class=\"n\"k2/spanspan class=\"o\"./spanspan class=\"n\"contains/spanspan class=\"p\"(/spanspan class=\"n\"i/spanspan class=\"p\")/span span class=\"o\"==/span span class=\"p\"(/spanspan class=\"n\"i/span span class=\"o\"amp;/span span class=\"mi\"1/spanspan class=\"p\")/span\n/pre/div\n\nh3 id=\"transfer-functions\"Transfer Functions/h3\npNow that we have implemented the basics of the codeKnownBits/code class, we need to\nstart implementing the transfer functions. They are for computing what we know\nabout the emresults/em of an operation, given the knowledge we have about the bits\nof the arguments./p\npWe'll start with a simple unary operation, codeinvert(x)/code (which is code~x/code in Python\nand C syntax), which flips all the bits of at integer. If we know some bits of\nthe arguments, we can compute the corresponding bits of the result. The unknown\nbits remain unknown./p\npHere's the code:/p\ndiv class=\"code\"pre class=\"code literal-block\"span class=\"k\"class/span span class=\"nc\"KnownBits/spanspan class=\"p\":/span\n    span class=\"o\".../span\n\n    span class=\"k\"def/span span class=\"nf\"abstract_invert/spanspan class=\"p\"(/spanspan class=\"bp\"self/spanspan class=\"p\"):/span\n        span class=\"c1\"# self.zeros has bits set where the known 0s are in self/span\n        span class=\"k\"return/span span class=\"n\"KnownBits/spanspan class=\"p\"(/spanspan class=\"bp\"self/spanspan class=\"o\"./spanspan class=\"n\"zeros/spanspan class=\"p\",/span span class=\"bp\"self/spanspan class=\"o\"./spanspan class=\"n\"unknowns/spanspan class=\"p\")/span\n/pre/div\n\npAnd a unit-test:/p\ndiv class=\"code\"pre class=\"code literal-block\"span class=\"k\"def/span span class=\"nf\"test_invert/spanspan class=\"p\"():/span\n    span class=\"n\"k1/span span class=\"o\"=/span span class=\"n\"KnownBits/spanspan class=\"o\"./spanspan class=\"n\"from_str/spanspan class=\"p\"(/spanspan class=\"s1\"'01?01?01?'/spanspan class=\"p\")/span\n    span class=\"n\"k2/span span class=\"o\"=/span span class=\"n\"k1/spanspan class=\"o\"./spanspan class=\"n\"abstract_invert/spanspan class=\"p\"()/span\n    span class=\"k\"assert/span span class=\"nb\"str/spanspan class=\"p\"(/spanspan class=\"n\"k2/spanspan class=\"p\")/span span class=\"o\"==/span span class=\"s1\"'...10?10?10?'/span\n\n    span class=\"n\"k1/span span class=\"o\"=/span span class=\"n\"KnownBits/spanspan class=\"o\"./spanspan class=\"n\"from_str/spanspan class=\"p\"(/spanspan class=\"s1\"'...?'/spanspan class=\"p\")/span\n    span class=\"n\"k2/span span class=\"o\"=/span span class=\"n\"k1/spanspan class=\"o\"./spanspan class=\"n\"abstract_invert/spanspan class=\"p\"()/span\n    span class=\"k\"assert/span span class=\"nb\"str/spanspan class=\"p\"(/spanspan class=\"n\"k2/spanspan class=\"p\")/span span class=\"o\"==/span span class=\"s1\"'...?'/span\n/pre/div\n\npBefore we continue with further transfer functions, we'll think about\ncorrectness of the transfer functions and build up some test infrastructure. To\ntest transfer functions, it's quite important to move being simple example-style\nunit tests. The state-space for more complicated binary transfer functions is\nextremely large and it's too easy to do something wrong in a corner case.\nTherefore we'll look at property-based-test for codeKnownBits/code next./p\nh3 id=\"property-based-tests-with-hypothesis\"Property-based Tests with Hypothesis/h3\npWe want to do property-based tests of codeKnownBits/code, to try\nmake it less likely that we'll get a corner-case in the implementation wrong.\nWe'll use a href=\"https://hypothesis.readthedocs.io/en/latest/\"Hypothesis/a for that./p\npI can't give a decent introduction to Hypothesis here, but want to give a few\nhints about the API. Hypothesis is a way to run unit tests with randomly\ngenerated input. It provides emstrategies/em to describe the data that the test\nfunctions expects. Hypothesis provides primitive strategies (for things like\nintegers, strings, floats, etc) and ways to build composite strategies out of\nthe primitive ones./p\npTo be able to write the tests, we need to generate random codeKnownBits/code instances,\nand we also want an codeint/code instance that is a member of the codeKnownBits/code instance.\nWe generate tuples of code(KnownBits, int)/code together, to ensure this property.\nWe'll ask Hypothesis to generate us a random concrete codeint/code as the concrete\nvalue, and then we'll also generate a second random codeint/code to use as the\ncodeunknown/code masks (i.e. which bits of the concrete int we don't know in the\ncodeKnownBits/code instance). Here's a function that takes two such ints and builds the\ntuple:/p\ndiv class=\"code\"pre class=\"code literal-block\"span class=\"k\"def/span span class=\"nf\"build_knownbits_and_contained_number/spanspan class=\"p\"(/spanspan class=\"n\"concrete_value/span span class=\"p\":/span span class=\"nb\"int/spanspan class=\"p\",/span span class=\"n\"unknowns/span span class=\"p\":/span span class=\"nb\"int/spanspan class=\"p\"):/span\n    span class=\"c1\"# to construct a valid KnownBits instance, we need to mask off the unknown/span\n    span class=\"c1\"# bits/span\n    span class=\"n\"ones/span span class=\"o\"=/span span class=\"n\"concrete_value/span span class=\"o\"amp;/span span class=\"o\"~/spanspan class=\"n\"unknowns/span\n    span class=\"k\"return/span span class=\"n\"KnownBits/spanspan class=\"p\"(/spanspan class=\"n\"ones/spanspan class=\"p\",/span span class=\"n\"unknowns/spanspan class=\"p\"),/span span class=\"n\"concrete_value/span\n/pre/div\n\npWe can turn this function into a hypothesis strategy to generate input data\nusing the codestrategies.builds/code function:/p\ndiv class=\"code\"pre class=\"code literal-block\"span class=\"kn\"from/span span class=\"nn\"hypothesis/span span class=\"kn\"import/span span class=\"n\"strategies/spanspan class=\"p\",/span span class=\"n\"given/spanspan class=\"p\",/span span class=\"n\"settings/span\n\nspan class=\"n\"ints/span span class=\"o\"=/span span class=\"n\"strategies/spanspan class=\"o\"./spanspan class=\"n\"integers/spanspan class=\"p\"()/span\n\nspan class=\"n\"random_knownbits_and_contained_number/span span class=\"o\"=/span span class=\"n\"strategies/spanspan class=\"o\"./spanspan class=\"n\"builds/spanspan class=\"p\"(/span\n    span class=\"n\"build_knownbits_and_contained_number/spanspan class=\"p\",/span\n    span class=\"n\"ints/spanspan class=\"p\",/span span class=\"n\"ints/span\nspan class=\"p\")/span\n/pre/div\n\npOne important special case of codeKnownBits/code are the constants, which contain only\na single concrete value. We'll also generate some of those specifically, and\nthen combine the coderandom_knownbits_and_contained_number/code strategy with it:/p\ndiv class=\"code\"pre class=\"code literal-block\"span class=\"n\"constant_knownbits/span span class=\"o\"=/span span class=\"n\"strategies/spanspan class=\"o\"./spanspan class=\"n\"builds/spanspan class=\"p\"(/span\n    span class=\"k\"lambda/span span class=\"n\"value/spanspan class=\"p\":/span span class=\"p\"(/spanspan class=\"n\"KnownBits/spanspan class=\"o\"./spanspan class=\"n\"from_constant/spanspan class=\"p\"(/spanspan class=\"n\"value/spanspan class=\"p\"),/span span class=\"n\"value/spanspan class=\"p\"),/span\n    span class=\"n\"ints/span\nspan class=\"p\")/span\n\nspan class=\"n\"knownbits_and_contained_number/span span class=\"o\"=/span span class=\"n\"constant_knownbits/span span class=\"o\"|/span span class=\"n\"random_knownbits_and_contained_number/span\n/pre/div\n\npNow we can write the first property-based tests, for the codeKnownBits.contains/code\nmethod:/p\ndiv class=\"code\"pre class=\"code literal-block\"span class=\"nd\"@given/spanspan class=\"p\"(/spanspan class=\"n\"knownbits_and_contained_number/spanspan class=\"p\")/span\nspan class=\"k\"def/span span class=\"nf\"test_contains/spanspan class=\"p\"(/spanspan class=\"n\"t/spanspan class=\"p\"):/span\n    span class=\"n\"k/spanspan class=\"p\",/span span class=\"n\"n/span span class=\"o\"=/span span class=\"n\"t/span\n    span class=\"k\"assert/span span class=\"n\"k/spanspan class=\"o\"./spanspan class=\"n\"contains/spanspan class=\"p\"(/spanspan class=\"n\"t/spanspan class=\"p\")/span\n/pre/div\n\npThe code@given/code decorator is used to tell Hypothesis which strategy to use to\ngenerate random data for the test function. Hypothesis will run the test with a\nnumber of random examples (100 by default). If it finds an error, it will try to\nminimize the example needed that demonstrates the problem, to try to make it\neasier to understand what is going wrong. It also saves all failing cases into\nan example database and tries them again on subsequent runs./p\npThis test is as much a check for whether we got the strategies right as it is\nfor the logic in codeKnownBits.contains/code. Here's an example output of random\nconcrete and abstract values that we are getting here:/p\ndiv class=\"code\"pre class=\"code literal-block\"span class=\"mf\"110000011001101/spanspan class=\"w\" /spanspan class=\"mf\".../spanspan class=\"err\"?/spanspan class=\"mf\"0/spanspan class=\"err\"???/spanspan class=\"mf\"1/span\nspan class=\"mf\"...1011011/spanspan class=\"w\" /spanspan class=\"mf\"...1011011/span\nspan class=\"mf\"...1001101110101000010010011111011/spanspan class=\"w\" /spanspan class=\"mf\"...1001101110101000010010011111011/span\nspan class=\"mf\"...1001101110101000010010011111011/spanspan class=\"w\" /spanspan class=\"mf\"...100110111010100001/spanspan class=\"err\"?/spanspan class=\"mf\"010/spanspan class=\"err\"?/spanspan class=\"mf\"1/spanspan class=\"err\"??/spanspan class=\"mf\"1/spanspan class=\"err\"??/spanspan class=\"mf\"11/span\nspan class=\"mf\"1000001101111101001011010011111101000011000111011001011111101/spanspan class=\"w\" /spanspan class=\"mf\"1000001101111101001011010011111101000011000111011001011111101/span\nspan class=\"mf\"1000001101111101001011010011111101000011000111011001011111101/spanspan class=\"w\" /spanspan class=\"mf\"1000001101111101001011010011111101000011000111/spanspan class=\"err\"????/spanspan class=\"mf\"01/spanspan class=\"err\"?/spanspan class=\"mf\"11/spanspan class=\"err\"?????/spanspan class=\"mf\"1/span\nspan class=\"mf\"1111100000010/spanspan class=\"w\" /spanspan class=\"mf\"1111100000010/span\nspan class=\"mf\"1111100000010/spanspan class=\"w\" /spanspan class=\"mf\".../spanspan class=\"err\"?/spanspan class=\"mf\"11111/spanspan class=\"err\"?/spanspan class=\"mf\"00000/spanspan class=\"err\"??/span\nspan class=\"mf\"110110/spanspan class=\"w\" /spanspan class=\"mf\"110110/span\nspan class=\"mf\"110110/spanspan class=\"w\" /spanspan class=\"mf\".../spanspan class=\"err\"?/spanspan class=\"mf\"00/spanspan class=\"err\"?/spanspan class=\"mf\"00/spanspan class=\"err\"????/spanspan class=\"mf\"11/spanspan class=\"err\"??/spanspan class=\"mf\"10/span\nspan class=\"mf\"110110/spanspan class=\"w\" /spanspan class=\"err\"??/spanspan class=\"mf\"0/spanspan class=\"err\"??/spanspan class=\"mf\"0/span\nspan class=\"mf\"...100010111011111/spanspan class=\"w\" /spanspan class=\"mf\".../spanspan class=\"err\"?/spanspan class=\"mf\"100/spanspan class=\"err\"?/spanspan class=\"mf\"10111/spanspan class=\"err\"??/spanspan class=\"mf\"111/spanspan class=\"err\"?/span\nspan class=\"mf\"...1000100000110001/spanspan class=\"w\" /spanspan class=\"mf\".../spanspan class=\"err\"?/spanspan class=\"mf\"000/spanspan class=\"err\"?/spanspan class=\"mf\"00000/spanspan class=\"err\"??/spanspan class=\"mf\"000/spanspan class=\"err\"?/span\nspan class=\"mf\"110000001110/spanspan class=\"w\" /spanspan class=\"mf\".../spanspan class=\"err\"?/spanspan class=\"mf\"0/spanspan class=\"err\"?/spanspan class=\"mf\"0/spanspan class=\"err\"??/spanspan class=\"mf\"000/spanspan class=\"err\"?/spanspan class=\"mf\"00/spanspan class=\"err\"?/spanspan class=\"mf\"0/spanspan class=\"err\"?/spanspan class=\"mf\"0000000/spanspan class=\"err\"?/spanspan class=\"mf\"00/spanspan class=\"err\"???/spanspan class=\"mf\"0000/spanspan class=\"err\"?????/spanspan class=\"mf\"00/spanspan class=\"err\"???/spanspan class=\"mf\"000/spanspan class=\"err\"?/spanspan class=\"mf\"0/spanspan class=\"err\"?/spanspan class=\"mf\"00/spanspan class=\"err\"?/spanspan class=\"mf\"01/spanspan class=\"err\"?/spanspan class=\"mf\"000/spanspan class=\"err\"?/spanspan class=\"mf\"0/spanspan class=\"err\"??/spanspan class=\"mf\"1/spanspan class=\"err\"??/span\nspan class=\"mf\"110000001110/spanspan class=\"w\" /spanspan class=\"err\"??/spanspan class=\"mf\"000000/spanspan class=\"err\"???/spanspan class=\"mf\"0/span\nspan class=\"mf\"1011011010000001110101001111000010001001011101010010010001000000010101010010001101110101111111010101010010101100110000011110000/spanspan class=\"w\" /spanspan class=\"mf\"1011011010000001110101001111000010001001011101010010010001000000010101010010001101110101111111010101010010101100110000011110000/span\nspan class=\"mf\"...1011010010010100/spanspan class=\"w\" /spanspan class=\"mf\"...1011010010010100/span\nspan class=\"mf\"...1011111110110011/spanspan class=\"w\" /spanspan class=\"mf\"...1011111110110011/span\nspan class=\"mf\"101000011110110/spanspan class=\"w\" /spanspan class=\"mf\"101000011/spanspan class=\"err\"?/spanspan class=\"mf\"10/spanspan class=\"err\"?/spanspan class=\"mf\"1/spanspan class=\"err\"?/span\nspan class=\"mf\"100101/spanspan class=\"w\" /spanspan class=\"err\"?/spanspan class=\"mf\"00/spanspan class=\"err\"?/spanspan class=\"mf\"0/spanspan class=\"err\"?/span\n/pre/div\n\npThat looks suitably random, but we might want to bias our random numbers a\nlittle bit towards common error values like small constants, powers of two, etc.\nLike this:/p\ndiv class=\"code\"pre class=\"code literal-block\"span class=\"n\"INTEGER_WIDTH/span span class=\"o\"=/span span class=\"mi\"64/span\nspan class=\"c1\"# some small integers/span\nspan class=\"n\"ints_special/span span class=\"o\"=/span span class=\"nb\"set/spanspan class=\"p\"(/spanspan class=\"nb\"range/spanspan class=\"p\"(/spanspan class=\"mi\"100/spanspan class=\"p\"))/span\nspan class=\"c1\"# powers of two/span\nspan class=\"n\"ints_special/span span class=\"o\"=/span span class=\"n\"ints_special/spanspan class=\"o\"./spanspan class=\"n\"union/spanspan class=\"p\"(/spanspan class=\"mi\"1/span span class=\"o\"lt;lt;/span span class=\"n\"i/span span class=\"k\"for/span span class=\"n\"i/span span class=\"ow\"in/span span class=\"nb\"range/spanspan class=\"p\"(/spanspan class=\"n\"INTEGER_WIDTH/span span class=\"o\"-/span span class=\"mi\"2/spanspan class=\"p\"))/span\nspan class=\"c1\"# powers of two - 1/span\nspan class=\"n\"ints_special/span span class=\"o\"=/span span class=\"n\"ints_special/spanspan class=\"o\"./spanspan class=\"n\"union/spanspan class=\"p\"((/spanspan class=\"mi\"1/span span class=\"o\"lt;lt;/span span class=\"n\"i/spanspan class=\"p\")/span span class=\"o\"-/span span class=\"mi\"1/span span class=\"k\"for/span span class=\"n\"i/span span class=\"ow\"in/span span class=\"nb\"range/spanspan class=\"p\"(/spanspan class=\"n\"INTEGER_WIDTH/span span class=\"o\"-/span span class=\"mi\"2/spanspan class=\"p\"))/span\nspan class=\"c1\"# negative versions of what we have so far/span\nspan class=\"n\"ints_special/span span class=\"o\"=/span span class=\"n\"ints_special/spanspan class=\"o\"./spanspan class=\"n\"union/spanspan class=\"p\"(/spanspan class=\"o\"-/spanspan class=\"n\"x/span span class=\"k\"for/span span class=\"n\"x/span span class=\"ow\"in/span span class=\"n\"ints_special/spanspan class=\"p\")/span\nspan class=\"c1\"# bit-flipped versions of what we have so far/span\nspan class=\"n\"ints_special/span span class=\"o\"=/span span class=\"n\"ints_special/spanspan class=\"o\"./spanspan class=\"n\"union/spanspan class=\"p\"(/spanspan class=\"o\"~/spanspan class=\"n\"x/span span class=\"k\"for/span span class=\"n\"x/span span class=\"ow\"in/span span class=\"n\"ints_special/spanspan class=\"p\")/span\nspan class=\"n\"ints_special/span span class=\"o\"=/span span class=\"nb\"list/spanspan class=\"p\"(/spanspan class=\"n\"ints_special/spanspan class=\"p\")/span\nspan class=\"c1\"# sort them (because hypothesis simplifies towards earlier elements in the list)/span\nspan class=\"n\"ints_special/spanspan class=\"o\"./spanspan class=\"n\"sort/spanspan class=\"p\"(/spanspan class=\"n\"key/spanspan class=\"o\"=/spanspan class=\"k\"lambda/span span class=\"n\"element/spanspan class=\"p\":/span span class=\"p\"(/spanspan class=\"nb\"abs/spanspan class=\"p\"(/spanspan class=\"n\"element/spanspan class=\"p\"),/span span class=\"n\"element/span span class=\"o\"lt;/span span class=\"mi\"0/spanspan class=\"p\"))/span\n\nspan class=\"n\"ints/span span class=\"o\"=/span span class=\"n\"strategies/spanspan class=\"o\"./spanspan class=\"n\"sampled_from/spanspan class=\"p\"(/spanspan class=\"n\"ints_special/spanspan class=\"p\")/span span class=\"o\"|/span span class=\"n\"strategies/spanspan class=\"o\"./spanspan class=\"n\"integers/spanspan class=\"p\"()/span\n/pre/div\n\npNow we get data like this:/p\ndiv class=\"code\"pre class=\"code literal-block\"span class=\"mf\"1110/spanspan class=\"w\" /spanspan class=\"mf\"1110/span\nspan class=\"mf\"...10000000000000000001/spanspan class=\"w\" /spanspan class=\"mf\"...10000/spanspan class=\"err\"??/spanspan class=\"mf\"0/spanspan class=\"err\"??/spanspan class=\"mf\"0000/spanspan class=\"err\"??/spanspan class=\"mf\"00/spanspan class=\"err\"?/spanspan class=\"mf\"1/span\nspan class=\"mf\"1/spanspan class=\"w\" /spanspan class=\"err\"??/spanspan class=\"mf\"0/spanspan class=\"err\"??/spanspan class=\"mf\"0000/spanspan class=\"err\"??/spanspan class=\"mf\"00/spanspan class=\"err\"?/spanspan class=\"mf\"1/span\nspan class=\"mf\"1/spanspan class=\"w\" /spanspan class=\"err\"?/span\nspan class=\"mf\"...10101100/spanspan class=\"w\" /spanspan class=\"mf\"...10101100/span\nspan class=\"mf\"110000000011001010111011111111111111011110010001001100110001011/spanspan class=\"w\" /spanspan class=\"mf\".../spanspan class=\"err\"?/spanspan class=\"mf\"0/spanspan class=\"err\"?/spanspan class=\"mf\"101/spanspan class=\"err\"?/span\nspan class=\"mf\"110000000011001010111011111111111111011110010001001100110001011/spanspan class=\"w\" /spanspan class=\"err\"??/spanspan class=\"mf\"00000000/spanspan class=\"err\"??/spanspan class=\"mf\"00/spanspan class=\"err\"?/spanspan class=\"mf\"0/spanspan class=\"err\"?/spanspan class=\"mf\"0/spanspan class=\"err\"???/spanspan class=\"mf\"0/spanspan class=\"err\"??????????????/spanspan class=\"mf\"0/spanspan class=\"err\"????/spanspan class=\"mf\"00/spanspan class=\"err\"?/spanspan class=\"mf\"000/spanspan class=\"err\"?/spanspan class=\"mf\"00/spanspan class=\"err\"??/spanspan class=\"mf\"00/spanspan class=\"err\"??/spanspan class=\"mf\"000/spanspan class=\"err\"?/spanspan class=\"mf\"0/spanspan class=\"err\"??/span\nspan class=\"mf\"...1011111111111111111111111111/spanspan class=\"w\" /spanspan class=\"mf\".../spanspan class=\"err\"?/spanspan class=\"mf\"11/spanspan class=\"err\"?/spanspan class=\"mf\"11/spanspan class=\"err\"??/span\nspan class=\"mf\"...1011111111111111111111111111/spanspan class=\"w\" /spanspan class=\"mf\".../spanspan class=\"err\"?/spanspan class=\"mf\"0/spanspan class=\"err\"??????????????????????????/span\nspan class=\"mf\"0/spanspan class=\"w\" /spanspan class=\"mf\".../spanspan class=\"err\"?/spanspan class=\"mf\"0/spanspan class=\"err\"??????????????????????????/span\nspan class=\"mf\"101101/spanspan class=\"w\" /spanspan class=\"mf\"101101/span\nspan class=\"mf\"111111111111111111111111111111111111111111111/spanspan class=\"w\" /spanspan class=\"mf\"111111111111111111111111111111111111111111111/span\nspan class=\"mf\"10111/spanspan class=\"w\" /spanspan class=\"mf\"10111/span\nspan class=\"mf\"...101100/spanspan class=\"w\" /spanspan class=\"mf\"...1/spanspan class=\"err\"?/spanspan class=\"mf\"111011/spanspan class=\"err\"?/spanspan class=\"mf\"0/span\nspan class=\"mf\"101000/spanspan class=\"w\" /spanspan class=\"err\"?/spanspan class=\"mf\"001010/spanspan class=\"err\"?/spanspan class=\"mf\"0/span\nspan class=\"mf\"101000/spanspan class=\"w\" /spanspan class=\"err\"?/spanspan class=\"mf\"0/spanspan class=\"err\"?/spanspan class=\"mf\"000/span\nspan class=\"mf\"110010/spanspan class=\"w\" /spanspan class=\"mf\"110010/span\nspan class=\"mf\"...100111/spanspan class=\"w\" /spanspan class=\"mf\"...100111/span\nspan class=\"mf\"1111011010010/spanspan class=\"w\" /spanspan class=\"mf\"1111011010010/span\nspan class=\"mf\"...1000000000000000000000000000000000000/spanspan class=\"w\" /spanspan class=\"mf\"...1000000000000000000000000000000000000/span\n/pre/div\n\npWe can also write a test that checks that the somewhat tricky logic in\ncode__str__/code and codefrom_str/code is correct, by making sure that the two functions\nround-trip (ie converting a codeKnownBits/code to a string and then back to a\ncodeKnownBits/code instance produces the same abstract value)./p\ndiv class=\"code\"pre class=\"code literal-block\"span class=\"nd\"@given/spanspan class=\"p\"(/spanspan class=\"n\"knownbits_and_contained_number/spanspan class=\"p\")/span\nspan class=\"k\"def/span span class=\"nf\"test_hypothesis_str_roundtrips/spanspan class=\"p\"(/spanspan class=\"n\"t1/spanspan class=\"p\"):/span\n    span class=\"n\"k1/spanspan class=\"p\",/span span class=\"n\"n1/span span class=\"o\"=/span span class=\"n\"t1/span\n    span class=\"n\"s/span span class=\"o\"=/span span class=\"nb\"str/spanspan class=\"p\"(/spanspan class=\"n\"k1/spanspan class=\"p\")/span\n    span class=\"n\"k2/span span class=\"o\"=/span span class=\"n\"KnownBits/spanspan class=\"o\"./spanspan class=\"n\"from_str/spanspan class=\"p\"(/spanspan class=\"n\"s/spanspan class=\"p\")/span\n    span class=\"k\"assert/span span class=\"n\"k1/spanspan class=\"o\"./spanspan class=\"n\"ones/span span class=\"o\"==/span span class=\"n\"k2/spanspan class=\"o\"./spanspan class=\"n\"ones/span\n    span class=\"k\"assert/span span class=\"n\"k1/spanspan class=\"o\"./spanspan class=\"n\"unknowns/span span class=\"o\"==/span span class=\"n\"k2/spanspan class=\"o\"./spanspan class=\"n\"unknowns/span\n/pre/div\n\npNow let's actually apply this infrastructure to test codeabstract_invert/code./p\nh3 id=\"when-are-transfer-functions-correct-how-do-we-test-them\"When are Transfer Functions Correct? How do we test them?/h3\npAbstract values, i.e. instances of codeKnownBits/code represent emsets/em of concrete\nvalues. We want the transfer functions to compute emoverapproximations/em of the\nconcrete values. So if we have an arbitrary abstract value codek/code, with a concrete\nnumber coden/code that is a member of the abstract values (i.e.\ncodek.contains(n) == True/code) then the result of the concrete operation codeop(n)/code\nstrongmust/strong be a member of the result of the abstract operation codek.abstract_op()/code\n(i.e. codek.abstract_op().contains(op(n)) == True/code)./p\npChecking the correctness/overapproximation property is a good match for\nhypothesis. Here's what the test for codeabstract_invert/code looks like:/p\ndiv class=\"code\"pre class=\"code literal-block\"span class=\"nd\"@given/spanspan class=\"p\"(/spanspan class=\"n\"knownbits_and_contained_number/spanspan class=\"p\")/span\nspan class=\"k\"def/span span class=\"nf\"test_hypothesis_invert/spanspan class=\"p\"(/spanspan class=\"n\"t/spanspan class=\"p\"):/span\n    span class=\"n\"k1/spanspan class=\"p\",/span span class=\"n\"n1/span span class=\"o\"=/span span class=\"n\"t1/span\n    span class=\"n\"n2/span span class=\"o\"=/span span class=\"o\"~/spanspan class=\"n\"n1/span span class=\"c1\"# compute the real result/span\n    span class=\"n\"k2/span span class=\"o\"=/span span class=\"n\"k1/spanspan class=\"o\"./spanspan class=\"n\"abstract_invert/spanspan class=\"p\"()/span span class=\"c1\"# compute the abstract result/span\n    span class=\"k\"assert/span span class=\"n\"k2/spanspan class=\"o\"./spanspan class=\"n\"contains/spanspan class=\"p\"(/spanspan class=\"n\"n2/spanspan class=\"p\")/span span class=\"c1\"# the abstract result must contain the real result/span\n/pre/div\n\npThis is the emonly/em condition needed for codeabstract_invert/code to be correct. If\ncodeabstract_invert/code fulfils this property for every combination of abstract and\nconcrete value then codeabstract_invert/code is correct. Note however, that this test\ndoes not actually check whether codeabstract_invert/code gives us precise results. A\ncorrect (but imprecise) implementation of codeabstract_invert/code would simply return\na completely unknown result, regardless of what is known about the input\ncodeKnownBits/code./p\npThe \"proper\" CS term for this notion of correctness is called emsoundness/em. The\ncorrectness condition on the transfer functions is called a emGalois\nconnection/em. I won't go into any mathematical/technical details here, but\nwanted to at least mention the terms. I found a href=\"https://web.njit.edu/~mjk76/\"Martin\nKellogg/a's\na href=\"https://web.njit.edu/~mjk76/teaching/cs684-sp24/assets/lecture-12.pdf#34\"slides/a\nto be quite an approachable introduction to the Galois connection and how to\nshow soundness./p\nh3 id=\"implementing-binary-transfer-functions\"Implementing Binary Transfer Functions/h3\npNow we have infrastructure in place for testing transfer functions with random\ninputs. With that we can start thinking about the more complicated case, that of\nbinary operations. Let's start with the simpler ones, codeand/code and codeor/code. For codeand/code,\nwe can know a code0/code bit in the result if either of the input bits are known code0/code;\nor we can know a code1/code bit in the result if both input bits are known code1/code.\nOtherwise the resulting bit is unknown. Let's look at all the combinations:/p\ndiv class=\"code\"pre class=\"code literal-block\"and\ninput1: 000111???\ninput2: 01?01?01?\nresult: 00001?0??\n/pre/div\n\ndiv class=\"code\"pre class=\"code literal-block\"span class=\"k\"class/span span class=\"nc\"KnownBits/spanspan class=\"p\":/span\n    span class=\"o\".../span\n\n    span class=\"k\"def/span span class=\"nf\"abstract_and/spanspan class=\"p\"(/spanspan class=\"bp\"self/spanspan class=\"p\",/span span class=\"n\"other/spanspan class=\"p\"):/span\n        span class=\"n\"ones/span span class=\"o\"=/span span class=\"bp\"self/spanspan class=\"o\"./spanspan class=\"n\"ones/span span class=\"o\"amp;/span span class=\"n\"other/spanspan class=\"o\"./spanspan class=\"n\"ones/span span class=\"c1\"# known ones/span\n        span class=\"n\"knowns/span span class=\"o\"=/span span class=\"bp\"self/spanspan class=\"o\"./spanspan class=\"n\"zeros/span span class=\"o\"|/span span class=\"n\"other/spanspan class=\"o\"./spanspan class=\"n\"zeros/span span class=\"o\"|/span span class=\"n\"ones/span\n        span class=\"k\"return/span span class=\"n\"KnownBits/spanspan class=\"p\"(/spanspan class=\"n\"ones/spanspan class=\"p\",/span span class=\"o\"~/spanspan class=\"n\"knowns/spanspan class=\"p\")/span\n/pre/div\n\npHere's an example unit-test and a property-based test for codeand/code:/p\ndiv class=\"code\"pre class=\"code literal-block\"span class=\"k\"def/span span class=\"nf\"test_and/spanspan class=\"p\"():/span\n    span class=\"c1\"# test all combinations of 0, 1, ? in one example/span\n    span class=\"n\"k1/span span class=\"o\"=/span span class=\"n\"KnownBits/spanspan class=\"o\"./spanspan class=\"n\"from_str/spanspan class=\"p\"(/spanspan class=\"s1\"'01?01?01?'/spanspan class=\"p\")/span\n    span class=\"n\"k2/span span class=\"o\"=/span span class=\"n\"KnownBits/spanspan class=\"o\"./spanspan class=\"n\"from_str/spanspan class=\"p\"(/spanspan class=\"s1\"'000111???'/spanspan class=\"p\")/span\n    span class=\"n\"res/span span class=\"o\"=/span span class=\"n\"k1/spanspan class=\"o\"./spanspan class=\"n\"abstract_and/spanspan class=\"p\"(/spanspan class=\"n\"k2/spanspan class=\"p\")/span     span class=\"c1\"# should be: 0...00001?0??/span\n    span class=\"k\"assert/span span class=\"nb\"str/spanspan class=\"p\"(/spanspan class=\"n\"res/spanspan class=\"p\")/span span class=\"o\"==/span   span class=\"s2\"\"1?0??\"/span\n\nspan class=\"nd\"@given/spanspan class=\"p\"(/spanspan class=\"n\"knownbits_and_contained_number/spanspan class=\"p\",/span span class=\"n\"knownbits_and_contained_number/spanspan class=\"p\")/span\nspan class=\"k\"def/span span class=\"nf\"test_hypothesis_and/spanspan class=\"p\"(/spanspan class=\"n\"t1/spanspan class=\"p\",/span span class=\"n\"t2/spanspan class=\"p\"):/span\n    span class=\"n\"k1/spanspan class=\"p\",/span span class=\"n\"n1/span span class=\"o\"=/span span class=\"n\"t1/span\n    span class=\"n\"k2/spanspan class=\"p\",/span span class=\"n\"n2/span span class=\"o\"=/span span class=\"n\"t2/span\n    span class=\"n\"k3/span span class=\"o\"=/span span class=\"n\"k1/spanspan class=\"o\"./spanspan class=\"n\"abstract_and/spanspan class=\"p\"(/spanspan class=\"n\"k2/spanspan class=\"p\")/span\n    span class=\"n\"n3/span span class=\"o\"=/span span class=\"n\"n1/span span class=\"o\"amp;/span span class=\"n\"n2/span\n    span class=\"k\"assert/span span class=\"n\"k3/spanspan class=\"o\"./spanspan class=\"n\"contains/spanspan class=\"p\"(/spanspan class=\"n\"n3/spanspan class=\"p\")/span\n/pre/div\n\npTo implement codeor/code is pretty similar. The result is known code1/code where either of the\ninputs is code1/code. The result is known code0/code where both inputs are known code0/code, and code?/code\notherwise./p\ndiv class=\"code\"pre class=\"code literal-block\"or\ninput1: 000111???\ninput2: 01?01?01?\nresult: 01?111?1?\n/pre/div\n\ndiv class=\"code\"pre class=\"code literal-block\"span class=\"k\"class/span span class=\"nc\"KnownBits/spanspan class=\"p\":/span\n    span class=\"o\".../span\n\n    span class=\"k\"def/span span class=\"nf\"abstract_or/spanspan class=\"p\"(/spanspan class=\"bp\"self/spanspan class=\"p\",/span span class=\"n\"other/spanspan class=\"p\"):/span\n        span class=\"n\"ones/span span class=\"o\"=/span span class=\"bp\"self/spanspan class=\"o\"./spanspan class=\"n\"ones/span span class=\"o\"|/span span class=\"n\"other/spanspan class=\"o\"./spanspan class=\"n\"ones/span\n        span class=\"n\"zeros/span span class=\"o\"=/span span class=\"bp\"self/spanspan class=\"o\"./spanspan class=\"n\"zeros/span span class=\"o\"amp;/span span class=\"n\"other/spanspan class=\"o\"./spanspan class=\"n\"zeros/span\n        span class=\"n\"knowns/span span class=\"o\"=/span span class=\"n\"ones/span span class=\"o\"|/span span class=\"n\"zeros/span\n        span class=\"k\"return/span span class=\"n\"KnownBits/spanspan class=\"p\"(/spanspan class=\"n\"ones/spanspan class=\"p\",/span span class=\"o\"~/spanspan class=\"n\"knowns/spanspan class=\"p\")/span\n/pre/div\n\npHere's an example unit-test and a property-based test for codeor/code:/p\ndiv class=\"code\"pre class=\"code literal-block\"span class=\"k\"def/span span class=\"nf\"test_or/spanspan class=\"p\"():/span\n    span class=\"n\"k1/span span class=\"o\"=/span span class=\"n\"KnownBits/spanspan class=\"o\"./spanspan class=\"n\"from_str/spanspan class=\"p\"(/spanspan class=\"s1\"'01?01?01?'/spanspan class=\"p\")/span\n    span class=\"n\"k2/span span class=\"o\"=/span span class=\"n\"KnownBits/spanspan class=\"o\"./spanspan class=\"n\"from_str/spanspan class=\"p\"(/spanspan class=\"s1\"'000111???'/spanspan class=\"p\")/span\n    span class=\"n\"res/span span class=\"o\"=/span span class=\"n\"k1/spanspan class=\"o\"./spanspan class=\"n\"abstract_or/spanspan class=\"p\"(/spanspan class=\"n\"k2/spanspan class=\"p\")/span     span class=\"c1\"# should be:  0...01?111?1?/span\n    span class=\"k\"assert/span span class=\"nb\"str/spanspan class=\"p\"(/spanspan class=\"n\"res/spanspan class=\"p\")/span span class=\"o\"==/span   span class=\"s2\"\"1?111?1?\"/span\n\nspan class=\"nd\"@given/spanspan class=\"p\"(/spanspan class=\"n\"knownbits_and_contained_number/spanspan class=\"p\",/span span class=\"n\"knownbits_and_contained_number/spanspan class=\"p\")/span\nspan class=\"k\"def/span span class=\"nf\"test_hypothesis_or/spanspan class=\"p\"(/spanspan class=\"n\"t1/spanspan class=\"p\",/span span class=\"n\"t2/spanspan class=\"p\"):/span\n    span class=\"n\"k1/spanspan class=\"p\",/span span class=\"n\"n1/span span class=\"o\"=/span span class=\"n\"t1/span\n    span class=\"n\"k2/spanspan class=\"p\",/span span class=\"n\"n2/span span class=\"o\"=/span span class=\"n\"t2/span\n    span class=\"n\"k3/span span class=\"o\"=/span span class=\"n\"k1/spanspan class=\"o\"./spanspan class=\"n\"abstract_or/spanspan class=\"p\"(/spanspan class=\"n\"k2/spanspan class=\"p\")/span\n    span class=\"n\"n3/span span class=\"o\"=/span span class=\"n\"n1/span span class=\"o\"|/span span class=\"n\"n2/span\n    span class=\"k\"assert/span span class=\"n\"k3/spanspan class=\"o\"./spanspan class=\"n\"contains/spanspan class=\"p\"(/spanspan class=\"n\"n3/spanspan class=\"p\")/span\n/pre/div\n\npImplementing support for codeabstract_xor/code is relatively simple, and left as an\nexercise :-)./p\nh3 id=\"addition-and-subtraction\"Addition and Subtraction/h3\npcodeinvert/code, codeand/code, and codeor/code are relatively simple transfer functions to write,\nbecause they compose over the individual bits of the integers. The arithmetic\nfunctions codeadd/code and codesub/code are significantly harder, because of carries and\nborrows. Coming up with the formulas for them and gaining an intuitive\nunderstanding is quite tricky and involves carefully going through a few\nexamples with pen and paper. When implementing this in PyPy, Nico and I didn't\ncome up with the implementation ourselves, but instead took them from the\na href=\"https://arxiv.org/abs/2105.05398\"Tristate Numbers/a paper. Here's the code,\nwith example tests and hypothesis tests:/p\ndiv class=\"code\"pre class=\"code literal-block\"span class=\"k\"class/span span class=\"nc\"KnownBits/spanspan class=\"p\":/span\n    span class=\"o\".../span\n\n    span class=\"k\"def/span span class=\"nf\"abstract_add/spanspan class=\"p\"(/spanspan class=\"bp\"self/spanspan class=\"p\",/span span class=\"n\"other/spanspan class=\"p\"):/span\n        span class=\"n\"sum_ones/span span class=\"o\"=/span span class=\"bp\"self/spanspan class=\"o\"./spanspan class=\"n\"ones/span span class=\"o\"+/span span class=\"n\"other/spanspan class=\"o\"./spanspan class=\"n\"ones/span\n        span class=\"n\"sum_unknowns/span span class=\"o\"=/span span class=\"bp\"self/spanspan class=\"o\"./spanspan class=\"n\"unknowns/span span class=\"o\"+/span span class=\"n\"other/spanspan class=\"o\"./spanspan class=\"n\"unknowns/span\n        span class=\"n\"all_carries/span span class=\"o\"=/span span class=\"n\"sum_ones/span span class=\"o\"+/span span class=\"n\"sum_unknowns/span\n        span class=\"n\"ones_carries/span span class=\"o\"=/span span class=\"n\"all_carries/span span class=\"o\"^/span span class=\"n\"sum_ones/span\n        span class=\"n\"unknowns/span span class=\"o\"=/span span class=\"bp\"self/spanspan class=\"o\"./spanspan class=\"n\"unknowns/span span class=\"o\"|/span span class=\"n\"other/spanspan class=\"o\"./spanspan class=\"n\"unknowns/span span class=\"o\"|/span span class=\"n\"ones_carries/span\n        span class=\"n\"ones/span span class=\"o\"=/span span class=\"n\"sum_ones/span span class=\"o\"amp;/span span class=\"o\"~/spanspan class=\"n\"unknowns/span\n        span class=\"k\"return/span span class=\"n\"KnownBits/spanspan class=\"p\"(/spanspan class=\"n\"ones/spanspan class=\"p\",/span span class=\"n\"unknowns/spanspan class=\"p\")/span\n\n    span class=\"k\"def/span span class=\"nf\"abstract_sub/spanspan class=\"p\"(/spanspan class=\"bp\"self/spanspan class=\"p\",/span span class=\"n\"other/spanspan class=\"p\"):/span\n        span class=\"n\"diff_ones/span span class=\"o\"=/span span class=\"bp\"self/spanspan class=\"o\"./spanspan class=\"n\"ones/span span class=\"o\"-/span span class=\"n\"other/spanspan class=\"o\"./spanspan class=\"n\"ones/span\n        span class=\"n\"val_borrows/span span class=\"o\"=/span span class=\"p\"(/spanspan class=\"n\"diff_ones/span span class=\"o\"+/span span class=\"bp\"self/spanspan class=\"o\"./spanspan class=\"n\"unknowns/spanspan class=\"p\")/span span class=\"o\"^/span span class=\"p\"(/spanspan class=\"n\"diff_ones/span span class=\"o\"-/span span class=\"n\"other/spanspan class=\"o\"./spanspan class=\"n\"unknowns/spanspan class=\"p\")/span\n        span class=\"n\"unknowns/span span class=\"o\"=/span span class=\"bp\"self/spanspan class=\"o\"./spanspan class=\"n\"unknowns/span span class=\"o\"|/span span class=\"n\"other/spanspan class=\"o\"./spanspan class=\"n\"unknowns/span span class=\"o\"|/span span class=\"n\"val_borrows/span\n        span class=\"n\"ones/span span class=\"o\"=/span span class=\"n\"diff_ones/span span class=\"o\"amp;/span span class=\"o\"~/spanspan class=\"n\"unknowns/span\n        span class=\"k\"return/span span class=\"n\"KnownBits/spanspan class=\"p\"(/spanspan class=\"n\"ones/spanspan class=\"p\",/span span class=\"n\"unknowns/spanspan class=\"p\")/span\n\n\nspan class=\"k\"def/span span class=\"nf\"test_add/spanspan class=\"p\"():/span\n    span class=\"n\"k1/span span class=\"o\"=/span span class=\"n\"KnownBits/spanspan class=\"o\"./spanspan class=\"n\"from_str/spanspan class=\"p\"(/spanspan class=\"s1\"'0?10?10?10'/spanspan class=\"p\")/span\n    span class=\"n\"k2/span span class=\"o\"=/span span class=\"n\"KnownBits/spanspan class=\"o\"./spanspan class=\"n\"from_str/spanspan class=\"p\"(/spanspan class=\"s1\"'0???111000'/spanspan class=\"p\")/span\n    span class=\"n\"res/span span class=\"o\"=/span span class=\"n\"k1/spanspan class=\"o\"./spanspan class=\"n\"abstract_add/spanspan class=\"p\"(/spanspan class=\"n\"k2/spanspan class=\"p\")/span\n    span class=\"k\"assert/span span class=\"nb\"str/spanspan class=\"p\"(/spanspan class=\"n\"res/spanspan class=\"p\")/span span class=\"o\"==/span   span class=\"s2\"\"?????01?10\"/span\n\nspan class=\"k\"def/span span class=\"nf\"test_sub/spanspan class=\"p\"():/span\n    span class=\"n\"k1/span span class=\"o\"=/span span class=\"n\"KnownBits/spanspan class=\"o\"./spanspan class=\"n\"from_str/spanspan class=\"p\"(/spanspan class=\"s1\"'0?10?10?10'/spanspan class=\"p\")/span\n    span class=\"n\"k2/span span class=\"o\"=/span span class=\"n\"KnownBits/spanspan class=\"o\"./spanspan class=\"n\"from_str/spanspan class=\"p\"(/spanspan class=\"s1\"'0???111000'/spanspan class=\"p\")/span\n    span class=\"n\"res/span span class=\"o\"=/span span class=\"n\"k1/spanspan class=\"o\"./spanspan class=\"n\"abstract_sub/spanspan class=\"p\"(/spanspan class=\"n\"k2/spanspan class=\"p\")/span\n    span class=\"k\"assert/span span class=\"nb\"str/spanspan class=\"p\"(/spanspan class=\"n\"res/spanspan class=\"p\")/span span class=\"o\"==/span   span class=\"s2\"\"...?11?10\"/span\n    span class=\"n\"k1/span span class=\"o\"=/span span class=\"n\"KnownBits/spanspan class=\"o\"./spanspan class=\"n\"from_str/spanspan class=\"p\"(/span    span class=\"s1\"'...1?10?10?10'/spanspan class=\"p\")/span\n    span class=\"n\"k2/span span class=\"o\"=/span span class=\"n\"KnownBits/spanspan class=\"o\"./spanspan class=\"n\"from_str/spanspan class=\"p\"(/spanspan class=\"s1\"'...10000???111000'/spanspan class=\"p\")/span\n    span class=\"n\"res/span span class=\"o\"=/span span class=\"n\"k1/spanspan class=\"o\"./spanspan class=\"n\"abstract_sub/spanspan class=\"p\"(/spanspan class=\"n\"k2/spanspan class=\"p\")/span\n    span class=\"k\"assert/span span class=\"nb\"str/spanspan class=\"p\"(/spanspan class=\"n\"res/spanspan class=\"p\")/span span class=\"o\"==/span   span class=\"s2\"\"111?????11?10\"/span\n\nspan class=\"nd\"@given/spanspan class=\"p\"(/spanspan class=\"n\"knownbits_and_contained_number/spanspan class=\"p\",/span span class=\"n\"knownbits_and_contained_number/spanspan class=\"p\")/span\nspan class=\"k\"def/span span class=\"nf\"test_hypothesis_add/spanspan class=\"p\"(/spanspan class=\"n\"t1/spanspan class=\"p\",/span span class=\"n\"t2/spanspan class=\"p\"):/span\n    span class=\"n\"k1/spanspan class=\"p\",/span span class=\"n\"n1/span span class=\"o\"=/span span class=\"n\"t1/span\n    span class=\"n\"k2/spanspan class=\"p\",/span span class=\"n\"n2/span span class=\"o\"=/span span class=\"n\"t2/span\n    span class=\"n\"k3/span span class=\"o\"=/span span class=\"n\"k1/spanspan class=\"o\"./spanspan class=\"n\"abstract_add/spanspan class=\"p\"(/spanspan class=\"n\"k2/spanspan class=\"p\")/span\n    span class=\"n\"n3/span span class=\"o\"=/span span class=\"n\"n1/span span class=\"o\"+/span span class=\"n\"n2/span\n    span class=\"k\"assert/span span class=\"n\"k3/spanspan class=\"o\"./spanspan class=\"n\"contains/spanspan class=\"p\"(/spanspan class=\"n\"n3/spanspan class=\"p\")/span\n\nspan class=\"nd\"@given/spanspan class=\"p\"(/spanspan class=\"n\"knownbits_and_contained_number/spanspan class=\"p\",/span span class=\"n\"knownbits_and_contained_number/spanspan class=\"p\")/span\nspan class=\"k\"def/span span class=\"nf\"test_hypothesis_sub/spanspan class=\"p\"(/spanspan class=\"n\"t1/spanspan class=\"p\",/span span class=\"n\"t2/spanspan class=\"p\"):/span\n    span class=\"n\"k1/spanspan class=\"p\",/span span class=\"n\"n1/span span class=\"o\"=/span span class=\"n\"t1/span\n    span class=\"n\"k2/spanspan class=\"p\",/span span class=\"n\"n2/span span class=\"o\"=/span span class=\"n\"t2/span\n    span class=\"n\"k3/span span class=\"o\"=/span span class=\"n\"k1/spanspan class=\"o\"./spanspan class=\"n\"abstract_sub/spanspan class=\"p\"(/spanspan class=\"n\"k2/spanspan class=\"p\")/span\n    span class=\"n\"n3/span span class=\"o\"=/span span class=\"n\"n1/span span class=\"o\"-/span span class=\"n\"n2/span\n    span class=\"k\"assert/span span class=\"n\"k3/spanspan class=\"o\"./spanspan class=\"n\"contains/spanspan class=\"p\"(/spanspan class=\"n\"n3/spanspan class=\"p\")/span\n/pre/div\n\npNow we are in a pretty good situation, and have implemented abstract versions\nfor a bunch of important arithmetic and binary functions. What's also surprising\nis that the implementation of all of the transfer functions is quite efficient.\nWe didn't have to write loops over the individual bits at all, instead we found\nclosed form expressions using primitive operations on the underlying integers\ncodeones/code and codeunknowns/code. This means that computing the results of abstract\noperations is quite efficient, which is important when using the abstract domain\nin the context of a JIT compiler./p\nh3 id=\"proving-correctness-of-the-transfer-functions-with-z3\"Proving correctness of the transfer functions with Z3/h3\npAs one can probably tell from my recent posts, I've been thinking about\ncompiler correctness a lot. Getting the transfer functions absolutely\ncorrect is really crucial, because a bug in them would lead to miscompilation of\nPython code when the abstract domain is added to the JIT. While the randomized\ntests are great, it's still entirely possible for them to miss bugs. The state\nspace for the arguments of a binary transfer function is code3**64 * 3**64/code, and if\nonly a small part of that contains wrong behaviour it would be really unlikely\nfor us to find it with random tests by chance. Therefore I was reluctant to\nmerge the PyPy branch that contained the new abstract domain for a long time./p\npTo increase our confidence in the correctness of the transfer functions further,\nwe can use Z3 to emprove/em their correctness, which gives us much stronger\nguarantees (not 100%, obviously). In this subsection I will show how to do that./p\npHere's an attempt to do this manually in the Python repl:/p\ndiv class=\"code\"pre class=\"code literal-block\"span class=\"o\"gt;gt;gt;gt;/spanspan class=\"w\" /spanspan class=\"kn\"import/spanspan class=\"w\" /spanspan class=\"nn\"z3/span\nspan class=\"o\"gt;gt;gt;gt;/spanspan class=\"w\" /spanspan class=\"n\"solver/spanspan class=\"w\" /spanspan class=\"o\"=/spanspan class=\"w\" /spanspan class=\"n\"z3/spanspan class=\"o\"./spanspan class=\"n\"Solver/spanspan class=\"p\"()/span\nspan class=\"o\"gt;gt;gt;gt;/spanspan class=\"w\" /spanspan class=\"c1\"# like last blog post, proof by failing to find counterexamples/span\nspan class=\"o\"gt;gt;gt;gt;/spanspan class=\"w\" /spanspan class=\"k\"def/spanspan class=\"w\" /spanspan class=\"nf\"prove/spanspan class=\"p\"(/spanspan class=\"n\"cond/spanspan class=\"p\"):/spanspan class=\"w\" /spanspan class=\"k\"assert/spanspan class=\"w\" /spanspan class=\"n\"solver/spanspan class=\"o\"./spanspan class=\"n\"check/spanspan class=\"p\"(/spanspan class=\"n\"z3/spanspan class=\"o\"./spanspan class=\"n\"Not/spanspan class=\"p\"(/spanspan class=\"n\"cond/spanspan class=\"p\"))/spanspan class=\"w\" /spanspan class=\"o\"==/spanspan class=\"w\" /spanspan class=\"n\"z3/spanspan class=\"o\"./spanspan class=\"n\"unsat/span\nspan class=\"o\"gt;gt;gt;gt;/span\nspan class=\"o\"gt;gt;gt;gt;/spanspan class=\"w\" /spanspan class=\"c1\"# let's set up a z3 bitvector variable for an arbitrary concrete value/span\nspan class=\"o\"gt;gt;gt;gt;/spanspan class=\"w\" /spanspan class=\"n\"n1/spanspan class=\"w\" /spanspan class=\"o\"=/spanspan class=\"w\" /spanspan class=\"n\"z3/spanspan class=\"o\"./spanspan class=\"n\"BitVec/spanspan class=\"p\"(/spanspan class=\"s1\"'concrete_value'/spanspan class=\"p\",/spanspan class=\"w\" /spanspan class=\"mi\"64/spanspan class=\"p\")/span\nspan class=\"o\"gt;gt;gt;gt;/spanspan class=\"w\" /spanspan class=\"n\"n1/span\nspan class=\"n\"concrete_value/span\nspan class=\"o\"gt;gt;gt;gt;/spanspan class=\"w\" /spanspan class=\"c1\"# due to operator overloading we can manipulate z3 formulas/span\nspan class=\"o\"gt;gt;gt;gt;/spanspan class=\"w\" /spanspan class=\"n\"n2/spanspan class=\"w\" /spanspan class=\"o\"=/spanspan class=\"w\" /spanspan class=\"o\"~/spanspan class=\"n\"n1/span\nspan class=\"o\"gt;gt;gt;gt;/spanspan class=\"w\" /spanspan class=\"n\"n2/span\nspan class=\"o\"~/spanspan class=\"n\"concrete_value/span\nspan class=\"o\"gt;gt;gt;gt;/spanspan class=\"w\" /span\nspan class=\"o\"gt;gt;gt;gt;/spanspan class=\"w\" /spanspan class=\"c1\"# now z3 bitvector variables for the ones and zeros fields/span\nspan class=\"o\"gt;gt;gt;gt;/spanspan class=\"w\" /spanspan class=\"n\"ones/spanspan class=\"w\" /spanspan class=\"o\"=/spanspan class=\"w\" /spanspan class=\"n\"z3/spanspan class=\"o\"./spanspan class=\"n\"BitVec/spanspan class=\"p\"(/spanspan class=\"s1\"'abstract_ones'/spanspan class=\"p\",/spanspan class=\"w\" /spanspan class=\"mi\"64/spanspan class=\"p\")/span\nspan class=\"o\"gt;gt;gt;gt;/spanspan class=\"w\" /spanspan class=\"n\"unknowns/spanspan class=\"w\" /spanspan class=\"o\"=/spanspan class=\"w\" /spanspan class=\"n\"z3/spanspan class=\"o\"./spanspan class=\"n\"BitVec/spanspan class=\"p\"(/spanspan class=\"s1\"'abstract_unknowns'/spanspan class=\"p\",/spanspan class=\"w\" /spanspan class=\"mi\"64/spanspan class=\"p\")/span\nspan class=\"o\"gt;gt;gt;gt;/spanspan class=\"w\" /spanspan class=\"c1\"# we construct a KnownBits instance with the z3 variables/span\nspan class=\"o\"gt;gt;gt;gt;/spanspan class=\"w\" /spanspan class=\"n\"k1/spanspan class=\"w\" /spanspan class=\"o\"=/spanspan class=\"w\" /spanspan class=\"n\"KnownBits/spanspan class=\"p\"(/spanspan class=\"n\"ones/spanspan class=\"p\",/spanspan class=\"w\" /spanspan class=\"n\"unknowns/spanspan class=\"p\")/span\nspan class=\"o\"gt;gt;gt;gt;/spanspan class=\"w\" /spanspan class=\"c1\"# due to operator overloading we can call the methods on k1:/span\nspan class=\"o\"gt;gt;gt;gt;/spanspan class=\"w\" /spanspan class=\"n\"k2/spanspan class=\"w\" /spanspan class=\"o\"=/spanspan class=\"w\" /spanspan class=\"n\"k1/spanspan class=\"o\"./spanspan class=\"n\"abstract_invert/spanspan class=\"p\"()/span\nspan class=\"o\"gt;gt;gt;gt;/spanspan class=\"w\" /spanspan class=\"n\"k2/spanspan class=\"o\"./spanspan class=\"n\"ones/span\nspan class=\"o\"~/spanspan class=\"n\"abstract_unknowns/spanspan class=\"w\" /spanspan class=\"o\"amp;/spanspan class=\"w\" /spanspan class=\"o\"~/spanspan class=\"n\"abstract_ones/span\nspan class=\"o\"gt;gt;gt;gt;/spanspan class=\"w\" /spanspan class=\"n\"k2/spanspan class=\"o\"./spanspan class=\"n\"unknowns/span\nspan class=\"n\"abstract_unknowns/span\nspan class=\"o\"gt;gt;gt;gt;/spanspan class=\"w\" /spanspan class=\"c1\"# here's the correctness condition that we want to prove:/span\nspan class=\"o\"gt;gt;gt;gt;/spanspan class=\"w\" /spanspan class=\"n\"k2/spanspan class=\"o\"./spanspan class=\"n\"contains/spanspan class=\"p\"(/spanspan class=\"n\"n2/spanspan class=\"p\")/span\nspan class=\"o\"~/spanspan class=\"n\"concrete_value/spanspan class=\"w\" /spanspan class=\"o\"amp;/spanspan class=\"w\" /spanspan class=\"o\"~/spanspan class=\"n\"abstract_unknowns/spanspan class=\"w\" /spanspan class=\"o\"==/span\nspan class=\"o\"~/spanspan class=\"n\"abstract_unknowns/spanspan class=\"w\" /spanspan class=\"o\"amp;/spanspan class=\"w\" /spanspan class=\"o\"~/spanspan class=\"n\"abstract_ones/span\nspan class=\"o\"gt;gt;gt;gt;/spanspan class=\"w\" /spanspan class=\"c1\"# let's try/span\nspan class=\"o\"gt;gt;gt;gt;/spanspan class=\"w\" /spanspan class=\"n\"prove/spanspan class=\"p\"(/spanspan class=\"n\"k2/spanspan class=\"o\"./spanspan class=\"n\"contains/spanspan class=\"p\"(/spanspan class=\"n\"n2/spanspan class=\"p\"))/span\nspan class=\"n\"Traceback/spanspan class=\"w\" /spanspan class=\"p\"(/spanspan class=\"n\"most/spanspan class=\"w\" /spanspan class=\"n\"recent/spanspan class=\"w\" /spanspan class=\"n\"call/spanspan class=\"w\" /spanspan class=\"n\"last/spanspan class=\"p\"):/span\nspan class=\"w\"  /spanspan class=\"n\"File/spanspan class=\"w\" /spanspan class=\"s2\"\"lt;stdingt;\"/spanspan class=\"p\",/spanspan class=\"w\" /spanspan class=\"n\"line/spanspan class=\"w\" /spanspan class=\"mi\"1/spanspan class=\"p\",/spanspan class=\"w\" /spanspan class=\"ow\"in/spanspan class=\"w\" /spanspan class=\"o\"lt;/spanspan class=\"n\"module/spanspan class=\"o\"gt;/span\nspan class=\"w\"  /spanspan class=\"n\"File/spanspan class=\"w\" /spanspan class=\"s2\"\"lt;stdingt;\"/spanspan class=\"p\",/spanspan class=\"w\" /spanspan class=\"n\"line/spanspan class=\"w\" /spanspan class=\"mi\"1/spanspan class=\"p\",/spanspan class=\"w\" /spanspan class=\"ow\"in/spanspan class=\"w\" /spanspan class=\"n\"prove/span\nspan class=\"n\"AssertionError/span\nspan class=\"o\"gt;gt;gt;gt;/spanspan class=\"w\" /spanspan class=\"c1\"# it doesn't work! let's look at the counterexample to see why:/span\nspan class=\"o\"gt;gt;gt;gt;/spanspan class=\"w\" /spanspan class=\"n\"solver/spanspan class=\"o\"./spanspan class=\"n\"model/spanspan class=\"p\"()/span\nspan class=\"p\"[/spanspan class=\"n\"abstract_unknowns/spanspan class=\"w\" /spanspan class=\"o\"=/spanspan class=\"w\" /spanspan class=\"mi\"0/spanspan class=\"p\",/span\nspan class=\"w\" /spanspan class=\"n\"abstract_ones/spanspan class=\"w\" /spanspan class=\"o\"=/spanspan class=\"w\" /spanspan class=\"mi\"0/spanspan class=\"p\",/span\nspan class=\"w\" /spanspan class=\"n\"concrete_value/spanspan class=\"w\" /spanspan class=\"o\"=/spanspan class=\"w\" /spanspan class=\"mi\"1/spanspan class=\"p\"]/span\nspan class=\"o\"gt;gt;gt;gt;/spanspan class=\"w\" /spanspan class=\"c1\"# we can build a KnownBits instance with the values in the/span\nspan class=\"o\"gt;gt;gt;gt;/spanspan class=\"w\" /spanspan class=\"c1\"# counterexample:/span\nspan class=\"o\"gt;gt;gt;gt;/spanspan class=\"w\" /spanspan class=\"o\"~/spanspan class=\"mi\"1/spanspan class=\"w\" /spanspan class=\"c1\"# concrete result/span\nspan class=\"o\"-/spanspan class=\"mi\"2/span\nspan class=\"o\"gt;gt;gt;gt;/spanspan class=\"w\" /spanspan class=\"n\"counter_example_k1/spanspan class=\"w\" /spanspan class=\"o\"=/spanspan class=\"w\" /spanspan class=\"n\"KnownBits/spanspan class=\"p\"(/spanspan class=\"mi\"0/spanspan class=\"p\",/spanspan class=\"w\" /spanspan class=\"mi\"0/spanspan class=\"p\")/span\nspan class=\"o\"gt;gt;gt;gt;/spanspan class=\"w\" /spanspan class=\"n\"counter_example_k1/span\nspan class=\"n\"KnownBits/spanspan class=\"o\"./spanspan class=\"n\"from_constant/spanspan class=\"p\"(/spanspan class=\"mi\"0/spanspan class=\"p\")/span\nspan class=\"o\"gt;gt;gt;gt;/spanspan class=\"w\" /spanspan class=\"n\"counter_example_k2/spanspan class=\"w\" /spanspan class=\"o\"=/spanspan class=\"w\" /spanspan class=\"n\"counter_example_k1/spanspan class=\"o\"./spanspan class=\"n\"abstract_invert/spanspan class=\"p\"()/span\nspan class=\"o\"gt;gt;gt;gt;/spanspan class=\"w\" /spanspan class=\"n\"counter_example_k2/span\nspan class=\"n\"KnownBits/spanspan class=\"o\"./spanspan class=\"n\"from_constant/spanspan class=\"p\"(/spanspan class=\"o\"-/spanspan class=\"mi\"1/spanspan class=\"p\")/span\nspan class=\"o\"gt;gt;gt;gt;/spanspan class=\"w\" /spanspan class=\"c1\"# let's check the failing condition/span\nspan class=\"o\"gt;gt;gt;gt;/spanspan class=\"w\" /spanspan class=\"n\"counter_example_k2/spanspan class=\"o\"./spanspan class=\"n\"contains/spanspan class=\"p\"(/spanspan class=\"o\"~/spanspan class=\"mi\"1/spanspan class=\"p\")/span\nspan class=\"kc\"False/span\n/pre/div\n\npWhat is the problem here? We didn't tell Z3 that coden1/code was supposed to be a\nmember of codek1/code. We can add this as a precondition to the solver, and then the\nprove works:/p\ndiv class=\"code\"pre class=\"code literal-block\"gt;gt;gt;gt; solver.add(k1.contains(n1))\ngt;gt;gt;gt; prove(k2.contains(n2)) # works!\n/pre/div\n\npThis is super cool! It's really a proof about the actual implementation, because\nwe call the implementation methods directly, and due to the operator overloading\nthat Z3 does we can be sure that we are actually checking a formula that\ncorresponds to the Python code. This eliminates one source of errors in formal\nmethods./p\npDoing the proof manually on the Python REPL is kind of annoying though, and we\nalso would like to make sure that the proofs are re-done when we change the\ncode. What we would really like to do is writing the proofs as a unit-test that\nwe can run while developing and in CI. Doing this is possible, and the unit\ntests that really perform proofs look pleasingly similar to the\nHypothesis-based ones./p\npFirst we need to set up a bit of infrastructure:/p\ndiv class=\"code\"pre class=\"code literal-block\"span class=\"n\"INTEGER_WIDTH/span span class=\"o\"=/span span class=\"mi\"64/span\n\nspan class=\"k\"def/span span class=\"nf\"BitVec/spanspan class=\"p\"(/spanspan class=\"n\"name/spanspan class=\"p\"):/span\n    span class=\"k\"return/span span class=\"n\"z3/spanspan class=\"o\"./spanspan class=\"n\"BitVec/spanspan class=\"p\"(/spanspan class=\"n\"name/spanspan class=\"p\",/span span class=\"n\"INTEGER_WIDTH/spanspan class=\"p\")/span\n\nspan class=\"k\"def/span span class=\"nf\"BitVecVal/spanspan class=\"p\"(/spanspan class=\"n\"val/spanspan class=\"p\"):/span\n    span class=\"k\"return/span span class=\"n\"z3/spanspan class=\"o\"./spanspan class=\"n\"BitVecVal/spanspan class=\"p\"(/spanspan class=\"n\"val/spanspan class=\"p\",/span span class=\"n\"INTEGER_WIDTH/spanspan class=\"p\")/span\n\nspan class=\"k\"def/span span class=\"nf\"z3_setup_variables/spanspan class=\"p\"():/span\n    span class=\"c1\"# instantiate a solver/span\n    span class=\"n\"solver/span span class=\"o\"=/span span class=\"n\"z3/spanspan class=\"o\"./spanspan class=\"n\"Solver/spanspan class=\"p\"()/span\n\n    span class=\"c1\"# a Z3 variable for the first concrete value/span\n    span class=\"n\"n1/span span class=\"o\"=/span span class=\"n\"BitVec/spanspan class=\"p\"(/spanspan class=\"s2\"\"n1\"/spanspan class=\"p\")/span\n    span class=\"c1\"# a KnownBits instances that uses Z3 variables as its ones and unknowns,/span\n    span class=\"c1\"# representing the first abstract value/span\n    span class=\"n\"k1/span span class=\"o\"=/span span class=\"n\"KnownBits/spanspan class=\"p\"(/spanspan class=\"n\"BitVec/spanspan class=\"p\"(/spanspan class=\"s2\"\"n1_ones\"/spanspan class=\"p\"),/span span class=\"n\"BitVec/spanspan class=\"p\"(/spanspan class=\"s2\"\"n1_unkowns\"/spanspan class=\"p\"))/span\n    span class=\"c1\"# add the precondition to the solver that the concrete value n1 must be a/span\n    span class=\"c1\"# member of the abstract value k1/span\n    span class=\"n\"solver/spanspan class=\"o\"./spanspan class=\"n\"add/spanspan class=\"p\"(/spanspan class=\"n\"k1/spanspan class=\"o\"./spanspan class=\"n\"contains/spanspan class=\"p\"(/spanspan class=\"n\"n1/spanspan class=\"p\"))/span\n\n    span class=\"c1\"# a Z3 variable for the second concrete value/span\n    span class=\"n\"n2/span span class=\"o\"=/span span class=\"n\"BitVec/spanspan class=\"p\"(/spanspan class=\"s2\"\"n2\"/spanspan class=\"p\")/span\n    span class=\"c1\"# a KnownBits instances for the second abstract value/span\n    span class=\"n\"k2/span span class=\"o\"=/span span class=\"n\"KnownBits/spanspan class=\"p\"(/spanspan class=\"n\"BitVec/spanspan class=\"p\"(/spanspan class=\"s2\"\"n2_ones\"/spanspan class=\"p\"),/span span class=\"n\"BitVec/spanspan class=\"p\"(/spanspan class=\"s2\"\"n2_unkowns\"/spanspan class=\"p\"))/span\n    span class=\"c1\"# add the precondition linking n2 and k2 to the solver/span\n    span class=\"n\"solver/spanspan class=\"o\"./spanspan class=\"n\"add/spanspan class=\"p\"(/spanspan class=\"n\"k2/spanspan class=\"o\"./spanspan class=\"n\"contains/spanspan class=\"p\"(/spanspan class=\"n\"n2/spanspan class=\"p\"))/span\n    span class=\"k\"return/span span class=\"n\"solver/spanspan class=\"p\",/span span class=\"n\"k1/spanspan class=\"p\",/span span class=\"n\"n1/spanspan class=\"p\",/span span class=\"n\"k2/spanspan class=\"p\",/span span class=\"n\"n2/span\n\nspan class=\"k\"def/span span class=\"nf\"prove/spanspan class=\"p\"(/spanspan class=\"n\"cond/spanspan class=\"p\",/span span class=\"n\"solver/spanspan class=\"p\"):/span\n    span class=\"n\"z3res/span span class=\"o\"=/span span class=\"n\"solver/spanspan class=\"o\"./spanspan class=\"n\"check/spanspan class=\"p\"(/spanspan class=\"n\"z3/spanspan class=\"o\"./spanspan class=\"n\"Not/spanspan class=\"p\"(/spanspan class=\"n\"cond/spanspan class=\"p\"))/span\n    span class=\"k\"if/span span class=\"n\"z3res/span span class=\"o\"!=/span span class=\"n\"z3/spanspan class=\"o\"./spanspan class=\"n\"unsat/spanspan class=\"p\":/span\n        span class=\"k\"assert/span span class=\"n\"z3res/span span class=\"o\"==/span span class=\"n\"z3/spanspan class=\"o\"./spanspan class=\"n\"sat/span span class=\"c1\"# can't be timeout, we set no timeout/span\n        span class=\"c1\"# make the model with the counterexample global, to make inspecting the/span\n        span class=\"c1\"# bug easier when running pytest --pdb/span\n        span class=\"k\"global/span span class=\"n\"model/span\n        span class=\"n\"model/span span class=\"o\"=/span span class=\"n\"solver/spanspan class=\"o\"./spanspan class=\"n\"model/spanspan class=\"p\"()/span\n        span class=\"nb\"print/spanspan class=\"p\"(/spanspan class=\"sa\"f/spanspan class=\"s2\"\"n1=/spanspan class=\"si\"{/spanspan class=\"n\"model/spanspan class=\"o\"./spanspan class=\"n\"eval/spanspan class=\"p\"(/spanspan class=\"n\"n1/spanspan class=\"p\")/spanspan class=\"si\"}/spanspan class=\"s2\", n2=/spanspan class=\"si\"{/spanspan class=\"n\"model/spanspan class=\"o\"./spanspan class=\"n\"eval/spanspan class=\"p\"(/spanspan class=\"n\"n2/spanspan class=\"p\")/spanspan class=\"si\"}/spanspan class=\"s2\"\"/spanspan class=\"p\")/span\n        span class=\"n\"counter_example_k1/span span class=\"o\"=/span span class=\"n\"KnownBits/spanspan class=\"p\"(/spanspan class=\"n\"model/spanspan class=\"o\"./spanspan class=\"n\"eval/spanspan class=\"p\"(/spanspan class=\"n\"k1/spanspan class=\"o\"./spanspan class=\"n\"ones/spanspan class=\"p\")/spanspan class=\"o\"./spanspan class=\"n\"as_signed_long/spanspan class=\"p\"(),/span\n                                       span class=\"n\"model/spanspan class=\"o\"./spanspan class=\"n\"eval/spanspan class=\"p\"(/spanspan class=\"n\"k1/spanspan class=\"o\"./spanspan class=\"n\"unknowns/spanspan class=\"p\")/spanspan class=\"o\"./spanspan class=\"n\"as_signed_long/spanspan class=\"p\"())/span\n        span class=\"n\"counter_example_k2/span span class=\"o\"=/span span class=\"n\"KnownBits/spanspan class=\"p\"(/spanspan class=\"n\"model/spanspan class=\"o\"./spanspan class=\"n\"eval/spanspan class=\"p\"(/spanspan class=\"n\"k2/spanspan class=\"o\"./spanspan class=\"n\"ones/spanspan class=\"p\")/spanspan class=\"o\"./spanspan class=\"n\"as_signed_long/spanspan class=\"p\"(),/span\n                                       span class=\"n\"model/spanspan class=\"o\"./spanspan class=\"n\"eval/spanspan class=\"p\"(/spanspan class=\"n\"k2/spanspan class=\"o\"./spanspan class=\"n\"unknowns/spanspan class=\"p\")/spanspan class=\"o\"./spanspan class=\"n\"as_signed_long/spanspan class=\"p\"())/span\n        span class=\"nb\"print/spanspan class=\"p\"(/spanspan class=\"sa\"f/spanspan class=\"s2\"\"k1=/spanspan class=\"si\"{/spanspan class=\"n\"counter_example_k1/spanspan class=\"si\"}/spanspan class=\"s2\", k2=/spanspan class=\"si\"{/spanspan class=\"n\"counter_example_k2/spanspan class=\"si\"}/spanspan class=\"s2\"\"/spanspan class=\"p\")/span\n        span class=\"nb\"print/spanspan class=\"p\"(/spanspan class=\"sa\"f/spanspan class=\"s2\"\"but /spanspan class=\"si\"{/spanspan class=\"n\"cond/spanspan class=\"si\"=}/spanspan class=\"s2\" evaluates to /spanspan class=\"si\"{/spanspan class=\"n\"model/spanspan class=\"o\"./spanspan class=\"n\"eval/spanspan class=\"p\"(/spanspan class=\"n\"cond/spanspan class=\"p\")/spanspan class=\"si\"}/spanspan class=\"s2\"\"/spanspan class=\"p\")/span\n        span class=\"k\"raise/span span class=\"ne\"ValueError/spanspan class=\"p\"(/spanspan class=\"n\"solver/spanspan class=\"o\"./spanspan class=\"n\"model/spanspan class=\"p\"())/span\n/pre/div\n\npAnd then we can write proof-unit-tests like this:/p\ndiv class=\"code\"pre class=\"code literal-block\"span class=\"k\"def/span span class=\"nf\"test_z3_abstract_invert/spanspan class=\"p\"():/span\n    span class=\"n\"solver/spanspan class=\"p\",/span span class=\"n\"k1/spanspan class=\"p\",/span span class=\"n\"n1/spanspan class=\"p\",/span span class=\"n\"_/spanspan class=\"p\",/span span class=\"n\"_/span span class=\"o\"=/span span class=\"n\"z3_setup_variables/spanspan class=\"p\"()/span\n    span class=\"n\"k2/span span class=\"o\"=/span span class=\"n\"k1/spanspan class=\"o\"./spanspan class=\"n\"abstract_invert/spanspan class=\"p\"()/span\n    span class=\"n\"n2/span span class=\"o\"=/span span class=\"o\"~/spanspan class=\"n\"n1/span\n    span class=\"n\"prove/spanspan class=\"p\"(/spanspan class=\"n\"k2/spanspan class=\"o\"./spanspan class=\"n\"contains/spanspan class=\"p\"(/spanspan class=\"n\"n2/spanspan class=\"p\"),/span span class=\"n\"solver/spanspan class=\"p\")/span\n\nspan class=\"k\"def/span span class=\"nf\"test_z3_abstract_and/spanspan class=\"p\"():/span\n    span class=\"n\"solver/spanspan class=\"p\",/span span class=\"n\"k1/spanspan class=\"p\",/span span class=\"n\"n1/spanspan class=\"p\",/span span class=\"n\"k2/spanspan class=\"p\",/span span class=\"n\"n2/span span class=\"o\"=/span span class=\"n\"z3_setup_variables/spanspan class=\"p\"()/span\n    span class=\"n\"k3/span span class=\"o\"=/span span class=\"n\"k1/spanspan class=\"o\"./spanspan class=\"n\"abstract_and/spanspan class=\"p\"(/spanspan class=\"n\"k2/spanspan class=\"p\")/span\n    span class=\"n\"n3/span span class=\"o\"=/span span class=\"n\"n1/span span class=\"o\"amp;/span span class=\"n\"n2/span\n    span class=\"n\"prove/spanspan class=\"p\"(/spanspan class=\"n\"k3/spanspan class=\"o\"./spanspan class=\"n\"contains/spanspan class=\"p\"(/spanspan class=\"n\"n3/spanspan class=\"p\"),/span span class=\"n\"solver/spanspan class=\"p\")/span\n\nspan class=\"k\"def/span span class=\"nf\"test_z3_abstract_or/spanspan class=\"p\"():/span\n    span class=\"n\"solver/spanspan class=\"p\",/span span class=\"n\"k1/spanspan class=\"p\",/span span class=\"n\"n1/spanspan class=\"p\",/span span class=\"n\"k2/spanspan class=\"p\",/span span class=\"n\"n2/span span class=\"o\"=/span span class=\"n\"z3_setup_variables/spanspan class=\"p\"()/span\n    span class=\"n\"k3/span span class=\"o\"=/span span class=\"n\"k1/spanspan class=\"o\"./spanspan class=\"n\"abstract_or/spanspan class=\"p\"(/spanspan class=\"n\"k2/spanspan class=\"p\")/span\n    span class=\"n\"n3/span span class=\"o\"=/span span class=\"n\"n1/span span class=\"o\"|/span span class=\"n\"n2/span\n    span class=\"n\"prove/spanspan class=\"p\"(/spanspan class=\"n\"k3/spanspan class=\"o\"./spanspan class=\"n\"contains/spanspan class=\"p\"(/spanspan class=\"n\"n3/spanspan class=\"p\"),/span span class=\"n\"solver/spanspan class=\"p\")/span\n\nspan class=\"k\"def/span span class=\"nf\"test_z3_abstract_add/spanspan class=\"p\"():/span\n    span class=\"n\"solver/spanspan class=\"p\",/span span class=\"n\"k1/spanspan class=\"p\",/span span class=\"n\"n1/spanspan class=\"p\",/span span class=\"n\"k2/spanspan class=\"p\",/span span class=\"n\"n2/span span class=\"o\"=/span span class=\"n\"z3_setup_variables/spanspan class=\"p\"()/span\n    span class=\"n\"k3/span span class=\"o\"=/span span class=\"n\"k1/spanspan class=\"o\"./spanspan class=\"n\"abstract_add/spanspan class=\"p\"(/spanspan class=\"n\"k2/spanspan class=\"p\")/span\n    span class=\"n\"n3/span span class=\"o\"=/span span class=\"n\"n1/span span class=\"o\"+/span span class=\"n\"n2/span\n    span class=\"n\"prove/spanspan class=\"p\"(/spanspan class=\"n\"k3/spanspan class=\"o\"./spanspan class=\"n\"contains/spanspan class=\"p\"(/spanspan class=\"n\"n3/spanspan class=\"p\"),/span span class=\"n\"solver/spanspan class=\"p\")/span\n\nspan class=\"k\"def/span span class=\"nf\"test_z3_abstract_sub/spanspan class=\"p\"():/span\n    span class=\"n\"solver/spanspan class=\"p\",/span span class=\"n\"k1/spanspan class=\"p\",/span span class=\"n\"n1/spanspan class=\"p\",/span span class=\"n\"k2/spanspan class=\"p\",/span span class=\"n\"n2/span span class=\"o\"=/span span class=\"n\"z3_setup_variables/spanspan class=\"p\"()/span\n    span class=\"n\"k3/span span class=\"o\"=/span span class=\"n\"k1/spanspan class=\"o\"./spanspan class=\"n\"abstract_sub/spanspan class=\"p\"(/spanspan class=\"n\"k2/spanspan class=\"p\")/span\n    span class=\"n\"n3/span span class=\"o\"=/span span class=\"n\"n1/span span class=\"o\"-/span span class=\"n\"n2/span\n    span class=\"n\"prove/spanspan class=\"p\"(/spanspan class=\"n\"k3/spanspan class=\"o\"./spanspan class=\"n\"contains/spanspan class=\"p\"(/spanspan class=\"n\"n3/spanspan class=\"p\"),/span span class=\"n\"solver/spanspan class=\"p\")/span\n/pre/div\n\npIt's possible to write a bit more Python-metaprogramming-magic and unify the\nHypothesis and Z3 tests into the same test definition.sup id=\"fnref:proof_bitwidths\"a class=\"footnote-ref\" href=\"https://www.pypy.org/posts/2024/08/toy-knownbits.html#fn:proof_bitwidths\"1/a/sup/p\nh3 id=\"cases-where-this-style-of-z3-proof-doesnt-work\"Cases where this style of Z3 proof doesn't work/h3\npUnfortunately the approach described in the previous section only works for a\nvery small number of cases. It breaks down as soon as the codeKnownBits/code methods\nthat we're calling contain any codeif/code conditions (including hidden ones like\nthe short-circuiting codeand/code and codeor/code in Python). Let's look at an example and\nimplement codeabstract_eq/code. codeeq/code is supposed to be an operation that compares two\nintegers and returns code0/code or code1/code if they are different or equal, respectively.\nImplementing this in knownbits looks like this (with example and hypothesis\ntests):/p\ndiv class=\"code\"pre class=\"code literal-block\"span class=\"k\"class/span span class=\"nc\"KnownBits/spanspan class=\"p\":/span\n    span class=\"o\".../span\n\n    span class=\"k\"def/span span class=\"nf\"abstract_eq/spanspan class=\"p\"(/spanspan class=\"bp\"self/spanspan class=\"p\",/span span class=\"n\"other/spanspan class=\"p\"):/span\n        span class=\"c1\"# the result is a 0, 1, or ?/span\n\n        span class=\"c1\"# if they are both the same constant, they must be equal/span\n        span class=\"k\"if/span span class=\"bp\"self/spanspan class=\"o\"./spanspan class=\"n\"is_constant/spanspan class=\"p\"()/span span class=\"ow\"and/span span class=\"n\"other/spanspan class=\"o\"./spanspan class=\"n\"is_constant/spanspan class=\"p\"()/span span class=\"ow\"and/span span class=\"bp\"self/spanspan class=\"o\"./spanspan class=\"n\"ones/span span class=\"o\"==/span span class=\"n\"other/spanspan class=\"o\"./spanspan class=\"n\"ones/spanspan class=\"p\":/span\n            span class=\"k\"return/span span class=\"n\"KnownBits/spanspan class=\"o\"./spanspan class=\"n\"from_constant/spanspan class=\"p\"(/spanspan class=\"mi\"1/spanspan class=\"p\")/span\n        span class=\"c1\"# check whether we have known disagreeing bits, then we know the result/span\n        span class=\"c1\"# is 0/span\n        span class=\"k\"if/span span class=\"bp\"self/spanspan class=\"o\"./spanspan class=\"n\"_disagrees/spanspan class=\"p\"(/spanspan class=\"n\"other/spanspan class=\"p\"):/span\n            span class=\"k\"return/span span class=\"n\"KnownBits/spanspan class=\"o\"./spanspan class=\"n\"from_constant/spanspan class=\"p\"(/spanspan class=\"mi\"0/spanspan class=\"p\")/span\n        span class=\"k\"return/span span class=\"n\"KnownBits/spanspan class=\"p\"(/spanspan class=\"mi\"0/spanspan class=\"p\",/span span class=\"mi\"1/spanspan class=\"p\")/span span class=\"c1\"# an unknown boolean/span\n\n    span class=\"k\"def/span span class=\"nf\"_disagrees/spanspan class=\"p\"(/spanspan class=\"bp\"self/spanspan class=\"p\",/span span class=\"n\"other/spanspan class=\"p\"):/span\n        span class=\"c1\"# check whether the bits disagree in any place where both are known/span\n        span class=\"n\"both_known/span span class=\"o\"=/span span class=\"bp\"self/spanspan class=\"o\"./spanspan class=\"n\"knowns/span span class=\"o\"amp;/span span class=\"n\"other/spanspan class=\"o\"./spanspan class=\"n\"knowns/span\n        span class=\"k\"return/span span class=\"bp\"self/spanspan class=\"o\"./spanspan class=\"n\"ones/span span class=\"o\"amp;/span span class=\"n\"both_known/span span class=\"o\"!=/span span class=\"n\"other/spanspan class=\"o\"./spanspan class=\"n\"ones/span span class=\"o\"amp;/span span class=\"n\"both_known/span\n\nspan class=\"k\"def/span span class=\"nf\"test_eq/spanspan class=\"p\"():/span\n    span class=\"n\"k1/span span class=\"o\"=/span span class=\"n\"KnownBits/spanspan class=\"o\"./spanspan class=\"n\"from_str/spanspan class=\"p\"(/spanspan class=\"s1\"'...?'/spanspan class=\"p\")/span\n    span class=\"n\"k2/span span class=\"o\"=/span span class=\"n\"KnownBits/spanspan class=\"o\"./spanspan class=\"n\"from_str/spanspan class=\"p\"(/spanspan class=\"s1\"'...?'/spanspan class=\"p\")/span\n    span class=\"k\"assert/span span class=\"nb\"str/spanspan class=\"p\"(/spanspan class=\"n\"k1/spanspan class=\"o\"./spanspan class=\"n\"abstract_eq/spanspan class=\"p\"(/spanspan class=\"n\"k2/spanspan class=\"p\"))/span span class=\"o\"==/span span class=\"s1\"'?'/span\n    span class=\"n\"k1/span span class=\"o\"=/span span class=\"n\"KnownBits/spanspan class=\"o\"./spanspan class=\"n\"from_constant/spanspan class=\"p\"(/spanspan class=\"mi\"10/spanspan class=\"p\")/span\n    span class=\"k\"assert/span span class=\"nb\"str/spanspan class=\"p\"(/spanspan class=\"n\"k1/spanspan class=\"o\"./spanspan class=\"n\"abstract_eq/spanspan class=\"p\"(/spanspan class=\"n\"k1/spanspan class=\"p\"))/span span class=\"o\"==/span span class=\"s1\"'1'/span\n    span class=\"n\"k1/span span class=\"o\"=/span span class=\"n\"KnownBits/spanspan class=\"o\"./spanspan class=\"n\"from_constant/spanspan class=\"p\"(/spanspan class=\"mi\"10/spanspan class=\"p\")/span\n    span class=\"n\"k2/span span class=\"o\"=/span span class=\"n\"KnownBits/spanspan class=\"o\"./spanspan class=\"n\"from_constant/spanspan class=\"p\"(/spanspan class=\"mi\"20/spanspan class=\"p\")/span\n    span class=\"k\"assert/span span class=\"nb\"str/spanspan class=\"p\"(/spanspan class=\"n\"k1/spanspan class=\"o\"./spanspan class=\"n\"abstract_eq/spanspan class=\"p\"(/spanspan class=\"n\"k2/spanspan class=\"p\"))/span span class=\"o\"==/span span class=\"s1\"'0'/span\n\nspan class=\"nd\"@given/spanspan class=\"p\"(/spanspan class=\"n\"knownbits_and_contained_number/spanspan class=\"p\",/span span class=\"n\"knownbits_and_contained_number/spanspan class=\"p\")/span\nspan class=\"k\"def/span span class=\"nf\"test_hypothesis_eq/spanspan class=\"p\"(/spanspan class=\"n\"t1/spanspan class=\"p\",/span span class=\"n\"t2/spanspan class=\"p\"):/span\n    span class=\"n\"k1/spanspan class=\"p\",/span span class=\"n\"n1/span span class=\"o\"=/span span class=\"n\"t1/span\n    span class=\"n\"k2/spanspan class=\"p\",/span span class=\"n\"n2/span span class=\"o\"=/span span class=\"n\"t2/span\n    span class=\"n\"k3/span span class=\"o\"=/span span class=\"n\"k1/spanspan class=\"o\"./spanspan class=\"n\"abstract_eq/spanspan class=\"p\"(/spanspan class=\"n\"k2/spanspan class=\"p\")/span\n    span class=\"k\"assert/span span class=\"n\"k3/spanspan class=\"o\"./spanspan class=\"n\"contains/spanspan class=\"p\"(/spanspan class=\"nb\"int/spanspan class=\"p\"(/spanspan class=\"n\"n1/span span class=\"o\"==/span span class=\"n\"n2/spanspan class=\"p\"))/span\n/pre/div\n\npTrying to do the proof in the same style as before breaks:/p\ndiv class=\"code\"pre class=\"code literal-block\"span class=\"o\"gt;gt;gt;gt;/span span class=\"n\"k3/span span class=\"o\"=/span span class=\"n\"k1/spanspan class=\"o\"./spanspan class=\"n\"abstract_eq/spanspan class=\"p\"(/spanspan class=\"n\"k2/spanspan class=\"p\")/span\nspan class=\"n\"Traceback/span span class=\"p\"(/spanspan class=\"n\"most/span span class=\"n\"recent/span span class=\"n\"call/span span class=\"n\"last/spanspan class=\"p\"):/span\n  span class=\"n\"File/span span class=\"s2\"\"lt;stdingt;\"/spanspan class=\"p\",/span span class=\"n\"line/span span class=\"mi\"1/spanspan class=\"p\",/span span class=\"ow\"in/span span class=\"o\"lt;/spanspan class=\"n\"module/spanspan class=\"o\"gt;/span\n  span class=\"n\"File/span span class=\"s2\"\"knownbits.py\"/spanspan class=\"p\",/span span class=\"n\"line/span span class=\"mi\"246/spanspan class=\"p\",/span span class=\"ow\"in/span span class=\"n\"abstract_eq/span\n    span class=\"k\"if/span span class=\"bp\"self/spanspan class=\"o\"./spanspan class=\"n\"_disagrees/spanspan class=\"p\"(/spanspan class=\"n\"other/spanspan class=\"p\"):/span\n  span class=\"n\"File/span span class=\"s2\"\"venv/site-packages/z3/z3.py\"/spanspan class=\"p\",/span span class=\"n\"line/span span class=\"mi\"381/spanspan class=\"p\",/span span class=\"ow\"in/span span class=\"fm\"__bool__/span\n    span class=\"k\"raise/span span class=\"n\"Z3Exception/spanspan class=\"p\"(/spanspan class=\"s2\"\"Symbolic expressions cannot be cast to concrete Boolean values.\"/spanspan class=\"p\")/span\nspan class=\"n\"z3/spanspan class=\"o\"./spanspan class=\"n\"z3types/spanspan class=\"o\"./spanspan class=\"n\"Z3Exception/spanspan class=\"p\":/span span class=\"n\"Symbolic/span span class=\"n\"expressions/span span class=\"n\"cannot/span span class=\"n\"be/span span class=\"n\"cast/span span class=\"n\"to/span span class=\"n\"concrete/span span class=\"n\"Boolean/span span class=\"n\"values/spanspan class=\"o\"./span\n/pre/div\n\npWe cannot call codeabstract_eq/code on a codeKnownBits/code with Z3 variables as fields,\nbecause once we hit an codeif/code statement, the whole approach of relying on the\noperator overloading breaks down. Z3 doesn't actually parse the Python code or\nanything advanced like that, we rather build an expression only by running the\ncode and letting the Z3 formulas build up./p\npTo still prove the correctness of codeabstract_eq/code we need to manually transform\nthe control flow logic of the function into a Z3 formula that uses the codez3.If/code\nexpression, using a small helper function:/p\ndiv class=\"code\"pre class=\"code literal-block\"span class=\"k\"def/span span class=\"nf\"z3_cond/spanspan class=\"p\"(/spanspan class=\"n\"b/spanspan class=\"p\",/span span class=\"n\"trueval/spanspan class=\"o\"=/spanspan class=\"mi\"1/spanspan class=\"p\",/span span class=\"n\"falseval/spanspan class=\"o\"=/spanspan class=\"mi\"0/spanspan class=\"p\"):/span\n    span class=\"k\"return/span span class=\"n\"z3/spanspan class=\"o\"./spanspan class=\"n\"If/spanspan class=\"p\"(/spanspan class=\"n\"b/spanspan class=\"p\",/span span class=\"n\"BitVecVal/spanspan class=\"p\"(/spanspan class=\"n\"trueval/spanspan class=\"p\"),/span span class=\"n\"BitVecVal/spanspan class=\"p\"(/spanspan class=\"n\"falseval/spanspan class=\"p\"))/span\n\nspan class=\"k\"def/span span class=\"nf\"z3_abstract_eq/spanspan class=\"p\"(/spanspan class=\"n\"k1/spanspan class=\"p\",/span span class=\"n\"k2/spanspan class=\"p\"):/span\n    span class=\"c1\"# follow the *logic* of abstract_eq, we can't call it due to the ifs in it/span\n    span class=\"n\"case1cond/span span class=\"o\"=/span span class=\"n\"z3/spanspan class=\"o\"./spanspan class=\"n\"And/spanspan class=\"p\"(/spanspan class=\"n\"k1/spanspan class=\"o\"./spanspan class=\"n\"is_constant/spanspan class=\"p\"(),/span span class=\"n\"k2/spanspan class=\"o\"./spanspan class=\"n\"is_constant/spanspan class=\"p\"(),/span span class=\"n\"k1/spanspan class=\"o\"./spanspan class=\"n\"ones/span span class=\"o\"==/span span class=\"n\"k2/spanspan class=\"o\"./spanspan class=\"n\"ones/spanspan class=\"p\")/span\n    span class=\"n\"case2cond/span span class=\"o\"=/span span class=\"n\"k1/spanspan class=\"o\"./spanspan class=\"n\"_disagrees/spanspan class=\"p\"(/spanspan class=\"n\"k2/spanspan class=\"p\")/span\n\n    span class=\"c1\"# ones is 1 in the first case, 0 otherwise/span\n    span class=\"n\"ones/span span class=\"o\"=/span span class=\"n\"z3_cond/spanspan class=\"p\"(/spanspan class=\"n\"case1cond/spanspan class=\"p\",/span span class=\"mi\"1/spanspan class=\"p\",/span span class=\"mi\"0/spanspan class=\"p\")/span\n\n    span class=\"c1\"# in the first two cases, unknowns is 0, 1 otherwise/span\n    span class=\"n\"unknowns/span span class=\"o\"=/span span class=\"n\"z3_cond/spanspan class=\"p\"(/spanspan class=\"n\"z3/spanspan class=\"o\"./spanspan class=\"n\"Or/spanspan class=\"p\"(/spanspan class=\"n\"case1cond/spanspan class=\"p\",/span span class=\"n\"case2cond/spanspan class=\"p\"),/span span class=\"mi\"0/spanspan class=\"p\",/span span class=\"mi\"1/spanspan class=\"p\")/span\n    span class=\"k\"return/span span class=\"n\"KnownBits/spanspan class=\"p\"(/spanspan class=\"n\"ones/spanspan class=\"p\",/span span class=\"n\"unknowns/spanspan class=\"p\")/span\n\nspan class=\"k\"def/span span class=\"nf\"test_z3_abstract_eq_logic/spanspan class=\"p\"():/span\n    span class=\"n\"solver/spanspan class=\"p\",/span span class=\"n\"k1/spanspan class=\"p\",/span span class=\"n\"n1/spanspan class=\"p\",/span span class=\"n\"k2/spanspan class=\"p\",/span span class=\"n\"n2/span span class=\"o\"=/span span class=\"n\"z3_setup_variables/spanspan class=\"p\"()/span\n    span class=\"n\"n3/span span class=\"o\"=/span span class=\"n\"z3_cond/spanspan class=\"p\"(/spanspan class=\"n\"n1/span span class=\"o\"==/span span class=\"n\"n2/spanspan class=\"p\")/span span class=\"c1\"# concrete result/span\n    span class=\"n\"k3/span span class=\"o\"=/span span class=\"n\"z3_abstract_eq/spanspan class=\"p\"(/spanspan class=\"n\"k1/spanspan class=\"p\",/span span class=\"n\"k2/spanspan class=\"p\")/span\n    span class=\"n\"prove/spanspan class=\"p\"(/spanspan class=\"n\"k3/spanspan class=\"o\"./spanspan class=\"n\"contains/spanspan class=\"p\"(/spanspan class=\"n\"n3/spanspan class=\"p\"),/span span class=\"n\"solver/spanspan class=\"p\")/span\n/pre/div\n\npThis proof works. It is a lot less satisfying than the previous ones though,\nbecause we could have done an error in the manual transcription from Python code\nto Z3 formulas (there are possibly more heavy-handed approaches where we do\nthis transformation more automatically using e.g. the codeast/code module to analyze\nthe source code, but that's a much more complicated researchy project). To\nlessen this problem somewhat we can factor out the parts of the logic that don't\nhave any conditions into small helper methods (like code_disagrees/code in this\nexample) and use them in the manual conversion of the code to Z3 formulas.sup id=\"fnref:tests_vs_proofs\"a class=\"footnote-ref\" href=\"https://www.pypy.org/posts/2024/08/toy-knownbits.html#fn:tests_vs_proofs\"2/a/sup/p\npThe final condition that Z3 checks, btw, is this one:/p\ndiv class=\"code\"pre class=\"code literal-block\"If(n1 == n2, 1, 0) amp;\n~If(Or(And(n1_unkowns == 0,\n           n2_unkowns == 0,\n           n1_ones == n2_ones),\n       n1_ones amp; ~n1_unkowns amp; ~n2_unkowns !=\n       n2_ones amp; ~n1_unkowns amp; ~n2_unkowns),\n    0, 1) ==\nIf(And(n1_unkowns == 0, n2_unkowns == 0, n1_ones == n2_ones),\n   1, 0)\n/pre/div\n\nh3 id=\"making-statements-about-precision\"Making Statements about Precision/h3\npSo far we have only used Z3 to prove statements about correctness, i.e. that\nour abstract operations overapproximate what can happen with concrete values.\nWhile proving this property is essential if we want to avoid miscompilation,\ncorrectness alone is not a very strong constraint on the implementation of our\nabstract transfer functions. We could simply return codeKnownbits.unknowns()/code for\nevery codeabstract_*/code method and the resulting overapproximation would be correct,\nbut useless in practice./p\npIt's much harder to make statements about whether the transfer functions are\nmaximally precise. There are two aspects of precision I want to discuss in this\nsection, however./p\npThe first aspect is that we would really like it if the transfer functions\ncompute the maximally precise results for singleton sets. If all abstract\narguments of an operations are constants, i.e. contain only a single concrete\nelement, then we know that the resulting set also has only a single element. We\ncan prove that all our transfer functions have this property:/p\ndiv class=\"code\"pre class=\"code literal-block\"span class=\"k\"def/span span class=\"nf\"test_z3_prove_constant_folding/spanspan class=\"p\"():/span\n    span class=\"n\"solver/spanspan class=\"p\",/span span class=\"n\"k1/spanspan class=\"p\",/span span class=\"n\"n1/spanspan class=\"p\",/span span class=\"n\"k2/spanspan class=\"p\",/span span class=\"n\"n2/span span class=\"o\"=/span span class=\"n\"z3_setup_variables/spanspan class=\"p\"()/span\n    span class=\"n\"k3/span span class=\"o\"=/span span class=\"n\"k1/spanspan class=\"o\"./spanspan class=\"n\"abstract_invert/spanspan class=\"p\"()/span\n    span class=\"n\"prove/spanspan class=\"p\"(/spanspan class=\"n\"z3/spanspan class=\"o\"./spanspan class=\"n\"Implies/spanspan class=\"p\"(/spanspan class=\"n\"k1/spanspan class=\"o\"./spanspan class=\"n\"is_constant/spanspan class=\"p\"(),/span\n                     span class=\"n\"k3/spanspan class=\"o\"./spanspan class=\"n\"is_constant/spanspan class=\"p\"()),/span span class=\"n\"solver/spanspan class=\"p\")/span\n\n    span class=\"n\"k3/span span class=\"o\"=/span span class=\"n\"k1/spanspan class=\"o\"./spanspan class=\"n\"abstract_and/spanspan class=\"p\"(/spanspan class=\"n\"k2/spanspan class=\"p\")/span\n    span class=\"n\"prove/spanspan class=\"p\"(/spanspan class=\"n\"z3/spanspan class=\"o\"./spanspan class=\"n\"Implies/spanspan class=\"p\"(/spanspan class=\"n\"z3/spanspan class=\"o\"./spanspan class=\"n\"And/spanspan class=\"p\"(/spanspan class=\"n\"k1/spanspan class=\"o\"./spanspan class=\"n\"is_constant/spanspan class=\"p\"(),/span span class=\"n\"k2/spanspan class=\"o\"./spanspan class=\"n\"is_constant/spanspan class=\"p\"()),/span\n                     span class=\"n\"k3/spanspan class=\"o\"./spanspan class=\"n\"is_constant/spanspan class=\"p\"()),/span span class=\"n\"solver/spanspan class=\"p\")/span\n\n    span class=\"n\"k3/span span class=\"o\"=/span span class=\"n\"k1/spanspan class=\"o\"./spanspan class=\"n\"abstract_or/spanspan class=\"p\"(/spanspan class=\"n\"k2/spanspan class=\"p\")/span\n    span class=\"n\"prove/spanspan class=\"p\"(/spanspan class=\"n\"z3/spanspan class=\"o\"./spanspan class=\"n\"Implies/spanspan class=\"p\"(/spanspan class=\"n\"z3/spanspan class=\"o\"./spanspan class=\"n\"And/spanspan class=\"p\"(/spanspan class=\"n\"k1/spanspan class=\"o\"./spanspan class=\"n\"is_constant/spanspan class=\"p\"(),/span span class=\"n\"k2/spanspan class=\"o\"./spanspan class=\"n\"is_constant/spanspan class=\"p\"()),/span\n                     span class=\"n\"k3/spanspan class=\"o\"./spanspan class=\"n\"is_constant/spanspan class=\"p\"()),/span span class=\"n\"solver/spanspan class=\"p\")/span\n\n    span class=\"n\"k3/span span class=\"o\"=/span span class=\"n\"k1/spanspan class=\"o\"./spanspan class=\"n\"abstract_sub/spanspan class=\"p\"(/spanspan class=\"n\"k2/spanspan class=\"p\")/span\n    span class=\"n\"prove/spanspan class=\"p\"(/spanspan class=\"n\"z3/spanspan class=\"o\"./spanspan class=\"n\"Implies/spanspan class=\"p\"(/spanspan class=\"n\"z3/spanspan class=\"o\"./spanspan class=\"n\"And/spanspan class=\"p\"(/spanspan class=\"n\"k1/spanspan class=\"o\"./spanspan class=\"n\"is_constant/spanspan class=\"p\"(),/span span class=\"n\"k2/spanspan class=\"o\"./spanspan class=\"n\"is_constant/spanspan class=\"p\"()),/span\n                     span class=\"n\"k3/spanspan class=\"o\"./spanspan class=\"n\"is_constant/spanspan class=\"p\"()),/span span class=\"n\"solver/spanspan class=\"p\")/span\n\n    span class=\"n\"k3/span span class=\"o\"=/span span class=\"n\"z3_abstract_eq/spanspan class=\"p\"(/spanspan class=\"n\"k1/spanspan class=\"p\",/span span class=\"n\"k2/spanspan class=\"p\")/span\n    span class=\"n\"prove/spanspan class=\"p\"(/spanspan class=\"n\"z3/spanspan class=\"o\"./spanspan class=\"n\"Implies/spanspan class=\"p\"(/spanspan class=\"n\"z3/spanspan class=\"o\"./spanspan class=\"n\"And/spanspan class=\"p\"(/spanspan class=\"n\"k1/spanspan class=\"o\"./spanspan class=\"n\"is_constant/spanspan class=\"p\"(),/span span class=\"n\"k2/spanspan class=\"o\"./spanspan class=\"n\"is_constant/spanspan class=\"p\"()),/span\n                     span class=\"n\"k3/spanspan class=\"o\"./spanspan class=\"n\"is_constant/spanspan class=\"p\"()),/span span class=\"n\"solver/spanspan class=\"p\")/span\n/pre/div\n\npProving with Z3 that the transfer functions are maximally precise for\nnon-constant arguments seems to be relatively hard. I tried a few completely\nrigorous approaches and failed. The paper a href=\"https://arxiv.org/pdf/2105.05398\"Sound, Precise, and Fast Abstract\nInterpretation with Tristate Numbers/a\ncontains an optimality proof for the transfer functions of addition and\nsubtraction, so we can be certain that they are as precise as is\npossible./p\npI still want to show an approach for trying to find concrete examples of\nabstract values that are less precise than they could be, using a combination\nof Hypothesis and Z3. The idea is to use hypothesis to pick random abstract\nvalues. Then we compute the abstract result using our transfer function.\nAfterwards we can ask Z3 to find us an abstract result that is better than the\none our transfer function produced. If Z3 finds a better abstract result, we\nhave a concrete example of imprecision for our transfer function. Those tests\naren't strict proofs, because they rely on generating random abstract values,\nbut they can still be valuable (not for the transfer functions in this blog\npost, which are all optimal)./p\npHere is what the code looks like (this is a little bit bonus content, I'll not\nexplain the details and can only hope that the comments are somewhat helpful):/p\ndiv class=\"code\"pre class=\"code literal-block\"span class=\"nd\"@given/spanspan class=\"p\"(/spanspan class=\"n\"random_knownbits_and_contained_number/spanspan class=\"p\",/span span class=\"n\"random_knownbits_and_contained_number/spanspan class=\"p\")/span\nspan class=\"nd\"@settings/spanspan class=\"p\"(/spanspan class=\"n\"deadline/spanspan class=\"o\"=/spanspan class=\"kc\"None/spanspan class=\"p\")/span\nspan class=\"k\"def/span span class=\"nf\"test_check_precision/spanspan class=\"p\"(/spanspan class=\"n\"t1/spanspan class=\"p\",/span span class=\"n\"t2/spanspan class=\"p\"):/span\n    span class=\"n\"k1/spanspan class=\"p\",/span span class=\"n\"n1/span span class=\"o\"=/span span class=\"n\"t1/span\n    span class=\"n\"k2/spanspan class=\"p\",/span span class=\"n\"n2/span span class=\"o\"=/span span class=\"n\"t2/span\n    span class=\"c1\"# apply transfer function/span\n    span class=\"n\"k3/span span class=\"o\"=/span span class=\"n\"k1/spanspan class=\"o\"./spanspan class=\"n\"abstract_add/spanspan class=\"p\"(/spanspan class=\"n\"k2/spanspan class=\"p\")/span\n    span class=\"n\"example_res/span span class=\"o\"=/span span class=\"n\"n1/span span class=\"o\"+/span span class=\"n\"n2/span\n\n    span class=\"c1\"# try to find a better version of k3 with Z3/span\n    span class=\"n\"solver/span span class=\"o\"=/span span class=\"n\"z3/spanspan class=\"o\"./spanspan class=\"n\"Solver/spanspan class=\"p\"()/span\n    span class=\"n\"solver/spanspan class=\"o\"./spanspan class=\"n\"set/spanspan class=\"p\"(/spanspan class=\"s2\"\"timeout\"/spanspan class=\"p\",/span span class=\"mi\"8000/spanspan class=\"p\")/span\n\n    span class=\"n\"var1/span span class=\"o\"=/span span class=\"n\"BitVec/spanspan class=\"p\"(/spanspan class=\"s1\"'v1'/spanspan class=\"p\")/span\n    span class=\"n\"var2/span span class=\"o\"=/span span class=\"n\"BitVec/spanspan class=\"p\"(/spanspan class=\"s1\"'v2'/spanspan class=\"p\")/span\n\n    span class=\"n\"ones/span span class=\"o\"=/span span class=\"n\"BitVec/spanspan class=\"p\"(/spanspan class=\"s1\"'ones'/spanspan class=\"p\")/span\n    span class=\"n\"unknowns/span span class=\"o\"=/span span class=\"n\"BitVec/spanspan class=\"p\"(/spanspan class=\"s1\"'unknowns'/spanspan class=\"p\")/span\n    span class=\"n\"better_k3/span span class=\"o\"=/span span class=\"n\"KnownBits/spanspan class=\"p\"(/spanspan class=\"n\"ones/spanspan class=\"p\",/span span class=\"n\"unknowns/spanspan class=\"p\")/span\n    span class=\"nb\"print/spanspan class=\"p\"(/spanspan class=\"n\"k1/spanspan class=\"p\",/span span class=\"n\"k2/spanspan class=\"p\",/span span class=\"n\"k3/spanspan class=\"p\")/span\n\n    span class=\"c1\"# we're trying to find an example for a better k3, so we use check, without/span\n    span class=\"c1\"# negation:/span\n    span class=\"n\"res/span span class=\"o\"=/span span class=\"n\"solver/spanspan class=\"o\"./spanspan class=\"n\"check/spanspan class=\"p\"(/spanspan class=\"n\"z3/spanspan class=\"o\"./spanspan class=\"n\"And/spanspan class=\"p\"(/span\n        span class=\"c1\"# better_k3 should be a valid knownbits instance/span\n        span class=\"n\"better_k3/spanspan class=\"o\"./spanspan class=\"n\"is_well_formed/spanspan class=\"p\"(),/span\n        span class=\"c1\"# it should be better than k3, ie there are known bits in better_k3/span\n        span class=\"c1\"# that we don't have in k3/span\n        span class=\"n\"better_k3/spanspan class=\"o\"./spanspan class=\"n\"knowns/span span class=\"o\"amp;/span span class=\"o\"~/spanspan class=\"n\"k3/spanspan class=\"o\"./spanspan class=\"n\"knowns/span span class=\"o\"!=/span span class=\"mi\"0/spanspan class=\"p\",/span\n        span class=\"c1\"# now encode the correctness condition for better_k3 with a ForAll:/span\n        span class=\"c1\"# for all concrete values var1 and var2, it must hold that if/span\n        span class=\"c1\"# var1 is in k1 and var2 is in k2 it follows that var1 + var2 is in/span\n        span class=\"c1\"# better_k3/span\n        span class=\"n\"z3/spanspan class=\"o\"./spanspan class=\"n\"ForAll/spanspan class=\"p\"(/span\n        span class=\"p\"[/spanspan class=\"n\"var1/spanspan class=\"p\",/span span class=\"n\"var2/spanspan class=\"p\"],/span\n        span class=\"n\"z3/spanspan class=\"o\"./spanspan class=\"n\"Implies/spanspan class=\"p\"(/span\n            span class=\"n\"z3/spanspan class=\"o\"./spanspan class=\"n\"And/spanspan class=\"p\"(/spanspan class=\"n\"k1/spanspan class=\"o\"./spanspan class=\"n\"contains/spanspan class=\"p\"(/spanspan class=\"n\"var1/spanspan class=\"p\"),/span span class=\"n\"k2/spanspan class=\"o\"./spanspan class=\"n\"contains/spanspan class=\"p\"(/spanspan class=\"n\"var2/spanspan class=\"p\")),/span\n            span class=\"n\"better_k3/spanspan class=\"o\"./spanspan class=\"n\"contains/spanspan class=\"p\"(/spanspan class=\"n\"var1/span span class=\"o\"+/span span class=\"n\"var2/spanspan class=\"p\")))))/span\n    span class=\"c1\"# if this query is satisfiable, we have found a better result for the/span\n    span class=\"c1\"# abstract_add/span\n    span class=\"k\"if/span span class=\"n\"res/span span class=\"o\"==/span span class=\"n\"z3/spanspan class=\"o\"./spanspan class=\"n\"sat/spanspan class=\"p\":/span\n        span class=\"n\"model/span span class=\"o\"=/span span class=\"n\"solver/spanspan class=\"o\"./spanspan class=\"n\"model/spanspan class=\"p\"()/span\n        span class=\"n\"rk3/span span class=\"o\"=/span span class=\"n\"KnownBits/spanspan class=\"p\"(/spanspan class=\"n\"model/spanspan class=\"o\"./spanspan class=\"n\"eval/spanspan class=\"p\"(/spanspan class=\"n\"ones/spanspan class=\"p\")/spanspan class=\"o\"./spanspan class=\"n\"as_signed_long/spanspan class=\"p\"(),/span span class=\"n\"model/spanspan class=\"o\"./spanspan class=\"n\"eval/spanspan class=\"p\"(/spanspan class=\"n\"unknowns/spanspan class=\"p\")/spanspan class=\"o\"./spanspan class=\"n\"as_signed_long/spanspan class=\"p\"())/span\n        span class=\"nb\"print/spanspan class=\"p\"(/spanspan class=\"s2\"\"better\"/spanspan class=\"p\",/span span class=\"n\"rk3/spanspan class=\"p\")/span\n        span class=\"k\"assert/span span class=\"mi\"0/span\n    span class=\"k\"if/span span class=\"n\"res/span span class=\"o\"==/span span class=\"n\"z3/spanspan class=\"o\"./spanspan class=\"n\"unknown/spanspan class=\"p\":/span\n        span class=\"nb\"print/spanspan class=\"p\"(/spanspan class=\"s2\"\"timeout\"/spanspan class=\"p\")/span\n/pre/div\n\npIt does not actually fail for codeabstract_add/code (nor the other abstract\nfunctions). To see the test failing we can add some imprecision to the\nimplementation of codeabstract_add/code to see Hypothesis and Z3 find examples of\nvalues that are not optimally precise (for example by setting some bits\nof codeunknowns/code in the implementation of codeabstract_add/code unconditionally)./p\nh3 id=\"using-the-abstract-domain-in-the-toy-optimizer-for-generalized-constant-folding\"Using the Abstract Domain in the Toy Optimizer for Generalized Constant Folding/h3\npNow after all this work we can finally actually use the knownbits abstract\ndomain in the toy optimizer. The code for this follows a href=\"https://bernsteinbear.com/blog/toy-abstract-interpretation/\"Max' intro post about\nabstract interpretation/a\nquite closely./p\npFor completeness sake, in the fold there's the basic infrastructure classes\nthat make up the IR again (they are identical or at least extremely close to\nthe previous toy posts)./p\ndetails\nsummarytoy infrastructure/summary\n\ndiv class=\"code\"pre class=\"code literal-block\"span class=\"k\"class/span span class=\"nc\"Value/spanspan class=\"p\":/span\n    span class=\"k\"def/span span class=\"nf\"find/spanspan class=\"p\"(/spanspan class=\"bp\"self/spanspan class=\"p\"):/span\n        span class=\"k\"raise/span span class=\"ne\"NotImplementedError/spanspan class=\"p\"(/spanspan class=\"s2\"\"abstract\"/spanspan class=\"p\")/span\n\n\nspan class=\"nd\"@dataclass/spanspan class=\"p\"(/spanspan class=\"n\"eq/spanspan class=\"o\"=/spanspan class=\"kc\"False/spanspan class=\"p\")/span\nspan class=\"k\"class/span span class=\"nc\"Operation/spanspan class=\"p\"(/spanspan class=\"n\"Value/spanspan class=\"p\"):/span\n    span class=\"n\"name/span span class=\"p\":/span span class=\"nb\"str/span\n    span class=\"n\"args/span span class=\"p\":/span span class=\"nb\"list/spanspan class=\"p\"[/spanspan class=\"n\"Value/spanspan class=\"p\"]/span\n\n    span class=\"n\"forwarded/span span class=\"p\":/span span class=\"n\"Optional/spanspan class=\"p\"[/spanspan class=\"n\"Value/spanspan class=\"p\"]/span span class=\"o\"=/span span class=\"kc\"None/span\n\n    span class=\"k\"def/span span class=\"nf\"find/spanspan class=\"p\"(/spanspan class=\"bp\"self/spanspan class=\"p\")/span span class=\"o\"-gt;/span span class=\"n\"Value/spanspan class=\"p\":/span\n        span class=\"n\"op/span span class=\"o\"=/span span class=\"bp\"self/span\n        span class=\"k\"while/span span class=\"nb\"isinstance/spanspan class=\"p\"(/spanspan class=\"n\"op/spanspan class=\"p\",/span span class=\"n\"Operation/spanspan class=\"p\"):/span\n            span class=\"nb\"next/span span class=\"o\"=/span span class=\"n\"op/spanspan class=\"o\"./spanspan class=\"n\"forwarded/span\n            span class=\"k\"if/span span class=\"nb\"next/span span class=\"ow\"is/span span class=\"kc\"None/spanspan class=\"p\":/span\n                span class=\"k\"return/span span class=\"n\"op/span\n            span class=\"n\"op/span span class=\"o\"=/span span class=\"nb\"next/span\n        span class=\"k\"return/span span class=\"n\"op/span\n\n    span class=\"k\"def/span span class=\"nf\"arg/spanspan class=\"p\"(/spanspan class=\"bp\"self/spanspan class=\"p\",/span span class=\"n\"index/spanspan class=\"p\"):/span\n        span class=\"k\"return/span span class=\"bp\"self/spanspan class=\"o\"./spanspan class=\"n\"args/spanspan class=\"p\"[/spanspan class=\"n\"index/spanspan class=\"p\"]/spanspan class=\"o\"./spanspan class=\"n\"find/spanspan class=\"p\"()/span\n\n    span class=\"k\"def/span span class=\"nf\"make_equal_to/spanspan class=\"p\"(/spanspan class=\"bp\"self/spanspan class=\"p\",/span span class=\"n\"value/span span class=\"p\":/span span class=\"n\"Value/spanspan class=\"p\"):/span\n        span class=\"bp\"self/spanspan class=\"o\"./spanspan class=\"n\"find/spanspan class=\"p\"()/spanspan class=\"o\"./spanspan class=\"n\"forwarded/span span class=\"o\"=/span span class=\"n\"value/span\n\n\nspan class=\"nd\"@dataclass/spanspan class=\"p\"(/spanspan class=\"n\"eq/spanspan class=\"o\"=/spanspan class=\"kc\"False/spanspan class=\"p\")/span\nspan class=\"k\"class/span span class=\"nc\"Constant/spanspan class=\"p\"(/spanspan class=\"n\"Value/spanspan class=\"p\"):/span\n    span class=\"n\"value/span span class=\"p\":/span span class=\"nb\"object/span\n\n    span class=\"k\"def/span span class=\"nf\"find/spanspan class=\"p\"(/spanspan class=\"bp\"self/spanspan class=\"p\"):/span\n        span class=\"k\"return/span span class=\"bp\"self/span\n\n\nspan class=\"k\"class/span span class=\"nc\"Block/spanspan class=\"p\"(/spanspan class=\"nb\"list/spanspan class=\"p\"):/span\n    span class=\"k\"def/span span class=\"fm\"__getattr__/spanspan class=\"p\"(/spanspan class=\"bp\"self/spanspan class=\"p\",/span span class=\"n\"opname/spanspan class=\"p\"):/span\n        span class=\"k\"def/span span class=\"nf\"wraparg/spanspan class=\"p\"(/spanspan class=\"n\"arg/spanspan class=\"p\"):/span\n            span class=\"k\"if/span span class=\"ow\"not/span span class=\"nb\"isinstance/spanspan class=\"p\"(/spanspan class=\"n\"arg/spanspan class=\"p\",/span span class=\"n\"Value/spanspan class=\"p\"):/span\n                span class=\"n\"arg/span span class=\"o\"=/span span class=\"n\"Constant/spanspan class=\"p\"(/spanspan class=\"n\"arg/spanspan class=\"p\")/span\n            span class=\"k\"return/span span class=\"n\"arg/span\n        span class=\"k\"def/span span class=\"nf\"make_op/spanspan class=\"p\"(/spanspan class=\"o\"*/spanspan class=\"n\"args/spanspan class=\"p\"):/span\n            span class=\"n\"op/span span class=\"o\"=/span span class=\"n\"Operation/spanspan class=\"p\"(/spanspan class=\"n\"opname/spanspan class=\"p\",/span\n                span class=\"p\"[/spanspan class=\"n\"wraparg/spanspan class=\"p\"(/spanspan class=\"n\"arg/spanspan class=\"p\")/span span class=\"k\"for/span span class=\"n\"arg/span span class=\"ow\"in/span span class=\"n\"args/spanspan class=\"p\"])/span\n            span class=\"bp\"self/spanspan class=\"o\"./spanspan class=\"n\"append/spanspan class=\"p\"(/spanspan class=\"n\"op/spanspan class=\"p\")/span\n            span class=\"k\"return/span span class=\"n\"op/span\n        span class=\"k\"return/span span class=\"n\"make_op/span\n\n\nspan class=\"k\"def/span span class=\"nf\"bb_to_str/spanspan class=\"p\"(/spanspan class=\"n\"l/span span class=\"p\":/span span class=\"n\"Block/spanspan class=\"p\",/span span class=\"n\"varprefix/span span class=\"p\":/span span class=\"nb\"str/span span class=\"o\"=/span span class=\"s2\"\"var\"/spanspan class=\"p\"):/span\n    span class=\"k\"def/span span class=\"nf\"arg_to_str/spanspan class=\"p\"(/spanspan class=\"n\"arg/span span class=\"p\":/span span class=\"n\"Value/spanspan class=\"p\"):/span\n        span class=\"k\"if/span span class=\"nb\"isinstance/spanspan class=\"p\"(/spanspan class=\"n\"arg/spanspan class=\"p\",/span span class=\"n\"Constant/spanspan class=\"p\"):/span\n            span class=\"k\"return/span span class=\"nb\"str/spanspan class=\"p\"(/spanspan class=\"n\"arg/spanspan class=\"o\"./spanspan class=\"n\"value/spanspan class=\"p\")/span\n        span class=\"k\"else/spanspan class=\"p\":/span\n            span class=\"k\"return/span span class=\"n\"varnames/spanspan class=\"p\"[/spanspan class=\"n\"arg/spanspan class=\"p\"]/span\n\n    span class=\"n\"varnames/span span class=\"o\"=/span span class=\"p\"{}/span\n    span class=\"n\"res/span span class=\"o\"=/span span class=\"p\"[]/span\n    span class=\"k\"for/span span class=\"n\"index/spanspan class=\"p\",/span span class=\"n\"op/span span class=\"ow\"in/span span class=\"nb\"enumerate/spanspan class=\"p\"(/spanspan class=\"n\"l/spanspan class=\"p\"):/span\n        span class=\"c1\"# give the operation a name used while/span\n        span class=\"c1\"# printing:/span\n        span class=\"n\"var/span span class=\"o\"=/span  span class=\"sa\"f/spanspan class=\"s2\"\"/spanspan class=\"si\"{/spanspan class=\"n\"varprefix/spanspan class=\"si\"}{/spanspan class=\"n\"index/spanspan class=\"si\"}/spanspan class=\"s2\"\"/span\n        span class=\"n\"varnames/spanspan class=\"p\"[/spanspan class=\"n\"op/spanspan class=\"p\"]/span span class=\"o\"=/span span class=\"n\"var/span\n        span class=\"n\"arguments/span span class=\"o\"=/span span class=\"s2\"\", \"/spanspan class=\"o\"./spanspan class=\"n\"join/spanspan class=\"p\"(/span\n            span class=\"n\"arg_to_str/spanspan class=\"p\"(/spanspan class=\"n\"op/spanspan class=\"o\"./spanspan class=\"n\"arg/spanspan class=\"p\"(/spanspan class=\"n\"i/spanspan class=\"p\"))/span\n                span class=\"k\"for/span span class=\"n\"i/span span class=\"ow\"in/span span class=\"nb\"range/spanspan class=\"p\"(/spanspan class=\"nb\"len/spanspan class=\"p\"(/spanspan class=\"n\"op/spanspan class=\"o\"./spanspan class=\"n\"args/spanspan class=\"p\"))/span\n        span class=\"p\")/span\n        span class=\"n\"strop/span span class=\"o\"=/span span class=\"sa\"f/spanspan class=\"s2\"\"/spanspan class=\"si\"{/spanspan class=\"n\"var/spanspan class=\"si\"}/spanspan class=\"s2\" = /spanspan class=\"si\"{/spanspan class=\"n\"op/spanspan class=\"o\"./spanspan class=\"n\"name/spanspan class=\"si\"}/spanspan class=\"s2\"(/spanspan class=\"si\"{/spanspan class=\"n\"arguments/spanspan class=\"si\"}/spanspan class=\"s2\")\"/span\n        span class=\"n\"res/spanspan class=\"o\"./spanspan class=\"n\"append/spanspan class=\"p\"(/spanspan class=\"n\"strop/spanspan class=\"p\")/span\n    span class=\"k\"return/span span class=\"s2\"\"/spanspan class=\"se\"\\n/spanspan class=\"s2\"\"/spanspan class=\"o\"./spanspan class=\"n\"join/spanspan class=\"p\"(/spanspan class=\"n\"res/spanspan class=\"p\")/span\n/pre/div\n\n\n\n/details\n\npNow we can write some first tests, the first one simply checking constant\nfolding:/p\ndiv class=\"code\"pre class=\"code literal-block\"span class=\"k\"def/span span class=\"nf\"test_constfold_two_ops/spanspan class=\"p\"():/span\n    span class=\"n\"bb/span span class=\"o\"=/span span class=\"n\"Block/spanspan class=\"p\"()/span\n    span class=\"n\"var0/span span class=\"o\"=/span span class=\"n\"bb/spanspan class=\"o\"./spanspan class=\"n\"getarg/spanspan class=\"p\"(/spanspan class=\"mi\"0/spanspan class=\"p\")/span\n    span class=\"n\"var1/span span class=\"o\"=/span span class=\"n\"bb/spanspan class=\"o\"./spanspan class=\"n\"int_add/spanspan class=\"p\"(/spanspan class=\"mi\"5/spanspan class=\"p\",/span span class=\"mi\"4/spanspan class=\"p\")/span\n    span class=\"n\"var2/span span class=\"o\"=/span span class=\"n\"bb/spanspan class=\"o\"./spanspan class=\"n\"int_add/spanspan class=\"p\"(/spanspan class=\"n\"var1/spanspan class=\"p\",/span span class=\"mi\"10/spanspan class=\"p\")/span\n    span class=\"n\"var3/span span class=\"o\"=/span span class=\"n\"bb/spanspan class=\"o\"./spanspan class=\"n\"int_add/spanspan class=\"p\"(/spanspan class=\"n\"var2/spanspan class=\"p\",/span span class=\"n\"var0/spanspan class=\"p\")/span\n\n    span class=\"n\"opt_bb/span span class=\"o\"=/span span class=\"n\"simplify/spanspan class=\"p\"(/spanspan class=\"n\"bb/spanspan class=\"p\")/span\n    span class=\"k\"assert/span span class=\"n\"bb_to_str/spanspan class=\"p\"(/spanspan class=\"n\"opt_bb/spanspan class=\"p\",/span span class=\"s2\"\"optvar\"/spanspan class=\"p\")/span span class=\"o\"==/span span class=\"s2\"\"\"\"/spanspan class=\"se\"\\/span\nspan class=\"s2\"optvar0 = getarg(0)/span\nspan class=\"s2\"optvar1 = int_add(19, optvar0)\"\"\"/span\n/pre/div\n\npCalling the transfer functions on constant codeKnownBits/code produces a constant\nresults, as we have seen. Therefore \"regular\" constant folding should hopefully\nbe achieved by optimizing with the codeKnownBits/code abstract domain too./p\npThe next two tests are slightly more complicated and can't be optimized by\nregular constant-folding. They follow the motivating examples from the start of\nthis blog post, a hundred years ago:/p\ndiv class=\"code\"pre class=\"code literal-block\"span class=\"n\"def/spanspan class=\"w\" /spanspan class=\"n\"test_constfold_via_knownbits/spanspan class=\"p\"():/span\nspan class=\"w\"    /spanspan class=\"n\"bb/spanspan class=\"w\" /spanspan class=\"o\"=/spanspan class=\"w\" /spanspan class=\"n\"Block/spanspan class=\"p\"()/span\nspan class=\"w\"    /spanspan class=\"n\"var0/spanspan class=\"w\" /spanspan class=\"o\"=/spanspan class=\"w\" /spanspan class=\"n\"bb/spanspan class=\"o\"./spanspan class=\"n\"getarg/spanspan class=\"p\"(/spanspan class=\"mi\"0/spanspan class=\"p\")/span\nspan class=\"w\"    /spanspan class=\"n\"var1/spanspan class=\"w\" /spanspan class=\"o\"=/spanspan class=\"w\" /spanspan class=\"n\"bb/spanspan class=\"o\"./spanspan class=\"n\"int_or/spanspan class=\"p\"(/spanspan class=\"n\"var0/spanspan class=\"p\",/spanspan class=\"w\" /spanspan class=\"mi\"1/spanspan class=\"p\")/span\nspan class=\"w\"    /spanspan class=\"n\"var2/spanspan class=\"w\" /spanspan class=\"o\"=/spanspan class=\"w\" /spanspan class=\"n\"bb/spanspan class=\"o\"./spanspan class=\"n\"int_and/spanspan class=\"p\"(/spanspan class=\"n\"var1/spanspan class=\"p\",/spanspan class=\"w\" /spanspan class=\"mi\"1/spanspan class=\"p\")/span\nspan class=\"w\"    /spanspan class=\"n\"var3/spanspan class=\"w\" /spanspan class=\"o\"=/spanspan class=\"w\" /spanspan class=\"n\"bb/spanspan class=\"o\"./spanspan class=\"n\"dummy/spanspan class=\"p\"(/spanspan class=\"n\"var2/spanspan class=\"p\")/span\n\nspan class=\"w\"    /spanspan class=\"n\"opt_bb/spanspan class=\"w\" /spanspan class=\"o\"=/spanspan class=\"w\" /spanspan class=\"n\"simplify/spanspan class=\"p\"(/spanspan class=\"n\"bb/spanspan class=\"p\")/span\nspan class=\"w\"    /spanspan class=\"nb\"assert/spanspan class=\"w\" /spanspan class=\"n\"bb_to_str/spanspan class=\"p\"(/spanspan class=\"n\"opt_bb/spanspan class=\"p\",/spanspan class=\"w\" /spanspan class=\"s2\"\"optvar\"/spanspan class=\"p\")/spanspan class=\"w\" /spanspan class=\"o\"==/spanspan class=\"w\" /spanspan class=\"s2\"\"\"\"/spanspan class=\"se\"\\/span\nspan class=\"s2\"optvar0 = getarg(0)/span\nspan class=\"s2\"optvar1 = int_or(optvar0, 1)/span\nspan class=\"s2\"optvar2 = dummy(1)\"\"\"/span\n\nspan class=\"n\"def/spanspan class=\"w\" /spanspan class=\"n\"test_constfold_alignment_check/spanspan class=\"p\"():/span\nspan class=\"w\"    /spanspan class=\"n\"bb/spanspan class=\"w\" /spanspan class=\"o\"=/spanspan class=\"w\" /spanspan class=\"n\"Block/spanspan class=\"p\"()/span\nspan class=\"w\"    /spanspan class=\"n\"var0/spanspan class=\"w\" /spanspan class=\"o\"=/spanspan class=\"w\" /spanspan class=\"n\"bb/spanspan class=\"o\"./spanspan class=\"n\"getarg/spanspan class=\"p\"(/spanspan class=\"mi\"0/spanspan class=\"p\")/span\nspan class=\"w\"    /spanspan class=\"n\"var1/spanspan class=\"w\" /spanspan class=\"o\"=/spanspan class=\"w\" /spanspan class=\"n\"bb/spanspan class=\"o\"./spanspan class=\"n\"int_invert/spanspan class=\"p\"(/spanspan class=\"mi\"0/spanspan class=\"n\"b111/spanspan class=\"p\")/span\nspan class=\"w\"    /spanspan class=\"c1\"# mask off the lowest three bits, thus var2 is aligned/span\nspan class=\"w\"    /spanspan class=\"n\"var2/spanspan class=\"w\" /spanspan class=\"o\"=/spanspan class=\"w\" /spanspan class=\"n\"bb/spanspan class=\"o\"./spanspan class=\"n\"int_and/spanspan class=\"p\"(/spanspan class=\"n\"var0/spanspan class=\"p\",/spanspan class=\"w\" /spanspan class=\"n\"var1/spanspan class=\"p\")/span\nspan class=\"w\"    /spanspan class=\"c1\"# add 16 to aligned quantity/span\nspan class=\"w\"    /spanspan class=\"n\"var3/spanspan class=\"w\" /spanspan class=\"o\"=/spanspan class=\"w\" /spanspan class=\"n\"bb/spanspan class=\"o\"./spanspan class=\"n\"int_add/spanspan class=\"p\"(/spanspan class=\"n\"var2/spanspan class=\"p\",/spanspan class=\"w\" /spanspan class=\"mi\"16/spanspan class=\"p\")/span\nspan class=\"w\"    /spanspan class=\"c1\"# check alignment of result/span\nspan class=\"w\"    /spanspan class=\"n\"var4/spanspan class=\"w\" /spanspan class=\"o\"=/spanspan class=\"w\" /spanspan class=\"n\"bb/spanspan class=\"o\"./spanspan class=\"n\"int_and/spanspan class=\"p\"(/spanspan class=\"n\"var3/spanspan class=\"p\",/spanspan class=\"w\" /spanspan class=\"mi\"0/spanspan class=\"n\"b111/spanspan class=\"p\")/span\nspan class=\"w\"    /spanspan class=\"n\"var5/spanspan class=\"w\" /spanspan class=\"o\"=/spanspan class=\"w\" /spanspan class=\"n\"bb/spanspan class=\"o\"./spanspan class=\"n\"int_eq/spanspan class=\"p\"(/spanspan class=\"n\"var4/spanspan class=\"p\",/spanspan class=\"w\" /spanspan class=\"mi\"0/spanspan class=\"p\")/span\nspan class=\"w\"    /spanspan class=\"c1\"# var5 should be const-folded to 1/span\nspan class=\"w\"    /spanspan class=\"n\"var6/spanspan class=\"w\" /spanspan class=\"o\"=/spanspan class=\"w\" /spanspan class=\"n\"bb/spanspan class=\"o\"./spanspan class=\"n\"dummy/spanspan class=\"p\"(/spanspan class=\"n\"var5/spanspan class=\"p\")/span\n\nspan class=\"w\"    /spanspan class=\"n\"opt_bb/spanspan class=\"w\" /spanspan class=\"o\"=/spanspan class=\"w\" /spanspan class=\"n\"simplify/spanspan class=\"p\"(/spanspan class=\"n\"bb/spanspan class=\"p\")/span\nspan class=\"w\"    /spanspan class=\"nb\"assert/spanspan class=\"w\" /spanspan class=\"n\"bb_to_str/spanspan class=\"p\"(/spanspan class=\"n\"opt_bb/spanspan class=\"p\",/spanspan class=\"w\" /spanspan class=\"s2\"\"optvar\"/spanspan class=\"p\")/spanspan class=\"w\" /spanspan class=\"o\"==/spanspan class=\"w\" /spanspan class=\"s2\"\"\"\"/spanspan class=\"se\"\\/span\nspan class=\"s2\"optvar0 = getarg(0)/span\nspan class=\"s2\"optvar1 = int_and(optvar0, -8)/span\nspan class=\"s2\"optvar2 = int_add(optvar1, 16)/span\nspan class=\"s2\"optvar3 = dummy(1)\"\"\"/span\n/pre/div\n\npHere is codesimplify/code to make these tests pass:/p\ndiv class=\"code\"pre class=\"code literal-block\"span class=\"k\"def/span span class=\"nf\"unknown_transfer_functions/spanspan class=\"p\"(/spanspan class=\"o\"*/spanspan class=\"n\"abstract_args/spanspan class=\"p\"):/span\n    span class=\"k\"return/span span class=\"n\"KnownBits/spanspan class=\"o\"./spanspan class=\"n\"all_unknown/spanspan class=\"p\"()/span\n\n\nspan class=\"k\"def/span span class=\"nf\"simplify/spanspan class=\"p\"(/spanspan class=\"n\"bb/spanspan class=\"p\":/span span class=\"n\"Block/spanspan class=\"p\")/span span class=\"o\"-gt;/span span class=\"n\"Block/spanspan class=\"p\":/span\n    span class=\"n\"abstract_values/span span class=\"o\"=/span span class=\"p\"{}/span span class=\"c1\"# dict mapping Operation to KnownBits/span\n\n    span class=\"k\"def/span span class=\"nf\"knownbits_of/spanspan class=\"p\"(/spanspan class=\"n\"val/span span class=\"p\":/span span class=\"n\"Value/spanspan class=\"p\"):/span\n        span class=\"k\"if/span span class=\"nb\"isinstance/spanspan class=\"p\"(/spanspan class=\"n\"val/spanspan class=\"p\",/span span class=\"n\"Constant/spanspan class=\"p\"):/span\n            span class=\"k\"return/span span class=\"n\"KnownBits/spanspan class=\"o\"./spanspan class=\"n\"from_constant/spanspan class=\"p\"(/spanspan class=\"n\"val/spanspan class=\"o\"./spanspan class=\"n\"value/spanspan class=\"p\")/span\n        span class=\"k\"return/span span class=\"n\"abstract_values/spanspan class=\"p\"[/spanspan class=\"n\"val/spanspan class=\"p\"]/span\n\n    span class=\"n\"opt_bb/span span class=\"o\"=/span span class=\"n\"Block/spanspan class=\"p\"()/span\n    span class=\"k\"for/span span class=\"n\"op/span span class=\"ow\"in/span span class=\"n\"bb/spanspan class=\"p\":/span\n        span class=\"c1\"# apply the transfer function on the abstract arguments/span\n        span class=\"n\"name_without_prefix/span span class=\"o\"=/span span class=\"n\"op/spanspan class=\"o\"./spanspan class=\"n\"name/spanspan class=\"o\"./spanspan class=\"n\"removeprefix/spanspan class=\"p\"(/spanspan class=\"s2\"\"int_\"/spanspan class=\"p\")/span\n        span class=\"n\"method_name/span span class=\"o\"=/span span class=\"sa\"f/spanspan class=\"s2\"\"abstract_/spanspan class=\"si\"{/spanspan class=\"n\"name_without_prefix/spanspan class=\"si\"}/spanspan class=\"s2\"\"/span\n        span class=\"n\"transfer_function/span span class=\"o\"=/span span class=\"nb\"getattr/spanspan class=\"p\"(/spanspan class=\"n\"KnownBits/spanspan class=\"p\",/span span class=\"n\"method_name/spanspan class=\"p\",/span span class=\"n\"unknown_transfer_functions/spanspan class=\"p\")/span\n        span class=\"n\"abstract_args/span span class=\"o\"=/span span class=\"p\"[/spanspan class=\"n\"knownbits_of/spanspan class=\"p\"(/spanspan class=\"n\"arg/spanspan class=\"o\"./spanspan class=\"n\"find/spanspan class=\"p\"())/span span class=\"k\"for/span span class=\"n\"arg/span span class=\"ow\"in/span span class=\"n\"op/spanspan class=\"o\"./spanspan class=\"n\"args/spanspan class=\"p\"]/span\n        span class=\"n\"abstract_res/span span class=\"o\"=/span span class=\"n\"abstract_values/spanspan class=\"p\"[/spanspan class=\"n\"op/spanspan class=\"p\"]/span span class=\"o\"=/span span class=\"n\"transfer_function/spanspan class=\"p\"(/spanspan class=\"o\"*/spanspan class=\"n\"abstract_args/spanspan class=\"p\")/span\n        span class=\"c1\"# if the result is a constant, we optimize the operation away and make/span\n        span class=\"c1\"# it equal to the constant result/span\n        span class=\"k\"if/span span class=\"n\"abstract_res/spanspan class=\"o\"./spanspan class=\"n\"is_constant/spanspan class=\"p\"():/span\n            span class=\"n\"op/spanspan class=\"o\"./spanspan class=\"n\"make_equal_to/spanspan class=\"p\"(/spanspan class=\"n\"Constant/spanspan class=\"p\"(/spanspan class=\"n\"abstract_res/spanspan class=\"o\"./spanspan class=\"n\"ones/spanspan class=\"p\"))/span\n            span class=\"k\"continue/span\n        span class=\"c1\"# otherwise emit the op/span\n        span class=\"n\"opt_bb/spanspan class=\"o\"./spanspan class=\"n\"append/spanspan class=\"p\"(/spanspan class=\"n\"op/spanspan class=\"p\")/span\n    span class=\"k\"return/span span class=\"n\"opt_bb/span\n/pre/div\n\npThe code follows the approach from the previous blog post very closely. The\nonly difference is that we apply the transfer function emfirst/em, to be able to\ndetect whether the abstract domain can tell us that the result has to always be\na constant. This code makes all three tests pass./p\nh3 id=\"using-the-knownbits-domain-for-conditional-peephole-rewrites\"Using the codeKnownBits/code Domain for Conditional Peephole Rewrites/h3\npSo far we are only using the codeKnownBits/code domain to find out that certain\noperations have to produce a constant. We can also use the codeKnownBits/code domain\nto check whether certain operation rewrites are correct. Let's use one of the\nexamples from the a href=\"https://www.pypy.org/posts/2024/07/mining-jit-traces-missing-optimizations-z3.html\"Mining JIT traces for missing optimizations with\nZ3/a\npost, where Z3 found the inefficiency code(x lt;lt; 4) amp; -0xf == x lt;lt; 4/code in PyPy JIT\ntraces. We don't have shift operations, but we want to generalize this optimization\nanyway. The general form of this rewrite is that under some circumstances codex amp;\ny == x/code, and we can use the codeKnownBits/code domain to detect situations where this\nmust be true./p\npTo understand emwhen/em codex amp; y == x/code is true, we can think about individual pairs of\nbits codea/code and codeb/code. If codea == 0/code, then codea amp; b == 0 amp; b == 0 == a/code. If codeb == 1/code\nthen codea amp; b == a amp; 1 == a/code. So if either codea == 0/code or codeb == 1/code is true,\ncodea amp; b == a/code follows. And if either of these conditions is true for emall/em the\nbits of codex/code and codey/code, we can know that codex amp; y == x/code./p\npWe can write a method on codeKnownBits/code to check for this condition:/p\ndiv class=\"code\"pre class=\"code literal-block\"span class=\"k\"class/span span class=\"nc\"KnownBits/spanspan class=\"p\":/span\n    span class=\"o\".../span\n\n    span class=\"k\"def/span span class=\"nf\"is_and_identity/spanspan class=\"p\"(/spanspan class=\"bp\"self/spanspan class=\"p\",/span span class=\"n\"other/spanspan class=\"p\"):/span\nspan class=\"w\"        /spanspan class=\"sd\"\"\"\" Return True if n1 amp; n2 == n1 for any n1 in self and n2 in other./span\nspan class=\"sd\"        (or, equivalently, return True if n1 | n2 == n2)\"\"\"/span\n        span class=\"k\"return/span span class=\"bp\"self/spanspan class=\"o\"./spanspan class=\"n\"zeros/span span class=\"o\"|/span span class=\"n\"other/spanspan class=\"o\"./spanspan class=\"n\"ones/span span class=\"o\"==/span span class=\"o\"-/spanspan class=\"mi\"1/span\n/pre/div\n\npSince my reasoning about this feels ripe for errors, let's check that our\nunderstanding is correct with Z3:/p\ndiv class=\"code\"pre class=\"code literal-block\"span class=\"k\"def/span span class=\"nf\"test_prove_is_and_identity/spanspan class=\"p\"():/span\n    span class=\"n\"solver/spanspan class=\"p\",/span span class=\"n\"k1/spanspan class=\"p\",/span span class=\"n\"n1/spanspan class=\"p\",/span span class=\"n\"k2/spanspan class=\"p\",/span span class=\"n\"n2/span span class=\"o\"=/span span class=\"n\"z3_setup_variables/spanspan class=\"p\"()/span\n    span class=\"n\"prove/spanspan class=\"p\"(/spanspan class=\"n\"z3/spanspan class=\"o\"./spanspan class=\"n\"Implies/spanspan class=\"p\"(/spanspan class=\"n\"k1/spanspan class=\"o\"./spanspan class=\"n\"is_and_identity/spanspan class=\"p\"(/spanspan class=\"n\"k2/spanspan class=\"p\"),/span span class=\"n\"n1/span span class=\"o\"amp;/span span class=\"n\"n2/span span class=\"o\"==/span span class=\"n\"n1/spanspan class=\"p\"),/span span class=\"n\"solver/spanspan class=\"p\")/span\n/pre/div\n\npNow let's use this in the toy optimizer. Here are two tests for this rewrite:/p\ndiv class=\"code\"pre class=\"code literal-block\"span class=\"k\"def/span span class=\"nf\"test_remove_redundant_and/spanspan class=\"p\"():/span\n    span class=\"n\"bb/span span class=\"o\"=/span span class=\"n\"Block/spanspan class=\"p\"()/span\n    span class=\"n\"var0/span span class=\"o\"=/span span class=\"n\"bb/spanspan class=\"o\"./spanspan class=\"n\"getarg/spanspan class=\"p\"(/spanspan class=\"mi\"0/spanspan class=\"p\")/span\n    span class=\"n\"var1/span span class=\"o\"=/span span class=\"n\"bb/spanspan class=\"o\"./spanspan class=\"n\"int_invert/spanspan class=\"p\"(/spanspan class=\"mb\"0b1111/spanspan class=\"p\")/span\n    span class=\"c1\"# mask off the lowest four bits/span\n    span class=\"n\"var2/span span class=\"o\"=/span span class=\"n\"bb/spanspan class=\"o\"./spanspan class=\"n\"int_and/spanspan class=\"p\"(/spanspan class=\"n\"var0/spanspan class=\"p\",/span span class=\"n\"var1/spanspan class=\"p\")/span\n    span class=\"c1\"# applying the same mask is not redundant/span\n    span class=\"n\"var3/span span class=\"o\"=/span span class=\"n\"bb/spanspan class=\"o\"./spanspan class=\"n\"int_and/spanspan class=\"p\"(/spanspan class=\"n\"var2/spanspan class=\"p\",/span span class=\"n\"var1/spanspan class=\"p\")/span\n    span class=\"n\"var4/span span class=\"o\"=/span span class=\"n\"bb/spanspan class=\"o\"./spanspan class=\"n\"dummy/spanspan class=\"p\"(/spanspan class=\"n\"var3/spanspan class=\"p\")/span\n\n    span class=\"n\"opt_bb/span span class=\"o\"=/span span class=\"n\"simplify/spanspan class=\"p\"(/spanspan class=\"n\"bb/spanspan class=\"p\")/span\n    span class=\"k\"assert/span span class=\"n\"bb_to_str/spanspan class=\"p\"(/spanspan class=\"n\"opt_bb/spanspan class=\"p\",/span span class=\"s2\"\"optvar\"/spanspan class=\"p\")/span span class=\"o\"==/span span class=\"s2\"\"\"\"/spanspan class=\"se\"\\/span\nspan class=\"s2\"optvar0 = getarg(0)/span\nspan class=\"s2\"optvar1 = int_and(optvar0, -16)/span\nspan class=\"s2\"optvar2 = dummy(optvar1)\"\"\"/span\n\nspan class=\"k\"def/span span class=\"nf\"test_remove_redundant_and_more_complex/spanspan class=\"p\"():/span\n    span class=\"n\"bb/span span class=\"o\"=/span span class=\"n\"Block/spanspan class=\"p\"()/span\n    span class=\"n\"var0/span span class=\"o\"=/span span class=\"n\"bb/spanspan class=\"o\"./spanspan class=\"n\"getarg/spanspan class=\"p\"(/spanspan class=\"mi\"0/spanspan class=\"p\")/span\n    span class=\"n\"var1/span span class=\"o\"=/span span class=\"n\"bb/spanspan class=\"o\"./spanspan class=\"n\"getarg/spanspan class=\"p\"(/spanspan class=\"mi\"1/spanspan class=\"p\")/span\n    span class=\"c1\"# var2 has bit pattern ????/span\n    span class=\"n\"var2/span span class=\"o\"=/span span class=\"n\"bb/spanspan class=\"o\"./spanspan class=\"n\"int_and/spanspan class=\"p\"(/spanspan class=\"n\"var0/spanspan class=\"p\",/span span class=\"mb\"0b1111/spanspan class=\"p\")/span\n    span class=\"c1\"# var3 has bit pattern ...?1111/span\n    span class=\"n\"var3/span span class=\"o\"=/span span class=\"n\"bb/spanspan class=\"o\"./spanspan class=\"n\"int_or/spanspan class=\"p\"(/spanspan class=\"n\"var1/spanspan class=\"p\",/span span class=\"mb\"0b1111/spanspan class=\"p\")/span\n    span class=\"c1\"# var4 is just var2/span\n    span class=\"n\"var4/span span class=\"o\"=/span span class=\"n\"bb/spanspan class=\"o\"./spanspan class=\"n\"int_and/spanspan class=\"p\"(/spanspan class=\"n\"var2/spanspan class=\"p\",/span span class=\"n\"var3/spanspan class=\"p\")/span\n    span class=\"n\"var5/span span class=\"o\"=/span span class=\"n\"bb/spanspan class=\"o\"./spanspan class=\"n\"dummy/spanspan class=\"p\"(/spanspan class=\"n\"var4/spanspan class=\"p\")/span\n\n    span class=\"n\"opt_bb/span span class=\"o\"=/span span class=\"n\"simplify/spanspan class=\"p\"(/spanspan class=\"n\"bb/spanspan class=\"p\")/span\n    span class=\"k\"assert/span span class=\"n\"bb_to_str/spanspan class=\"p\"(/spanspan class=\"n\"opt_bb/spanspan class=\"p\",/span span class=\"s2\"\"optvar\"/spanspan class=\"p\")/span span class=\"o\"==/span span class=\"s2\"\"\"\"/spanspan class=\"se\"\\/span\nspan class=\"s2\"optvar0 = getarg(0)/span\nspan class=\"s2\"optvar1 = getarg(1)/span\nspan class=\"s2\"optvar2 = int_and(optvar0, 15)/span\nspan class=\"s2\"optvar3 = int_or(optvar1, 15)/span\nspan class=\"s2\"optvar4 = dummy(optvar2)\"\"\"/span\n/pre/div\n\npThe first test could also be made to pass by implementing a reassociation\noptimization that turns code(x amp; c1) amp; c2/code into codex amp; (c1 amp; c2)/code and then constant-folds the second codeand/code. But here we want to\nuse codeKnownBits/code and conditionally rewrite codeint_and/code to its first argument. So to make the tests pass,\nwe can change codesimplify/code like this:/p\ndiv class=\"code\"pre class=\"code literal-block\"span class=\"k\"def/span span class=\"nf\"simplify/spanspan class=\"p\"(/spanspan class=\"n\"bb/spanspan class=\"p\":/span span class=\"n\"Block/spanspan class=\"p\")/span span class=\"o\"-gt;/span span class=\"n\"Block/spanspan class=\"p\":/span\n    span class=\"n\"abstract_values/span span class=\"o\"=/span span class=\"p\"{}/span span class=\"c1\"# dict mapping Operation to KnownBits/span\n\n    span class=\"k\"def/span span class=\"nf\"knownbits_of/spanspan class=\"p\"(/spanspan class=\"n\"val/span span class=\"p\":/span span class=\"n\"Value/spanspan class=\"p\"):/span\n        span class=\"o\".../span\n\n    span class=\"n\"opt_bb/span span class=\"o\"=/span span class=\"n\"Block/spanspan class=\"p\"()/span\n    span class=\"k\"for/span span class=\"n\"op/span span class=\"ow\"in/span span class=\"n\"bb/spanspan class=\"p\":/span\n        span class=\"c1\"# apply the transfer function on the abstract arguments/span\n        span class=\"n\"name_without_prefix/span span class=\"o\"=/span span class=\"n\"op/spanspan class=\"o\"./spanspan class=\"n\"name/spanspan class=\"o\"./spanspan class=\"n\"removeprefix/spanspan class=\"p\"(/spanspan class=\"s2\"\"int_\"/spanspan class=\"p\")/span\n        span class=\"n\"method_name/span span class=\"o\"=/span span class=\"sa\"f/spanspan class=\"s2\"\"abstract_/spanspan class=\"si\"{/spanspan class=\"n\"name_without_prefix/spanspan class=\"si\"}/spanspan class=\"s2\"\"/span\n        span class=\"n\"transfer_function/span span class=\"o\"=/span span class=\"nb\"getattr/spanspan class=\"p\"(/spanspan class=\"n\"KnownBits/spanspan class=\"p\",/span span class=\"n\"method_name/spanspan class=\"p\",/span span class=\"n\"unknown_transfer_functions/spanspan class=\"p\")/span\n        span class=\"n\"abstract_args/span span class=\"o\"=/span span class=\"p\"[/spanspan class=\"n\"knownbits_of/spanspan class=\"p\"(/spanspan class=\"n\"arg/spanspan class=\"o\"./spanspan class=\"n\"find/spanspan class=\"p\"())/span span class=\"k\"for/span span class=\"n\"arg/span span class=\"ow\"in/span span class=\"n\"op/spanspan class=\"o\"./spanspan class=\"n\"args/spanspan class=\"p\"]/span\n        span class=\"n\"abstract_res/span span class=\"o\"=/span span class=\"n\"abstract_values/spanspan class=\"p\"[/spanspan class=\"n\"op/spanspan class=\"p\"]/span span class=\"o\"=/span span class=\"n\"transfer_function/spanspan class=\"p\"(/spanspan class=\"o\"*/spanspan class=\"n\"abstract_args/spanspan class=\"p\")/span\n        span class=\"c1\"# if the result is a constant, we optimize the operation away and make/span\n        span class=\"c1\"# it equal to the constant result/span\n        span class=\"k\"if/span span class=\"n\"abstract_res/spanspan class=\"o\"./spanspan class=\"n\"is_constant/spanspan class=\"p\"():/span\n            span class=\"n\"op/spanspan class=\"o\"./spanspan class=\"n\"make_equal_to/spanspan class=\"p\"(/spanspan class=\"n\"Constant/spanspan class=\"p\"(/spanspan class=\"n\"abstract_res/spanspan class=\"o\"./spanspan class=\"n\"ones/spanspan class=\"p\"))/span\n            span class=\"k\"continue/span\n        span class=\"c1\"# lt;lt;lt;lt; new code/span\n        span class=\"c1\"# conditionally rewrite int_and(x, y) to x/span\n        span class=\"k\"if/span span class=\"n\"op/spanspan class=\"o\"./spanspan class=\"n\"name/span span class=\"o\"==/span span class=\"s2\"\"int_and\"/spanspan class=\"p\":/span\n            span class=\"n\"k1/spanspan class=\"p\",/span span class=\"n\"k2/span span class=\"o\"=/span span class=\"n\"abstract_args/span\n            span class=\"k\"if/span span class=\"n\"k1/spanspan class=\"o\"./spanspan class=\"n\"is_and_identity/spanspan class=\"p\"(/spanspan class=\"n\"k2/spanspan class=\"p\"):/span\n                span class=\"n\"op/spanspan class=\"o\"./spanspan class=\"n\"make_equal_to/spanspan class=\"p\"(/spanspan class=\"n\"op/spanspan class=\"o\"./spanspan class=\"n\"arg/spanspan class=\"p\"(/spanspan class=\"mi\"0/spanspan class=\"p\"))/span\n                span class=\"k\"continue/span\n        span class=\"c1\"# gt;gt;gt;gt; end changes/span\n        span class=\"n\"opt_bb/spanspan class=\"o\"./spanspan class=\"n\"append/spanspan class=\"p\"(/spanspan class=\"n\"op/spanspan class=\"p\")/span\n    span class=\"k\"return/span span class=\"n\"opt_bb/span\n/pre/div\n\npAnd with that, the new tests pass as well. A real implementation would also\ncheck the other argument order, but we leave that out for the sake of brevity./p\npThis rewrite also generalizes the a href=\"https://pypy.org/posts/2024/07/finding-simple-rewrite-rules-jit-z3.html\"rewrites/a codeint_and(0, x) -gt; 0/code and\ncodeint_and(-1, x) -gt; x/code, let's add a test for those:/p\ndiv class=\"code\"pre class=\"code literal-block\"span class=\"k\"def/span span class=\"nf\"test_remove_and_simple/spanspan class=\"p\"():/span\n    span class=\"n\"bb/span span class=\"o\"=/span span class=\"n\"Block/spanspan class=\"p\"()/span\n    span class=\"n\"var0/span span class=\"o\"=/span span class=\"n\"bb/spanspan class=\"o\"./spanspan class=\"n\"getarg/spanspan class=\"p\"(/spanspan class=\"mi\"0/spanspan class=\"p\")/span\n    span class=\"n\"var1/span span class=\"o\"=/span span class=\"n\"bb/spanspan class=\"o\"./spanspan class=\"n\"getarg/spanspan class=\"p\"(/spanspan class=\"mi\"1/spanspan class=\"p\")/span\n    span class=\"n\"var2/span span class=\"o\"=/span span class=\"n\"bb/spanspan class=\"o\"./spanspan class=\"n\"int_and/spanspan class=\"p\"(/spanspan class=\"mi\"0/spanspan class=\"p\",/span span class=\"n\"var0/spanspan class=\"p\")/span span class=\"c1\"# == 0/span\n    span class=\"n\"var3/span span class=\"o\"=/span span class=\"n\"bb/spanspan class=\"o\"./spanspan class=\"n\"int_invert/spanspan class=\"p\"(/spanspan class=\"n\"var2/spanspan class=\"p\")/span span class=\"c1\"# == -1/span\n    span class=\"n\"var4/span span class=\"o\"=/span span class=\"n\"bb/spanspan class=\"o\"./spanspan class=\"n\"int_and/spanspan class=\"p\"(/spanspan class=\"n\"var1/spanspan class=\"p\",/span span class=\"n\"var3/spanspan class=\"p\")/span span class=\"c1\"# == var1/span\n    span class=\"n\"var5/span span class=\"o\"=/span span class=\"n\"bb/spanspan class=\"o\"./spanspan class=\"n\"dummy/spanspan class=\"p\"(/spanspan class=\"n\"var4/spanspan class=\"p\")/span\n\n    span class=\"n\"opt_bb/span span class=\"o\"=/span span class=\"n\"simplify/spanspan class=\"p\"(/spanspan class=\"n\"bb/spanspan class=\"p\")/span\n    span class=\"k\"assert/span span class=\"n\"bb_to_str/spanspan class=\"p\"(/spanspan class=\"n\"opt_bb/spanspan class=\"p\",/span span class=\"s2\"\"optvar\"/spanspan class=\"p\")/span span class=\"o\"==/span span class=\"s2\"\"\"\"/spanspan class=\"se\"\\/span\nspan class=\"s2\"optvar0 = getarg(0)/span\nspan class=\"s2\"optvar1 = getarg(1)/span\nspan class=\"s2\"optvar2 = dummy(optvar1)\"\"\"/span\n/pre/div\n\npThis test just passes. And that's it for this post!/p\nh3 id=\"conclusion\"Conclusion/h3\npIn this post we've seen the implementation, testing and proofs about a 'known\nbits' abstract domain, as well as its use in the toy optimizer to generalize\nconstant folding, and to implement conditional peephole rewrites./p\npIn the next posts I'll write about the real implementation of a knownbits\ndomain in PyPy's JIT, its combination with the existing interval abstract\ndomain, how to deal with gaining information from conditions in the program,\nand some lose ends./p\npSources:/p\nul\nlia href=\"https://github.com/llvm/llvm-project/blob/main/llvm/lib/Support/KnownBits.cpp\"Known bits in LLVM/a/li\nlia href=\"https://github.com/torvalds/linux/blob/master/kernel/bpf/tnum.c\"Tristate numbers for known bits in Linux eBPF/a/li\nlia href=\"https://arxiv.org/abs/2105.05398\"Sound, Precise, and Fast Abstract Interpretation with Tristate Numbers/a/li\nlia href=\"https://people.cs.rutgers.edu/~sn349/papers/agni-cav2023.pdf\"Verifying the Verier: eBPF Range Analysis Verication/a/li\nlia href=\"https://dougallj.wordpress.com/2020/01/13/bit-twiddling-addition-with-unknown-bits/\"Bit-Twiddling: Addition with Unknown\n  Bits/a\n  is a super readable blog post by Dougall J. I've taken the codeones/code and\n  codeunknowns/code naming from this post, which I find significantly clearer than\n  codevalue/code and codemask/code, which the Linux kernel uses./li\nlia href=\"https://bitmath.blogspot.com/\"Bits, Math and Performance(?)/a, a fantastic\n  blog by a href=\"https://mastodon.gamedev.place/@harold\"Harold Aptroot/a. There are a\n  lot of relevant posts about known bits, range analysis etc. Harold is also\n  the author of a href=\"http://haroldbot.nl/\"Haroldbot/a, a website that can be used\n  for bitvector calculations, and also checks bitvector identities./li\nlia href=\"https://cea.hal.science/cea-01795779/document\"Sharpening Constraint Programming approaches for Bit-Vector Theory/a/li\nlia href=\"https://users.cs.utah.edu/~regehr/papers/lctes06_2/fp019-regehr.pdf\"Deriving Abstract Transfer Functions for Analyzing Embedded Software/a/li\nlia href=\"https://arxiv.org/abs/2105.00493\"Synthesizing Abstract Transformers/a/li\n/ul\ndiv class=\"footnote\"\nhr\nol\nli id=\"fn:proof_bitwidths\"\npThere's a subtletly about the Z3 proofs that I'm sort of\nglossing over here. Python integers are of arbitrary width, and the\ncodeKnownBits/code code is actually carefully written to work for integers of any\nsize. This property is tested by the Hypothesis tests, which don't limit\nthe sizes of the generated random integers. However, the Z3 proofs only\ncheck bitvectors of a fixed bitwidth of 64. There are various ways to deal\nwith this situation. For most \"real\" compilers, the bitwidth of integers\nwould be fixed anyway. Then the components codeones/code and codeunknowns/code of the\ncodeKnownBits/code class would use the number of bits the corresponding integer\nvariable has, and the Z3 proofs would use the same width. This is what we\ndo in the PyPy JIT. a class=\"footnote-backref\" href=\"https://www.pypy.org/posts/2024/08/toy-knownbits.html#fnref:proof_bitwidths\" title=\"Jump back to footnote 1 in the text\"/a/p\n/li\nli id=\"fn:tests_vs_proofs\"\npThe less close connection between implementation and proof\nfor codeabstract_eq/code is one of the reasons why it makes sense to do\nunit-testing emin addition/em to proofs. For a more detailed explanation of\nwhy both tests and proofs are good to\nhave, see a href=\"https://siek.blogspot.com/2024/06/data-structures-and-algorithms-correctly.html#correct-software-via-write-test-and-prove:~:text=We%20recognize%20that%20once%20step,detect%20most%20of%20the%20bugs\"Jeremy Siek's blog\npost/a,\nas well as the a href=\"https://www-cs-faculty.stanford.edu/~knuth/faq.html#:~:text=What's%20the%20exact%20citation%20of%20your%20oft%2Dcited%20comment%20about%20bugs?\"Knuth\nquote/a. a class=\"footnote-backref\" href=\"https://www.pypy.org/posts/2024/08/toy-knownbits.html#fnref:tests_vs_proofs\" title=\"Jump back to footnote 2 in the text\"/a/p\n/li\n/ol\n/div"
        }
      ],
      "description": "pAfter a href=\"https://bernsteinbear.com/blog/toy-abstract-interpretation/\"Max' introduction to abstract interpretation for the toy optimizer/a in the\nlast post, I want to present a more complicated abstract domain in this post.\nThis abstract domain reasons about the individual bits of a variable in a trace.\nEvery bit can be either \"known zero\", \"known one\" or \"unknown\". The abstract\ndomain is useful for optimizing integer operations, particularly the bitwise operations.\nThe abstract domain follows quite closely the a href=\"https://github.com/torvalds/linux/blob/master/kernel/bpf/tnum.c\"tristate abstract domain of the\neBPF verifier in the Linux\nKernel/a, as\ndescribed by the paper\na href=\"https://arxiv.org/abs/2105.05398\"Sound, Precise, and Fast Abstract Interpretation with Tristate\nNumbers/a by Harishankar Vishwanathan, Matan\nShachnai, Srinivas Narayana, and Santosh Nagarakatte./p\npThe presentation in this post will still be in the context of the\na href=\"https://www.pypy.org/categories/toy-optimizer\"toy optimizer/a. We'll spend a significant part of\nthe post convincing ourselves that the abstract domain transfer functions that\nwe're writing are really correct, using both property-based testing and\nautomated proofs (again using Z3)./p\npPyPy has implemented and merged a more complicated version of the same abstract\ndomain for the \"real\" PyPy JIT. A more thorough explanation of that real world\nimplementation will follow./p\npI'd like to thank Max Bernstein and Armin Rigo for lots of great feedback on\ndrafts of this post. The PyPy implementation was mainly done by Nico\nRittinghaus and me./p\npstrongContents:/strong/p\ndiv class=\"toc\"\nul\nlia href=\"https://www.pypy.org/posts/2024/08/toy-knownbits.html#motivation\"Motivation/a/li\nlia href=\"https://www.pypy.org/posts/2024/08/toy-knownbits.html#the-knownbits-abstract-domain\"The Knownbits Abstract Domain/a/li\nlia href=\"https://www.pypy.org/posts/2024/08/toy-knownbits.html#transfer-functions\"Transfer Functions/a/li\nlia href=\"https://www.pypy.org/posts/2024/08/toy-knownbits.html#property-based-tests-with-hypothesis\"Property-based Tests with Hypothesis/a/li\nlia href=\"https://www.pypy.org/posts/2024/08/toy-knownbits.html#when-are-transfer-functions-correct-how-do-we-test-them\"When are Transfer Functions Correct? How do we test them?/a/li\nlia href=\"https://www.pypy.org/posts/2024/08/toy-knownbits.html#implementing-binary-transfer-functions\"Implementing Binary Transfer Functions/a/li\nlia href=\"https://www.pypy.org/posts/2024/08/toy-knownbits.html#addition-and-subtraction\"Addition and Subtraction/a/li\nlia href=\"https://www.pypy.org/posts/2024/08/toy-knownbits.html#proving-correctness-of-the-transfer-functions-with-z3\"Proving correctness of the transfer functions with Z3/a/li\nlia href=\"https://www.pypy.org/posts/2024/08/toy-knownbits.html#cases-where-this-style-of-z3-proof-doesnt-work\"Cases where this style of Z3 proof doesn't work/a/li\nlia href=\"https://www.pypy.org/posts/2024/08/toy-knownbits.html#making-statements-about-precision\"Making Statements about Precision/a/li\nlia href=\"https://www.pypy.org/posts/2024/08/toy-knownbits.html#using-the-abstract-domain-in-the-toy-optimizer-for-generalized-constant-folding\"Using the Abstract Domain in the Toy Optimizer for Generalized Constant Folding/a/li\nlia href=\"https://www.pypy.org/posts/2024/08/toy-knownbits.html#using-the-knownbits-domain-for-conditional-peephole-rewrites\"Using the KnownBits Domain for Conditional Peephole Rewrites/a/li\nlia href=\"https://www.pypy.org/posts/2024/08/toy-knownbits.html#conclusion\"Conclusion/a/li\n/ul\n/div\nh3 id=\"motivation\"Motivation/h3\npIn many programs that do bit-manipulation of integers, some of the bits of the\ninteger variables of the program can be statically known. Here's a simple\nexample:/p\ndiv class=\"code\"pre class=\"code literal-block\"span class=\"nv\"x/spanspan class=\"w\" /spanspan class=\"o\"=/spanspan class=\"w\" /spanspan class=\"nv\"a/spanspan class=\"w\" /spanspan class=\"o\"|/spanspan class=\"w\" /spanspan class=\"mi\"1/span\n...\nspan class=\"k\"if/spanspan class=\"w\" /spanspan class=\"nv\"x/spanspan class=\"w\" /spanspan class=\"o\"amp;/spanspan class=\"w\" /spanspan class=\"mi\"1/span:\nspan class=\"w\"    /span...\nspan class=\"k\"else/span:\nspan class=\"w\"    /span...\n/pre/div\n\npAfter the assignment codex = a | 1/code, we know that the lowest bit of codex/code must be code1/code\n(the other bits are unknown) and an optimizer could remove the condition codex amp; 1/code by\nconstant-folding it to code1/code./p\npAnother (more complicated) example is:/p\ndiv class=\"code\"pre class=\"code literal-block\"assert i amp; 0b111 == 0 # check that i is a multiple of 8\nj = i + 16\nassert j amp; 0b111 == 0\n/pre/div\n\npThis kind of code could e.g. happen in a a href=\"https://docs.pydrofoil.org/en/latest/\"CPU\nemulator/a, where codei/code and codej/code are\nintegers that represent emulated pointers, and the codeassert/codes are alignment\nchecks. The first assert implies that the lowest three bits of i must be code0/code.\nAdding 16 to such a number produces a result where the lowest three bits are\nagain all code0/code, therefore the second assert is always true. So we would like a\ncompiler to remove the second assert./p\npBoth of these will optimizations are doable with the help of the knownbits\nabstract domain that we'll discuss in the rest of the post./p\nh3 id=\"the-knownbits-abstract-domain\"The Knownbits Abstract Domain/h3\npAn abstract value of the knownbits domain needs to be able to store, for every\nbit of an integer variable in a program, whether it is known 0, known 1, or\nunknown. To represent\nthree different states, we need 2 bits, which we will call codeone/code and codeunknown/code.\nHere's the encoding:/p\ntable\nthead\ntr\nthone/th\nthunknown/th\nth align=\"right\"knownbit/th\n/tr\n/thead\ntbody\ntr\ntd0/td\ntd0/td\ntd align=\"right\"0/td\n/tr\ntr\ntd1/td\ntd0/td\ntd align=\"right\"1/td\n/tr\ntr\ntd0/td\ntd1/td\ntd align=\"right\"?/td\n/tr\ntr\ntd1/td\ntd1/td\ntd align=\"right\"illegal/td\n/tr\n/tbody\n/table\npThe codeunknown/code bit is set if we don't know the value of the bit (\"?\"), the codeone/code\nbit is set if the bit is known to be a code1/code. Since two bits are enough to encode\nfour different states, but we only need three, the combination of a set codeone/code\nbit and a set codeunknown/code is not allowed./p\npWe don't just want to encode a single bit, however. Instead, we want to do this\nfor all the bits of an integer variable. Therefore the instances of the abstract\ndomain get two integer fields codeones/code and codeunknowns/code, where each pair of\ncorresponding bits encodes the knowledge about the corresponding bit of the\ninteger variable in the program./p\npWe can start implementing a Python class that works like this:/p\ndiv class=\"code\"pre class=\"code literal-block\"span class=\"kn\"from/span span class=\"nn\"dataclasses/span span class=\"kn\"import/span span class=\"n\"dataclass/span\n\nspan class=\"nd\"@dataclass/spanspan class=\"p\"(/spanspan class=\"n\"eq/spanspan class=\"o\"=/spanspan class=\"kc\"False/spanspan class=\"p\")/span\nspan class=\"k\"class/span span class=\"nc\"KnownBits/spanspan class=\"p\":/span\n    span class=\"n\"ones/span span class=\"p\":/span span class=\"nb\"int/span\n    span class=\"n\"unknowns/span span class=\"p\":/span span class=\"nb\"int/span\n\n    span class=\"k\"def/span span class=\"nf\"__post_init__/spanspan class=\"p\"(/spanspan class=\"bp\"self/spanspan class=\"p\"):/span\n        span class=\"k\"if/span span class=\"nb\"isinstance/spanspan class=\"p\"(/spanspan class=\"bp\"self/spanspan class=\"o\"./spanspan class=\"n\"ones/spanspan class=\"p\",/span span class=\"nb\"int/spanspan class=\"p\"):/span\n            span class=\"k\"assert/span span class=\"bp\"self/spanspan class=\"o\"./spanspan class=\"n\"is_well_formed/spanspan class=\"p\"()/span\n\n    span class=\"k\"def/span span class=\"nf\"is_well_formed/spanspan class=\"p\"(/spanspan class=\"bp\"self/spanspan class=\"p\"):/span\n        span class=\"c1\"# a bit cannot be both 1 and unknown/span\n        span class=\"k\"return/span span class=\"bp\"self/spanspan class=\"o\"./spanspan class=\"n\"ones/span span class=\"o\"amp;/span span class=\"bp\"self/spanspan class=\"o\"./spanspan class=\"n\"unknowns/span span class=\"o\"==/span span class=\"mi\"0/span\n\n    span class=\"nd\"@staticmethod/span\n    span class=\"k\"def/span span class=\"nf\"from_constant/spanspan class=\"p\"(/spanspan class=\"n\"const/span span class=\"p\":/span span class=\"nb\"int/spanspan class=\"p\"):/span\nspan class=\"w\"        /spanspan class=\"sd\"\"\"\" Construct a KnownBits corresponding to a constant, where all bits/span\nspan class=\"sd\"        are known.\"\"\"/span\n        span class=\"k\"return/span span class=\"n\"KnownBits/spanspan class=\"p\"(/spanspan class=\"n\"const/spanspan class=\"p\",/span span class=\"mi\"0/spanspan class=\"p\")/span\n\n    span class=\"k\"def/span span class=\"nf\"is_constant/spanspan class=\"p\"(/spanspan class=\"bp\"self/spanspan class=\"p\"):/span\nspan class=\"w\"        /spanspan class=\"sd\"\"\"\" Check if the KnownBits instance represents a constant. \"\"\"/span\n        span class=\"c1\"# it's a constant if there are no unknowns/span\n        span class=\"k\"return/span span class=\"bp\"self/spanspan class=\"o\"./spanspan class=\"n\"unknowns/span span class=\"o\"==/span span class=\"mi\"0/span\n/pre/div\n\npWe can also add some convenience properties. Sometimes it is easier to work\nwith an integer where all the emknown/em bits are set, or one where the positions\nof all the known zeros have a set bit:/p\ndiv class=\"code\"pre class=\"code literal-block\"span class=\"k\"class/span span class=\"nc\"KnownBits/spanspan class=\"p\":/span\n    span class=\"o\".../span\n\n    span class=\"nd\"@property/span\n    span class=\"k\"def/span span class=\"nf\"knowns/spanspan class=\"p\"(/spanspan class=\"bp\"self/spanspan class=\"p\"):/span\nspan class=\"w\"        /spanspan class=\"sd\"\"\"\" return an integer where the known bits are set. \"\"\"/span\n        span class=\"c1\"# the knowns are just the unknowns, inverted/span\n        span class=\"k\"return/span span class=\"o\"~/spanspan class=\"bp\"self/spanspan class=\"o\"./spanspan class=\"n\"unknowns/span\n\n    span class=\"nd\"@property/span\n    span class=\"k\"def/span span class=\"nf\"zeros/spanspan class=\"p\"(/spanspan class=\"bp\"self/spanspan class=\"p\"):/span\nspan class=\"w\"        /spanspan class=\"sd\"\"\"\" return an integer where the places that are known zeros have a bit/span\nspan class=\"sd\"        set. \"\"\"/span\n        span class=\"c1\"# it's a 0 if it is known, but not 1/span\n        span class=\"k\"return/span span class=\"bp\"self/spanspan class=\"o\"./spanspan class=\"n\"knowns/span span class=\"o\"amp;/span span class=\"o\"~/spanspan class=\"bp\"self/spanspan class=\"o\"./spanspan class=\"n\"ones/span\n/pre/div\n\npAlso, for debugging and for writing tests we want a way to print the known bits\nin a human-readable form, and also to have a way to construct a codeKnownBits/code\ninstance from a string. It's not important to understand the details of\ncode__str__/code or codefrom_str/code for the rest of the post, so I'm putting them into a fold:/p\ndetails\nsummarycodeKnownBits/code from and to string conversions/summary\n\n\ndiv class=\"code\"pre class=\"code literal-block\"span class=\"k\"class/span span class=\"nc\"KnownBits/spanspan class=\"p\":/span\n    span class=\"o\".../span\n\n    span class=\"k\"def/span span class=\"fm\"__repr__/spanspan class=\"p\"(/spanspan class=\"bp\"self/spanspan class=\"p\"):/span\n        span class=\"k\"if/span span class=\"bp\"self/spanspan class=\"o\"./spanspan class=\"n\"is_constant/spanspan class=\"p\"():/span\n            span class=\"k\"return/span span class=\"sa\"f/spanspan class=\"s2\"\"KnownBits.from_constant(/spanspan class=\"si\"{/spanspan class=\"bp\"self/spanspan class=\"o\"./spanspan class=\"n\"ones/spanspan class=\"si\"}/spanspan class=\"s2\")\"/span\n        span class=\"k\"return/span span class=\"sa\"f/spanspan class=\"s2\"\"KnownBits(/spanspan class=\"si\"{/spanspan class=\"bp\"self/spanspan class=\"o\"./spanspan class=\"n\"ones/spanspan class=\"si\"}/spanspan class=\"s2\", /spanspan class=\"si\"{/spanspan class=\"bp\"self/spanspan class=\"o\"./spanspan class=\"n\"unknowns/spanspan class=\"si\"}/spanspan class=\"s2\")\"/span\n\n    span class=\"k\"def/span span class=\"fm\"__str__/spanspan class=\"p\"(/spanspan class=\"bp\"self/spanspan class=\"p\"):/span\n        span class=\"n\"res/span span class=\"o\"=/span span class=\"p\"[]/span\n        span class=\"n\"ones/spanspan class=\"p\",/span span class=\"n\"unknowns/span span class=\"o\"=/span span class=\"bp\"self/spanspan class=\"o\"./spanspan class=\"n\"ones/spanspan class=\"p\",/span span class=\"bp\"self/spanspan class=\"o\"./spanspan class=\"n\"unknowns/span\n        span class=\"c1\"# construct the string representation right to left/span\n        span class=\"k\"while/span span class=\"mi\"1/spanspan class=\"p\":/span\n            span class=\"k\"if/span span class=\"ow\"not/span span class=\"n\"ones/span span class=\"ow\"and/span span class=\"ow\"not/span span class=\"n\"unknowns/spanspan class=\"p\":/span\n                span class=\"k\"break/span span class=\"c1\"# we leave off the leading known 0s/span\n            span class=\"k\"if/span span class=\"n\"ones/span span class=\"o\"==/span span class=\"o\"-/spanspan class=\"mi\"1/span span class=\"ow\"and/span span class=\"ow\"not/span span class=\"n\"unknowns/spanspan class=\"p\":/span\n                span class=\"c1\"# -1 has all bits set in two's complement, so the leading/span\n                span class=\"c1\"# bits are all 1/span\n                span class=\"n\"res/spanspan class=\"o\"./spanspan class=\"n\"append/spanspan class=\"p\"(/spanspan class=\"s1\"'1'/spanspan class=\"p\")/span\n                span class=\"n\"res/spanspan class=\"o\"./spanspan class=\"n\"append/spanspan class=\"p\"(/spanspan class=\"s2\"\"...\"/spanspan class=\"p\")/span\n                span class=\"k\"break/span\n            span class=\"k\"if/span span class=\"n\"unknowns/span span class=\"o\"==/span span class=\"o\"-/spanspan class=\"mi\"1/spanspan class=\"p\":/span\n                span class=\"c1\"# -1 has all bits set in two's complement, so the leading bits/span\n                span class=\"c1\"# are all ?/span\n                span class=\"k\"assert/span span class=\"ow\"not/span span class=\"n\"ones/span\n                span class=\"n\"res/spanspan class=\"o\"./spanspan class=\"n\"append/spanspan class=\"p\"(/spanspan class=\"s2\"\"?\"/spanspan class=\"p\")/span\n                span class=\"n\"res/spanspan class=\"o\"./spanspan class=\"n\"append/spanspan class=\"p\"(/spanspan class=\"s2\"\"...\"/spanspan class=\"p\")/span\n                span class=\"k\"break/span\n            span class=\"k\"if/span span class=\"n\"unknowns/span span class=\"o\"amp;/span span class=\"mi\"1/spanspan class=\"p\":/span\n                span class=\"n\"res/spanspan class=\"o\"./spanspan class=\"n\"append/spanspan class=\"p\"(/spanspan class=\"s1\"'?'/spanspan class=\"p\")/span\n            span class=\"k\"elif/span span class=\"n\"ones/span span class=\"o\"amp;/span span class=\"mi\"1/spanspan class=\"p\":/span\n                span class=\"n\"res/spanspan class=\"o\"./spanspan class=\"n\"append/spanspan class=\"p\"(/spanspan class=\"s1\"'1'/spanspan class=\"p\")/span\n            span class=\"k\"else/spanspan class=\"p\":/span\n                span class=\"n\"res/spanspan class=\"o\"./spanspan class=\"n\"append/spanspan class=\"p\"(/spanspan class=\"s1\"'0'/spanspan class=\"p\")/span\n            span class=\"n\"ones/span span class=\"o\"gt;gt;=/span span class=\"mi\"1/span\n            span class=\"n\"unknowns/span span class=\"o\"gt;gt;=/span span class=\"mi\"1/span\n        span class=\"k\"if/span span class=\"ow\"not/span span class=\"n\"res/spanspan class=\"p\":/span\n            span class=\"n\"res/spanspan class=\"o\"./spanspan class=\"n\"append/spanspan class=\"p\"(/spanspan class=\"s1\"'0'/spanspan class=\"p\")/span\n        span class=\"n\"res/spanspan class=\"o\"./spanspan class=\"n\"reverse/spanspan class=\"p\"()/span\n        span class=\"k\"return/span span class=\"s2\"\"\"/spanspan class=\"o\"./spanspan class=\"n\"join/spanspan class=\"p\"(/spanspan class=\"n\"res/spanspan class=\"p\")/span\n\n    span class=\"nd\"@staticmethod/span\n    span class=\"k\"def/span span class=\"nf\"from_str/spanspan class=\"p\"(/spanspan class=\"n\"s/spanspan class=\"p\"):/span\nspan class=\"w\"        /spanspan class=\"sd\"\"\"\" Construct a KnownBits instance that from a string. String can start/span\nspan class=\"sd\"        with ...1 to mean that all higher bits are 1, or ...? to mean that all/span\nspan class=\"sd\"        higher bits are unknown. Otherwise it is assumed that the higher bits/span\nspan class=\"sd\"        are all 0. \"\"\"/span\n        span class=\"n\"ones/spanspan class=\"p\",/span span class=\"n\"unknowns/span span class=\"o\"=/span span class=\"mi\"0/spanspan class=\"p\",/span span class=\"mi\"0/span\n        span class=\"n\"startindex/span span class=\"o\"=/span span class=\"mi\"0/span\n        span class=\"k\"if/span span class=\"n\"s/spanspan class=\"o\"./spanspan class=\"n\"startswith/spanspan class=\"p\"(/spanspan class=\"s2\"\"...?\"/spanspan class=\"p\"):/span\n            span class=\"n\"unknowns/span span class=\"o\"=/span span class=\"o\"-/spanspan class=\"mi\"1/span\n            span class=\"n\"startindex/span span class=\"o\"=/span span class=\"mi\"4/span\n        span class=\"k\"elif/span span class=\"n\"s/spanspan class=\"o\"./spanspan class=\"n\"startswith/spanspan class=\"p\"(/spanspan class=\"s2\"\"...1\"/spanspan class=\"p\"):/span\n            span class=\"n\"ones/span span class=\"o\"=/span span class=\"o\"-/spanspan class=\"mi\"1/span\n            span class=\"n\"startindex/span span class=\"o\"=/span span class=\"mi\"4/span\n        span class=\"k\"for/span span class=\"n\"index/span span class=\"ow\"in/span span class=\"nb\"range/spanspan class=\"p\"(/spanspan class=\"n\"startindex/spanspan class=\"p\",/span span class=\"nb\"len/spanspan class=\"p\"(/spanspan class=\"n\"s/spanspan class=\"p\")):/span\n            span class=\"n\"ones/span span class=\"o\"lt;lt;=/span span class=\"mi\"1/span\n            span class=\"n\"unknowns/span span class=\"o\"lt;lt;=/span span class=\"mi\"1/span\n            span class=\"n\"c/span span class=\"o\"=/span span class=\"n\"s/spanspan class=\"p\"[/spanspan class=\"n\"index/spanspan class=\"p\"]/span\n            span class=\"k\"if/span span class=\"n\"c/span span class=\"o\"==/span span class=\"s1\"'1'/spanspan class=\"p\":/span\n                span class=\"n\"ones/span span class=\"o\"|=/span span class=\"mi\"1/span\n            span class=\"k\"elif/span span class=\"n\"c/span span class=\"o\"==/span span class=\"s1\"'?'/spanspan class=\"p\":/span\n                span class=\"n\"unknowns/span span class=\"o\"|=/span span class=\"mi\"1/span\n        span class=\"k\"return/span span class=\"n\"KnownBits/spanspan class=\"p\"(/spanspan class=\"n\"ones/spanspan class=\"p\",/span span class=\"n\"unknowns/spanspan class=\"p\")/span\n\n    span class=\"nd\"@staticmethod/span\n    span class=\"k\"def/span span class=\"nf\"all_unknown/spanspan class=\"p\"():/span\nspan class=\"w\"        /spanspan class=\"sd\"\"\"\" convenience constructor for the \"all bits unknown\" abstract value/span\nspan class=\"sd\"        \"\"\"/span\n        span class=\"k\"return/span span class=\"n\"KnownBits/spanspan class=\"o\"./spanspan class=\"n\"from_str/spanspan class=\"p\"(/spanspan class=\"s2\"\"...?\"/spanspan class=\"p\")/span\n/pre/div\n\n\n\n/details\n\npAnd here's a a href=\"https://pytest.org\"pytest/a-style unit test for codestr/code:/p\ndiv class=\"code\"pre class=\"code literal-block\"span class=\"k\"def/span span class=\"nf\"test_str/spanspan class=\"p\"():/span\n    span class=\"k\"assert/span span class=\"nb\"str/spanspan class=\"p\"(/spanspan class=\"n\"KnownBits/spanspan class=\"o\"./spanspan class=\"n\"from_constant/spanspan class=\"p\"(/spanspan class=\"mi\"0/spanspan class=\"p\"))/span span class=\"o\"==/span span class=\"s1\"'0'/span\n    span class=\"k\"assert/span span class=\"nb\"str/spanspan class=\"p\"(/spanspan class=\"n\"KnownBits/spanspan class=\"o\"./spanspan class=\"n\"from_constant/spanspan class=\"p\"(/spanspan class=\"mi\"5/spanspan class=\"p\"))/span span class=\"o\"==/span span class=\"s1\"'101'/span\n    span class=\"k\"assert/span span class=\"nb\"str/spanspan class=\"p\"(/spanspan class=\"n\"KnownBits/spanspan class=\"p\"(/spanspan class=\"mi\"5/spanspan class=\"p\",/span span class=\"mb\"0b10/spanspan class=\"p\"))/span span class=\"o\"==/span span class=\"s1\"'1?1'/span\n    span class=\"k\"assert/span span class=\"nb\"str/spanspan class=\"p\"(/spanspan class=\"n\"KnownBits/spanspan class=\"p\"(/spanspan class=\"o\"~/spanspan class=\"mb\"0b1111/spanspan class=\"p\",/span span class=\"mb\"0b10/spanspan class=\"p\"))/span span class=\"o\"==/span span class=\"s1\"'...100?0'/span\n    span class=\"k\"assert/span span class=\"nb\"str/spanspan class=\"p\"(/spanspan class=\"n\"KnownBits/spanspan class=\"p\"(/spanspan class=\"mi\"1/spanspan class=\"p\",/span span class=\"o\"~/spanspan class=\"mb\"0b1/spanspan class=\"p\"))/span span class=\"o\"==/span span class=\"s1\"'...?1'/span\n/pre/div\n\npAn instance of codeKnownBits/code represents a set of integers, namely those that match\nthe known bits stored in the instance. We can write a method codecontains/code that\ntakes a concrete codeint/code value and returns codeTrue/code if the value matches the\npattern of the known bits:/p\ndiv class=\"code\"pre class=\"code literal-block\"span class=\"k\"class/span span class=\"nc\"KnownBits/spanspan class=\"p\":/span\n    span class=\"o\".../span\n\n    span class=\"k\"def/span span class=\"nf\"contains/spanspan class=\"p\"(/spanspan class=\"bp\"self/spanspan class=\"p\",/span span class=\"n\"value/span span class=\"p\":/span span class=\"nb\"int/spanspan class=\"p\"):/span\nspan class=\"w\"        /spanspan class=\"sd\"\"\"\" Check whether the KnownBits instance contains the concrete integer/span\nspan class=\"sd\"        `value`. \"\"\"/span\n        span class=\"c1\"# check whether value matches the bit pattern. in the places where we/span\n        span class=\"c1\"# know the bits, the value must agree with ones./span\n        span class=\"k\"return/span span class=\"n\"value/span span class=\"o\"amp;/span span class=\"bp\"self/spanspan class=\"o\"./spanspan class=\"n\"knowns/span span class=\"o\"==/span span class=\"bp\"self/spanspan class=\"o\"./spanspan class=\"n\"ones/span\n/pre/div\n\npand a test:/p\ndiv class=\"code\"pre class=\"code literal-block\"span class=\"k\"def/span span class=\"nf\"test_contains/spanspan class=\"p\"():/span\n    span class=\"n\"k1/span span class=\"o\"=/span span class=\"n\"KnownBits/spanspan class=\"o\"./spanspan class=\"n\"from_str/spanspan class=\"p\"(/spanspan class=\"s1\"'1?1'/spanspan class=\"p\")/span\n    span class=\"k\"assert/span span class=\"n\"k1/spanspan class=\"o\"./spanspan class=\"n\"contains/spanspan class=\"p\"(/spanspan class=\"mb\"0b111/spanspan class=\"p\")/span\n    span class=\"k\"assert/span span class=\"n\"k1/spanspan class=\"o\"./spanspan class=\"n\"contains/spanspan class=\"p\"(/spanspan class=\"mb\"0b101/spanspan class=\"p\")/span\n    span class=\"k\"assert/span span class=\"ow\"not/span span class=\"n\"k1/spanspan class=\"o\"./spanspan class=\"n\"contains/spanspan class=\"p\"(/spanspan class=\"mb\"0b110/spanspan class=\"p\")/span\n    span class=\"k\"assert/span span class=\"ow\"not/span span class=\"n\"k1/spanspan class=\"o\"./spanspan class=\"n\"contains/spanspan class=\"p\"(/spanspan class=\"mb\"0b011/spanspan class=\"p\")/span\n\n    span class=\"n\"k2/span span class=\"o\"=/span span class=\"n\"KnownBits/spanspan class=\"o\"./spanspan class=\"n\"from_str/spanspan class=\"p\"(/spanspan class=\"s1\"'...?1'/spanspan class=\"p\")/span span class=\"c1\"# all odd numbers/span\n    span class=\"k\"for/span span class=\"n\"i/span span class=\"ow\"in/span span class=\"nb\"range/spanspan class=\"p\"(/spanspan class=\"o\"-/spanspan class=\"mi\"101/spanspan class=\"p\",/span span class=\"mi\"100/spanspan class=\"p\"):/span\n        span class=\"k\"assert/span span class=\"n\"k2/spanspan class=\"o\"./spanspan class=\"n\"contains/spanspan class=\"p\"(/spanspan class=\"n\"i/spanspan class=\"p\")/span span class=\"o\"==/span span class=\"p\"(/spanspan class=\"n\"i/span span class=\"o\"amp;/span span class=\"mi\"1/spanspan class=\"p\")/span\n/pre/div\n\nh3 id=\"transfer-functions\"Transfer Functions/h3\npNow that we have implemented the basics of the codeKnownBits/code class, we need to\nstart implementing the transfer functions. They are for computing what we know\nabout the emresults/em of an operation, given the knowledge we have about the bits\nof the arguments./p\npWe'll start with a simple unary operation, codeinvert(x)/code (which is code~x/code in Python\nand C syntax), which flips all the bits of at integer. If we know some bits of\nthe arguments, we can compute the corresponding bits of the result. The unknown\nbits remain unknown./p\npHere's the code:/p\ndiv class=\"code\"pre class=\"code literal-block\"span class=\"k\"class/span span class=\"nc\"KnownBits/spanspan class=\"p\":/span\n    span class=\"o\".../span\n\n    span class=\"k\"def/span span class=\"nf\"abstract_invert/spanspan class=\"p\"(/spanspan class=\"bp\"self/spanspan class=\"p\"):/span\n        span class=\"c1\"# self.zeros has bits set where the known 0s are in self/span\n        span class=\"k\"return/span span class=\"n\"KnownBits/spanspan class=\"p\"(/spanspan class=\"bp\"self/spanspan class=\"o\"./spanspan class=\"n\"zeros/spanspan class=\"p\",/span span class=\"bp\"self/spanspan class=\"o\"./spanspan class=\"n\"unknowns/spanspan class=\"p\")/span\n/pre/div\n\npAnd a unit-test:/p\ndiv class=\"code\"pre class=\"code literal-block\"span class=\"k\"def/span span class=\"nf\"test_invert/spanspan class=\"p\"():/span\n    span class=\"n\"k1/span span class=\"o\"=/span span class=\"n\"KnownBits/spanspan class=\"o\"./spanspan class=\"n\"from_str/spanspan class=\"p\"(/spanspan class=\"s1\"'01?01?01?'/spanspan class=\"p\")/span\n    span class=\"n\"k2/span span class=\"o\"=/span span class=\"n\"k1/spanspan class=\"o\"./spanspan class=\"n\"abstract_invert/spanspan class=\"p\"()/span\n    span class=\"k\"assert/span span class=\"nb\"str/spanspan class=\"p\"(/spanspan class=\"n\"k2/spanspan class=\"p\")/span span class=\"o\"==/span span class=\"s1\"'...10?10?10?'/span\n\n    span class=\"n\"k1/span span class=\"o\"=/span span class=\"n\"KnownBits/spanspan class=\"o\"./spanspan class=\"n\"from_str/spanspan class=\"p\"(/spanspan class=\"s1\"'...?'/spanspan class=\"p\")/span\n    span class=\"n\"k2/span span class=\"o\"=/span span class=\"n\"k1/spanspan class=\"o\"./spanspan class=\"n\"abstract_invert/spanspan class=\"p\"()/span\n    span class=\"k\"assert/span span class=\"nb\"str/spanspan class=\"p\"(/spanspan class=\"n\"k2/spanspan class=\"p\")/span span class=\"o\"==/span span class=\"s1\"'...?'/span\n/pre/div\n\npBefore we continue with further transfer functions, we'll think about\ncorrectness of the transfer functions and build up some test infrastructure. To\ntest transfer functions, it's quite important to move being simple example-style\nunit tests. The state-space for more complicated binary transfer functions is\nextremely large and it's too easy to do something wrong in a corner case.\nTherefore we'll look at property-based-test for codeKnownBits/code next./p\nh3 id=\"property-based-tests-with-hypothesis\"Property-based Tests with Hypothesis/h3\npWe want to do property-based tests of codeKnownBits/code, to try\nmake it less likely that we'll get a corner-case in the implementation wrong.\nWe'll use a href=\"https://hypothesis.readthedocs.io/en/latest/\"Hypothesis/a for that./p\npI can't give a decent introduction to Hypothesis here, but want to give a few\nhints about the API. Hypothesis is a way to run unit tests with randomly\ngenerated input. It provides emstrategies/em to describe the data that the test\nfunctions expects. Hypothesis provides primitive strategies (for things like\nintegers, strings, floats, etc) and ways to build composite strategies out of\nthe primitive ones./p\npTo be able to write the tests, we need to generate random codeKnownBits/code instances,\nand we also want an codeint/code instance that is a member of the codeKnownBits/code instance.\nWe generate tuples of code(KnownBits, int)/code together, to ensure this property.\nWe'll ask Hypothesis to generate us a random concrete codeint/code as the concrete\nvalue, and then we'll also generate a second random codeint/code to use as the\ncodeunknown/code masks (i.e. which bits of the concrete int we don't know in the\ncodeKnownBits/code instance). Here's a function that takes two such ints and builds the\ntuple:/p\ndiv class=\"code\"pre class=\"code literal-block\"span class=\"k\"def/span span class=\"nf\"build_knownbits_and_contained_number/spanspan class=\"p\"(/spanspan class=\"n\"concrete_value/span span class=\"p\":/span span class=\"nb\"int/spanspan class=\"p\",/span span class=\"n\"unknowns/span span class=\"p\":/span span class=\"nb\"int/spanspan class=\"p\"):/span\n    span class=\"c1\"# to construct a valid KnownBits instance, we need to mask off the unknown/span\n    span class=\"c1\"# bits/span\n    span class=\"n\"ones/span span class=\"o\"=/span span class=\"n\"concrete_value/span span class=\"o\"amp;/span span class=\"o\"~/spanspan class=\"n\"unknowns/span\n    span class=\"k\"return/span span class=\"n\"KnownBits/spanspan class=\"p\"(/spanspan class=\"n\"ones/spanspan class=\"p\",/span span class=\"n\"unknowns/spanspan class=\"p\"),/span span class=\"n\"concrete_value/span\n/pre/div\n\npWe can turn this function into a hypothesis strategy to generate input data\nusing the codestrategies.builds/code function:/p\ndiv class=\"code\"pre class=\"code literal-block\"span class=\"kn\"from/span span class=\"nn\"hypothesis/span span class=\"kn\"import/span span class=\"n\"strategies/spanspan class=\"p\",/span span class=\"n\"given/spanspan class=\"p\",/span span class=\"n\"settings/span\n\nspan class=\"n\"ints/span span class=\"o\"=/span span class=\"n\"strategies/spanspan class=\"o\"./spanspan class=\"n\"integers/spanspan class=\"p\"()/span\n\nspan class=\"n\"random_knownbits_and_contained_number/span span class=\"o\"=/span span class=\"n\"strategies/spanspan class=\"o\"./spanspan class=\"n\"builds/spanspan class=\"p\"(/span\n    span class=\"n\"build_knownbits_and_contained_number/spanspan class=\"p\",/span\n    span class=\"n\"ints/spanspan class=\"p\",/span span class=\"n\"ints/span\nspan class=\"p\")/span\n/pre/div\n\npOne important special case of codeKnownBits/code are the constants, which contain only\na single concrete value. We'll also generate some of those specifically, and\nthen combine the coderandom_knownbits_and_contained_number/code strategy with it:/p\ndiv class=\"code\"pre class=\"code literal-block\"span class=\"n\"constant_knownbits/span span class=\"o\"=/span span class=\"n\"strategies/spanspan class=\"o\"./spanspan class=\"n\"builds/spanspan class=\"p\"(/span\n    span class=\"k\"lambda/span span class=\"n\"value/spanspan class=\"p\":/span span class=\"p\"(/spanspan class=\"n\"KnownBits/spanspan class=\"o\"./spanspan class=\"n\"from_constant/spanspan class=\"p\"(/spanspan class=\"n\"value/spanspan class=\"p\"),/span span class=\"n\"value/spanspan class=\"p\"),/span\n    span class=\"n\"ints/span\nspan class=\"p\")/span\n\nspan class=\"n\"knownbits_and_contained_number/span span class=\"o\"=/span span class=\"n\"constant_knownbits/span span class=\"o\"|/span span class=\"n\"random_knownbits_and_contained_number/span\n/pre/div\n\npNow we can write the first property-based tests, for the codeKnownBits.contains/code\nmethod:/p\ndiv class=\"code\"pre class=\"code literal-block\"span class=\"nd\"@given/spanspan class=\"p\"(/spanspan class=\"n\"knownbits_and_contained_number/spanspan class=\"p\")/span\nspan class=\"k\"def/span span class=\"nf\"test_contains/spanspan class=\"p\"(/spanspan class=\"n\"t/spanspan class=\"p\"):/span\n    span class=\"n\"k/spanspan class=\"p\",/span span class=\"n\"n/span span class=\"o\"=/span span class=\"n\"t/span\n    span class=\"k\"assert/span span class=\"n\"k/spanspan class=\"o\"./spanspan class=\"n\"contains/spanspan class=\"p\"(/spanspan class=\"n\"t/spanspan class=\"p\")/span\n/pre/div\n\npThe code@given/code decorator is used to tell Hypothesis which strategy to use to\ngenerate random data for the test function. Hypothesis will run the test with a\nnumber of random examples (100 by default). If it finds an error, it will try to\nminimize the example needed that demonstrates the problem, to try to make it\neasier to understand what is going wrong. It also saves all failing cases into\nan example database and tries them again on subsequent runs./p\npThis test is as much a check for whether we got the strategies right as it is\nfor the logic in codeKnownBits.contains/code. Here's an example output of random\nconcrete and abstract values that we are getting here:/p\ndiv class=\"code\"pre class=\"code literal-block\"span class=\"mf\"110000011001101/spanspan class=\"w\" /spanspan class=\"mf\".../spanspan class=\"err\"?/spanspan class=\"mf\"0/spanspan class=\"err\"???/spanspan class=\"mf\"1/span\nspan class=\"mf\"...1011011/spanspan class=\"w\" /spanspan class=\"mf\"...1011011/span\nspan class=\"mf\"...1001101110101000010010011111011/spanspan class=\"w\" /spanspan class=\"mf\"...1001101110101000010010011111011/span\nspan class=\"mf\"...1001101110101000010010011111011/spanspan class=\"w\" /spanspan class=\"mf\"...100110111010100001/spanspan class=\"err\"?/spanspan class=\"mf\"010/spanspan class=\"err\"?/spanspan class=\"mf\"1/spanspan class=\"err\"??/spanspan class=\"mf\"1/spanspan class=\"err\"??/spanspan class=\"mf\"11/span\nspan class=\"mf\"1000001101111101001011010011111101000011000111011001011111101/spanspan class=\"w\" /spanspan class=\"mf\"1000001101111101001011010011111101000011000111011001011111101/span\nspan class=\"mf\"1000001101111101001011010011111101000011000111011001011111101/spanspan class=\"w\" /spanspan class=\"mf\"1000001101111101001011010011111101000011000111/spanspan class=\"err\"????/spanspan class=\"mf\"01/spanspan class=\"err\"?/spanspan class=\"mf\"11/spanspan class=\"err\"?????/spanspan class=\"mf\"1/span\nspan class=\"mf\"1111100000010/spanspan class=\"w\" /spanspan class=\"mf\"1111100000010/span\nspan class=\"mf\"1111100000010/spanspan class=\"w\" /spanspan class=\"mf\".../spanspan class=\"err\"?/spanspan class=\"mf\"11111/spanspan class=\"err\"?/spanspan class=\"mf\"00000/spanspan class=\"err\"??/span\nspan class=\"mf\"110110/spanspan class=\"w\" /spanspan class=\"mf\"110110/span\nspan class=\"mf\"110110/spanspan class=\"w\" /spanspan class=\"mf\".../spanspan class=\"err\"?/spanspan class=\"mf\"00/spanspan class=\"err\"?/spanspan class=\"mf\"00/spanspan class=\"err\"????/spanspan class=\"mf\"11/spanspan class=\"err\"??/spanspan class=\"mf\"10/span\nspan class=\"mf\"110110/spanspan class=\"w\" /spanspan class=\"err\"??/spanspan class=\"mf\"0/spanspan class=\"err\"??/spanspan class=\"mf\"0/span\nspan class=\"mf\"...100010111011111/spanspan class=\"w\" /spanspan class=\"mf\".../spanspan class=\"err\"?/spanspan class=\"mf\"100/spanspan class=\"err\"?/spanspan class=\"mf\"10111/spanspan class=\"err\"??/spanspan class=\"mf\"111/spanspan class=\"err\"?/span\nspan class=\"mf\"...1000100000110001/spanspan class=\"w\" /spanspan class=\"mf\".../spanspan class=\"err\"?/spanspan class=\"mf\"000/spanspan class=\"err\"?/spanspan class=\"mf\"00000/spanspan class=\"err\"??/spanspan class=\"mf\"000/spanspan class=\"err\"?/span\nspan class=\"mf\"110000001110/spanspan class=\"w\" /spanspan class=\"mf\".../spanspan class=\"err\"?/spanspan class=\"mf\"0/spanspan class=\"err\"?/spanspan class=\"mf\"0/spanspan class=\"err\"??/spanspan class=\"mf\"000/spanspan class=\"err\"?/spanspan class=\"mf\"00/spanspan class=\"err\"?/spanspan class=\"mf\"0/spanspan class=\"err\"?/spanspan class=\"mf\"0000000/spanspan class=\"err\"?/spanspan class=\"mf\"00/spanspan class=\"err\"???/spanspan class=\"mf\"0000/spanspan class=\"err\"?????/spanspan class=\"mf\"00/spanspan class=\"err\"???/spanspan class=\"mf\"000/spanspan class=\"err\"?/spanspan class=\"mf\"0/spanspan class=\"err\"?/spanspan class=\"mf\"00/spanspan class=\"err\"?/spanspan class=\"mf\"01/spanspan class=\"err\"?/spanspan class=\"mf\"000/spanspan class=\"err\"?/spanspan class=\"mf\"0/spanspan class=\"err\"??/spanspan class=\"mf\"1/spanspan class=\"err\"??/span\nspan class=\"mf\"110000001110/spanspan class=\"w\" /spanspan class=\"err\"??/spanspan class=\"mf\"000000/spanspan class=\"err\"???/spanspan class=\"mf\"0/span\nspan class=\"mf\"1011011010000001110101001111000010001001011101010010010001000000010101010010001101110101111111010101010010101100110000011110000/spanspan class=\"w\" /spanspan class=\"mf\"1011011010000001110101001111000010001001011101010010010001000000010101010010001101110101111111010101010010101100110000011110000/span\nspan class=\"mf\"...1011010010010100/spanspan class=\"w\" /spanspan class=\"mf\"...1011010010010100/span\nspan class=\"mf\"...1011111110110011/spanspan class=\"w\" /spanspan class=\"mf\"...1011111110110011/span\nspan class=\"mf\"101000011110110/spanspan class=\"w\" /spanspan class=\"mf\"101000011/spanspan class=\"err\"?/spanspan class=\"mf\"10/spanspan class=\"err\"?/spanspan class=\"mf\"1/spanspan class=\"err\"?/span\nspan class=\"mf\"100101/spanspan class=\"w\" /spanspan class=\"err\"?/spanspan class=\"mf\"00/spanspan class=\"err\"?/spanspan class=\"mf\"0/spanspan class=\"err\"?/span\n/pre/div\n\npThat looks suitably random, but we might want to bias our random numbers a\nlittle bit towards common error values like small constants, powers of two, etc.\nLike this:/p\ndiv class=\"code\"pre class=\"code literal-block\"span class=\"n\"INTEGER_WIDTH/span span class=\"o\"=/span span class=\"mi\"64/span\nspan class=\"c1\"# some small integers/span\nspan class=\"n\"ints_special/span span class=\"o\"=/span span class=\"nb\"set/spanspan class=\"p\"(/spanspan class=\"nb\"range/spanspan class=\"p\"(/spanspan class=\"mi\"100/spanspan class=\"p\"))/span\nspan class=\"c1\"# powers of two/span\nspan class=\"n\"ints_special/span span class=\"o\"=/span span class=\"n\"ints_special/spanspan class=\"o\"./spanspan class=\"n\"union/spanspan class=\"p\"(/spanspan class=\"mi\"1/span span class=\"o\"lt;lt;/span span class=\"n\"i/span span class=\"k\"for/span span class=\"n\"i/span span class=\"ow\"in/span span class=\"nb\"range/spanspan class=\"p\"(/spanspan class=\"n\"INTEGER_WIDTH/span span class=\"o\"-/span span class=\"mi\"2/spanspan class=\"p\"))/span\nspan class=\"c1\"# powers of two - 1/span\nspan class=\"n\"ints_special/span span class=\"o\"=/span span class=\"n\"ints_special/spanspan class=\"o\"./spanspan class=\"n\"union/spanspan class=\"p\"((/spanspan class=\"mi\"1/span span class=\"o\"lt;lt;/span span class=\"n\"i/spanspan class=\"p\")/span span class=\"o\"-/span span class=\"mi\"1/span span class=\"k\"for/span span class=\"n\"i/span span class=\"ow\"in/span span class=\"nb\"range/spanspan class=\"p\"(/spanspan class=\"n\"INTEGER_WIDTH/span span class=\"o\"-/span span class=\"mi\"2/spanspan class=\"p\"))/span\nspan class=\"c1\"# negative versions of what we have so far/span\nspan class=\"n\"ints_special/span span class=\"o\"=/span span class=\"n\"ints_special/spanspan class=\"o\"./spanspan class=\"n\"union/spanspan class=\"p\"(/spanspan class=\"o\"-/spanspan class=\"n\"x/span span class=\"k\"for/span span class=\"n\"x/span span class=\"ow\"in/span span class=\"n\"ints_special/spanspan class=\"p\")/span\nspan class=\"c1\"# bit-flipped versions of what we have so far/span\nspan class=\"n\"ints_special/span span class=\"o\"=/span span class=\"n\"ints_special/spanspan class=\"o\"./spanspan class=\"n\"union/spanspan class=\"p\"(/spanspan class=\"o\"~/spanspan class=\"n\"x/span span class=\"k\"for/span span class=\"n\"x/span span class=\"ow\"in/span span class=\"n\"ints_special/spanspan class=\"p\")/span\nspan class=\"n\"ints_special/span span class=\"o\"=/span span class=\"nb\"list/spanspan class=\"p\"(/spanspan class=\"n\"ints_special/spanspan class=\"p\")/span\nspan class=\"c1\"# sort them (because hypothesis simplifies towards earlier elements in the list)/span\nspan class=\"n\"ints_special/spanspan class=\"o\"./spanspan class=\"n\"sort/spanspan class=\"p\"(/spanspan class=\"n\"key/spanspan class=\"o\"=/spanspan class=\"k\"lambda/span span class=\"n\"element/spanspan class=\"p\":/span span class=\"p\"(/spanspan class=\"nb\"abs/spanspan class=\"p\"(/spanspan class=\"n\"element/spanspan class=\"p\"),/span span class=\"n\"element/span span class=\"o\"lt;/span span class=\"mi\"0/spanspan class=\"p\"))/span\n\nspan class=\"n\"ints/span span class=\"o\"=/span span class=\"n\"strategies/spanspan class=\"o\"./spanspan class=\"n\"sampled_from/spanspan class=\"p\"(/spanspan class=\"n\"ints_special/spanspan class=\"p\")/span span class=\"o\"|/span span class=\"n\"strategies/spanspan class=\"o\"./spanspan class=\"n\"integers/spanspan class=\"p\"()/span\n/pre/div\n\npNow we get data like this:/p\ndiv class=\"code\"pre class=\"code literal-block\"span class=\"mf\"1110/spanspan class=\"w\" /spanspan class=\"mf\"1110/span\nspan class=\"mf\"...10000000000000000001/spanspan class=\"w\" /spanspan class=\"mf\"...10000/spanspan class=\"err\"??/spanspan class=\"mf\"0/spanspan class=\"err\"??/spanspan class=\"mf\"0000/spanspan class=\"err\"??/spanspan class=\"mf\"00/spanspan class=\"err\"?/spanspan class=\"mf\"1/span\nspan class=\"mf\"1/spanspan class=\"w\" /spanspan class=\"err\"??/spanspan class=\"mf\"0/spanspan class=\"err\"??/spanspan class=\"mf\"0000/spanspan class=\"err\"??/spanspan class=\"mf\"00/spanspan class=\"err\"?/spanspan class=\"mf\"1/span\nspan class=\"mf\"1/spanspan class=\"w\" /spanspan class=\"err\"?/span\nspan class=\"mf\"...10101100/spanspan class=\"w\" /spanspan class=\"mf\"...10101100/span\nspan class=\"mf\"110000000011001010111011111111111111011110010001001100110001011/spanspan class=\"w\" /spanspan class=\"mf\".../spanspan class=\"err\"?/spanspan class=\"mf\"0/spanspan class=\"err\"?/spanspan class=\"mf\"101/spanspan class=\"err\"?/span\nspan class=\"mf\"110000000011001010111011111111111111011110010001001100110001011/spanspan class=\"w\" /spanspan class=\"err\"??/spanspan class=\"mf\"00000000/spanspan class=\"err\"??/spanspan class=\"mf\"00/spanspan class=\"err\"?/spanspan class=\"mf\"0/spanspan class=\"err\"?/spanspan class=\"mf\"0/spanspan class=\"err\"???/spanspan class=\"mf\"0/spanspan class=\"err\"??????????????/spanspan class=\"mf\"0/spanspan class=\"err\"????/spanspan class=\"mf\"00/spanspan class=\"err\"?/spanspan class=\"mf\"000/spanspan class=\"err\"?/spanspan class=\"mf\"00/spanspan class=\"err\"??/spanspan class=\"mf\"00/spanspan class=\"err\"??/spanspan class=\"mf\"000/spanspan class=\"err\"?/spanspan class=\"mf\"0/spanspan class=\"err\"??/span\nspan class=\"mf\"...1011111111111111111111111111/spanspan class=\"w\" /spanspan class=\"mf\".../spanspan class=\"err\"?/spanspan class=\"mf\"11/spanspan class=\"err\"?/spanspan class=\"mf\"11/spanspan class=\"err\"??/span\nspan class=\"mf\"...1011111111111111111111111111/spanspan class=\"w\" /spanspan class=\"mf\".../spanspan class=\"err\"?/spanspan class=\"mf\"0/spanspan class=\"err\"??????????????????????????/span\nspan class=\"mf\"0/spanspan class=\"w\" /spanspan class=\"mf\".../spanspan class=\"err\"?/spanspan class=\"mf\"0/spanspan class=\"err\"??????????????????????????/span\nspan class=\"mf\"101101/spanspan class=\"w\" /spanspan class=\"mf\"101101/span\nspan class=\"mf\"111111111111111111111111111111111111111111111/spanspan class=\"w\" /spanspan class=\"mf\"111111111111111111111111111111111111111111111/span\nspan class=\"mf\"10111/spanspan class=\"w\" /spanspan class=\"mf\"10111/span\nspan class=\"mf\"...101100/spanspan class=\"w\" /spanspan class=\"mf\"...1/spanspan class=\"err\"?/spanspan class=\"mf\"111011/spanspan class=\"err\"?/spanspan class=\"mf\"0/span\nspan class=\"mf\"101000/spanspan class=\"w\" /spanspan class=\"err\"?/spanspan class=\"mf\"001010/spanspan class=\"err\"?/spanspan class=\"mf\"0/span\nspan class=\"mf\"101000/spanspan class=\"w\" /spanspan class=\"err\"?/spanspan class=\"mf\"0/spanspan class=\"err\"?/spanspan class=\"mf\"000/span\nspan class=\"mf\"110010/spanspan class=\"w\" /spanspan class=\"mf\"110010/span\nspan class=\"mf\"...100111/spanspan class=\"w\" /spanspan class=\"mf\"...100111/span\nspan class=\"mf\"1111011010010/spanspan class=\"w\" /spanspan class=\"mf\"1111011010010/span\nspan class=\"mf\"...1000000000000000000000000000000000000/spanspan class=\"w\" /spanspan class=\"mf\"...1000000000000000000000000000000000000/span\n/pre/div\n\npWe can also write a test that checks that the somewhat tricky logic in\ncode__str__/code and codefrom_str/code is correct, by making sure that the two functions\nround-trip (ie converting a codeKnownBits/code to a string and then back to a\ncodeKnownBits/code instance produces the same abstract value)./p\ndiv class=\"code\"pre class=\"code literal-block\"span class=\"nd\"@given/spanspan class=\"p\"(/spanspan class=\"n\"knownbits_and_contained_number/spanspan class=\"p\")/span\nspan class=\"k\"def/span span class=\"nf\"test_hypothesis_str_roundtrips/spanspan class=\"p\"(/spanspan class=\"n\"t1/spanspan class=\"p\"):/span\n    span class=\"n\"k1/spanspan class=\"p\",/span span class=\"n\"n1/span span class=\"o\"=/span span class=\"n\"t1/span\n    span class=\"n\"s/span span class=\"o\"=/span span class=\"nb\"str/spanspan class=\"p\"(/spanspan class=\"n\"k1/spanspan class=\"p\")/span\n    span class=\"n\"k2/span span class=\"o\"=/span span class=\"n\"KnownBits/spanspan class=\"o\"./spanspan class=\"n\"from_str/spanspan class=\"p\"(/spanspan class=\"n\"s/spanspan class=\"p\")/span\n    span class=\"k\"assert/span span class=\"n\"k1/spanspan class=\"o\"./spanspan class=\"n\"ones/span span class=\"o\"==/span span class=\"n\"k2/spanspan class=\"o\"./spanspan class=\"n\"ones/span\n    span class=\"k\"assert/span span class=\"n\"k1/spanspan class=\"o\"./spanspan class=\"n\"unknowns/span span class=\"o\"==/span span class=\"n\"k2/spanspan class=\"o\"./spanspan class=\"n\"unknowns/span\n/pre/div\n\npNow let's actually apply this infrastructure to test codeabstract_invert/code./p\nh3 id=\"when-are-transfer-functions-correct-how-do-we-test-them\"When are Transfer Functions Correct? How do we test them?/h3\npAbstract values, i.e. instances of codeKnownBits/code represent emsets/em of concrete\nvalues. We want the transfer functions to compute emoverapproximations/em of the\nconcrete values. So if we have an arbitrary abstract value codek/code, with a concrete\nnumber coden/code that is a member of the abstract values (i.e.\ncodek.contains(n) == True/code) then the result of the concrete operation codeop(n)/code\nstrongmust/strong be a member of the result of the abstract operation codek.abstract_op()/code\n(i.e. codek.abstract_op().contains(op(n)) == True/code)./p\npChecking the correctness/overapproximation property is a good match for\nhypothesis. Here's what the test for codeabstract_invert/code looks like:/p\ndiv class=\"code\"pre class=\"code literal-block\"span class=\"nd\"@given/spanspan class=\"p\"(/spanspan class=\"n\"knownbits_and_contained_number/spanspan class=\"p\")/span\nspan class=\"k\"def/span span class=\"nf\"test_hypothesis_invert/spanspan class=\"p\"(/spanspan class=\"n\"t/spanspan class=\"p\"):/span\n    span class=\"n\"k1/spanspan class=\"p\",/span span class=\"n\"n1/span span class=\"o\"=/span span class=\"n\"t1/span\n    span class=\"n\"n2/span span class=\"o\"=/span span class=\"o\"~/spanspan class=\"n\"n1/span span class=\"c1\"# compute the real result/span\n    span class=\"n\"k2/span span class=\"o\"=/span span class=\"n\"k1/spanspan class=\"o\"./spanspan class=\"n\"abstract_invert/spanspan class=\"p\"()/span span class=\"c1\"# compute the abstract result/span\n    span class=\"k\"assert/span span class=\"n\"k2/spanspan class=\"o\"./spanspan class=\"n\"contains/spanspan class=\"p\"(/spanspan class=\"n\"n2/spanspan class=\"p\")/span span class=\"c1\"# the abstract result must contain the real result/span\n/pre/div\n\npThis is the emonly/em condition needed for codeabstract_invert/code to be correct. If\ncodeabstract_invert/code fulfils this property for every combination of abstract and\nconcrete value then codeabstract_invert/code is correct. Note however, that this test\ndoes not actually check whether codeabstract_invert/code gives us precise results. A\ncorrect (but imprecise) implementation of codeabstract_invert/code would simply return\na completely unknown result, regardless of what is known about the input\ncodeKnownBits/code./p\npThe \"proper\" CS term for this notion of correctness is called emsoundness/em. The\ncorrectness condition on the transfer functions is called a emGalois\nconnection/em. I won't go into any mathematical/technical details here, but\nwanted to at least mention the terms. I found a href=\"https://web.njit.edu/~mjk76/\"Martin\nKellogg/a's\na href=\"https://web.njit.edu/~mjk76/teaching/cs684-sp24/assets/lecture-12.pdf#34\"slides/a\nto be quite an approachable introduction to the Galois connection and how to\nshow soundness./p\nh3 id=\"implementing-binary-transfer-functions\"Implementing Binary Transfer Functions/h3\npNow we have infrastructure in place for testing transfer functions with random\ninputs. With that we can start thinking about the more complicated case, that of\nbinary operations. Let's start with the simpler ones, codeand/code and codeor/code. For codeand/code,\nwe can know a code0/code bit in the result if either of the input bits are known code0/code;\nor we can know a code1/code bit in the result if both input bits are known code1/code.\nOtherwise the resulting bit is unknown. Let's look at all the combinations:/p\ndiv class=\"code\"pre class=\"code literal-block\"and\ninput1: 000111???\ninput2: 01?01?01?\nresult: 00001?0??\n/pre/div\n\ndiv class=\"code\"pre class=\"code literal-block\"span class=\"k\"class/span span class=\"nc\"KnownBits/spanspan class=\"p\":/span\n    span class=\"o\".../span\n\n    span class=\"k\"def/span span class=\"nf\"abstract_and/spanspan class=\"p\"(/spanspan class=\"bp\"self/spanspan class=\"p\",/span span class=\"n\"other/spanspan class=\"p\"):/span\n        span class=\"n\"ones/span span class=\"o\"=/span span class=\"bp\"self/spanspan class=\"o\"./spanspan class=\"n\"ones/span span class=\"o\"amp;/span span class=\"n\"other/spanspan class=\"o\"./spanspan class=\"n\"ones/span span class=\"c1\"# known ones/span\n        span class=\"n\"knowns/span span class=\"o\"=/span span class=\"bp\"self/spanspan class=\"o\"./spanspan class=\"n\"zeros/span span class=\"o\"|/span span class=\"n\"other/spanspan class=\"o\"./spanspan class=\"n\"zeros/span span class=\"o\"|/span span class=\"n\"ones/span\n        span class=\"k\"return/span span class=\"n\"KnownBits/spanspan class=\"p\"(/spanspan class=\"n\"ones/spanspan class=\"p\",/span span class=\"o\"~/spanspan class=\"n\"knowns/spanspan class=\"p\")/span\n/pre/div\n\npHere's an example unit-test and a property-based test for codeand/code:/p\ndiv class=\"code\"pre class=\"code literal-block\"span class=\"k\"def/span span class=\"nf\"test_and/spanspan class=\"p\"():/span\n    span class=\"c1\"# test all combinations of 0, 1, ? in one example/span\n    span class=\"n\"k1/span span class=\"o\"=/span span class=\"n\"KnownBits/spanspan class=\"o\"./spanspan class=\"n\"from_str/spanspan class=\"p\"(/spanspan class=\"s1\"'01?01?01?'/spanspan class=\"p\")/span\n    span class=\"n\"k2/span span class=\"o\"=/span span class=\"n\"KnownBits/spanspan class=\"o\"./spanspan class=\"n\"from_str/spanspan class=\"p\"(/spanspan class=\"s1\"'000111???'/spanspan class=\"p\")/span\n    span class=\"n\"res/span span class=\"o\"=/span span class=\"n\"k1/spanspan class=\"o\"./spanspan class=\"n\"abstract_and/spanspan class=\"p\"(/spanspan class=\"n\"k2/spanspan class=\"p\")/span     span class=\"c1\"# should be: 0...00001?0??/span\n    span class=\"k\"assert/span span class=\"nb\"str/spanspan class=\"p\"(/spanspan class=\"n\"res/spanspan class=\"p\")/span span class=\"o\"==/span   span class=\"s2\"\"1?0??\"/span\n\nspan class=\"nd\"@given/spanspan class=\"p\"(/spanspan class=\"n\"knownbits_and_contained_number/spanspan class=\"p\",/span span class=\"n\"knownbits_and_contained_number/spanspan class=\"p\")/span\nspan class=\"k\"def/span span class=\"nf\"test_hypothesis_and/spanspan class=\"p\"(/spanspan class=\"n\"t1/spanspan class=\"p\",/span span class=\"n\"t2/spanspan class=\"p\"):/span\n    span class=\"n\"k1/spanspan class=\"p\",/span span class=\"n\"n1/span span class=\"o\"=/span span class=\"n\"t1/span\n    span class=\"n\"k2/spanspan class=\"p\",/span span class=\"n\"n2/span span class=\"o\"=/span span class=\"n\"t2/span\n    span class=\"n\"k3/span span class=\"o\"=/span span class=\"n\"k1/spanspan class=\"o\"./spanspan class=\"n\"abstract_and/spanspan class=\"p\"(/spanspan class=\"n\"k2/spanspan class=\"p\")/span\n    span class=\"n\"n3/span span class=\"o\"=/span span class=\"n\"n1/span span class=\"o\"amp;/span span class=\"n\"n2/span\n    span class=\"k\"assert/span span class=\"n\"k3/spanspan class=\"o\"./spanspan class=\"n\"contains/spanspan class=\"p\"(/spanspan class=\"n\"n3/spanspan class=\"p\")/span\n/pre/div\n\npTo implement codeor/code is pretty similar. The result is known code1/code where either of the\ninputs is code1/code. The result is known code0/code where both inputs are known code0/code, and code?/code\notherwise./p\ndiv class=\"code\"pre class=\"code literal-block\"or\ninput1: 000111???\ninput2: 01?01?01?\nresult: 01?111?1?\n/pre/div\n\ndiv class=\"code\"pre class=\"code literal-block\"span class=\"k\"class/span span class=\"nc\"KnownBits/spanspan class=\"p\":/span\n    span class=\"o\".../span\n\n    span class=\"k\"def/span span class=\"nf\"abstract_or/spanspan class=\"p\"(/spanspan class=\"bp\"self/spanspan class=\"p\",/span span class=\"n\"other/spanspan class=\"p\"):/span\n        span class=\"n\"ones/span span class=\"o\"=/span span class=\"bp\"self/spanspan class=\"o\"./spanspan class=\"n\"ones/span span class=\"o\"|/span span class=\"n\"other/spanspan class=\"o\"./spanspan class=\"n\"ones/span\n        span class=\"n\"zeros/span span class=\"o\"=/span span class=\"bp\"self/spanspan class=\"o\"./spanspan class=\"n\"zeros/span span class=\"o\"amp;/span span class=\"n\"other/spanspan class=\"o\"./spanspan class=\"n\"zeros/span\n        span class=\"n\"knowns/span span class=\"o\"=/span span class=\"n\"ones/span span class=\"o\"|/span span class=\"n\"zeros/span\n        span class=\"k\"return/span span class=\"n\"KnownBits/spanspan class=\"p\"(/spanspan class=\"n\"ones/spanspan class=\"p\",/span span class=\"o\"~/spanspan class=\"n\"knowns/spanspan class=\"p\")/span\n/pre/div\n\npHere's an example unit-test and a property-based test for codeor/code:/p\ndiv class=\"code\"pre class=\"code literal-block\"span class=\"k\"def/span span class=\"nf\"test_or/spanspan class=\"p\"():/span\n    span class=\"n\"k1/span span class=\"o\"=/span span class=\"n\"KnownBits/spanspan class=\"o\"./spanspan class=\"n\"from_str/spanspan class=\"p\"(/spanspan class=\"s1\"'01?01?01?'/spanspan class=\"p\")/span\n    span class=\"n\"k2/span span class=\"o\"=/span span class=\"n\"KnownBits/spanspan class=\"o\"./spanspan class=\"n\"from_str/spanspan class=\"p\"(/spanspan class=\"s1\"'000111???'/spanspan class=\"p\")/span\n    span class=\"n\"res/span span class=\"o\"=/span span class=\"n\"k1/spanspan class=\"o\"./spanspan class=\"n\"abstract_or/spanspan class=\"p\"(/spanspan class=\"n\"k2/spanspan class=\"p\")/span     span class=\"c1\"# should be:  0...01?111?1?/span\n    span class=\"k\"assert/span span class=\"nb\"str/spanspan class=\"p\"(/spanspan class=\"n\"res/spanspan class=\"p\")/span span class=\"o\"==/span   span class=\"s2\"\"1?111?1?\"/span\n\nspan class=\"nd\"@given/spanspan class=\"p\"(/spanspan class=\"n\"knownbits_and_contained_number/spanspan class=\"p\",/span span class=\"n\"knownbits_and_contained_number/spanspan class=\"p\")/span\nspan class=\"k\"def/span span class=\"nf\"test_hypothesis_or/spanspan class=\"p\"(/spanspan class=\"n\"t1/spanspan class=\"p\",/span span class=\"n\"t2/spanspan class=\"p\"):/span\n    span class=\"n\"k1/spanspan class=\"p\",/span span class=\"n\"n1/span span class=\"o\"=/span span class=\"n\"t1/span\n    span class=\"n\"k2/spanspan class=\"p\",/span span class=\"n\"n2/span span class=\"o\"=/span span class=\"n\"t2/span\n    span class=\"n\"k3/span span class=\"o\"=/span span class=\"n\"k1/spanspan class=\"o\"./spanspan class=\"n\"abstract_or/spanspan class=\"p\"(/spanspan class=\"n\"k2/spanspan class=\"p\")/span\n    span class=\"n\"n3/span span class=\"o\"=/span span class=\"n\"n1/span span class=\"o\"|/span span class=\"n\"n2/span\n    span class=\"k\"assert/span span class=\"n\"k3/spanspan class=\"o\"./spanspan class=\"n\"contains/spanspan class=\"p\"(/spanspan class=\"n\"n3/spanspan class=\"p\")/span\n/pre/div\n\npImplementing support for codeabstract_xor/code is relatively simple, and left as an\nexercise :-)./p\nh3 id=\"addition-and-subtraction\"Addition and Subtraction/h3\npcodeinvert/code, codeand/code, and codeor/code are relatively simple transfer functions to write,\nbecause they compose over the individual bits of the integers. The arithmetic\nfunctions codeadd/code and codesub/code are significantly harder, because of carries and\nborrows. Coming up with the formulas for them and gaining an intuitive\nunderstanding is quite tricky and involves carefully going through a few\nexamples with pen and paper. When implementing this in PyPy, Nico and I didn't\ncome up with the implementation ourselves, but instead took them from the\na href=\"https://arxiv.org/abs/2105.05398\"Tristate Numbers/a paper. Here's the code,\nwith example tests and hypothesis tests:/p\ndiv class=\"code\"pre class=\"code literal-block\"span class=\"k\"class/span span class=\"nc\"KnownBits/spanspan class=\"p\":/span\n    span class=\"o\".../span\n\n    span class=\"k\"def/span span class=\"nf\"abstract_add/spanspan class=\"p\"(/spanspan class=\"bp\"self/spanspan class=\"p\",/span span class=\"n\"other/spanspan class=\"p\"):/span\n        span class=\"n\"sum_ones/span span class=\"o\"=/span span class=\"bp\"self/spanspan class=\"o\"./spanspan class=\"n\"ones/span span class=\"o\"+/span span class=\"n\"other/spanspan class=\"o\"./spanspan class=\"n\"ones/span\n        span class=\"n\"sum_unknowns/span span class=\"o\"=/span span class=\"bp\"self/spanspan class=\"o\"./spanspan class=\"n\"unknowns/span span class=\"o\"+/span span class=\"n\"other/spanspan class=\"o\"./spanspan class=\"n\"unknowns/span\n        span class=\"n\"all_carries/span span class=\"o\"=/span span class=\"n\"sum_ones/span span class=\"o\"+/span span class=\"n\"sum_unknowns/span\n        span class=\"n\"ones_carries/span span class=\"o\"=/span span class=\"n\"all_carries/span span class=\"o\"^/span span class=\"n\"sum_ones/span\n        span class=\"n\"unknowns/span span class=\"o\"=/span span class=\"bp\"self/spanspan class=\"o\"./spanspan class=\"n\"unknowns/span span class=\"o\"|/span span class=\"n\"other/spanspan class=\"o\"./spanspan class=\"n\"unknowns/span span class=\"o\"|/span span class=\"n\"ones_carries/span\n        span class=\"n\"ones/span span class=\"o\"=/span span class=\"n\"sum_ones/span span class=\"o\"amp;/span span class=\"o\"~/spanspan class=\"n\"unknowns/span\n        span class=\"k\"return/span span class=\"n\"KnownBits/spanspan class=\"p\"(/spanspan class=\"n\"ones/spanspan class=\"p\",/span span class=\"n\"unknowns/spanspan class=\"p\")/span\n\n    span class=\"k\"def/span span class=\"nf\"abstract_sub/spanspan class=\"p\"(/spanspan class=\"bp\"self/spanspan class=\"p\",/span span class=\"n\"other/spanspan class=\"p\"):/span\n        span class=\"n\"diff_ones/span span class=\"o\"=/span span class=\"bp\"self/spanspan class=\"o\"./spanspan class=\"n\"ones/span span class=\"o\"-/span span class=\"n\"other/spanspan class=\"o\"./spanspan class=\"n\"ones/span\n        span class=\"n\"val_borrows/span span class=\"o\"=/span span class=\"p\"(/spanspan class=\"n\"diff_ones/span span class=\"o\"+/span span class=\"bp\"self/spanspan class=\"o\"./spanspan class=\"n\"unknowns/spanspan class=\"p\")/span span class=\"o\"^/span span class=\"p\"(/spanspan class=\"n\"diff_ones/span span class=\"o\"-/span span class=\"n\"other/spanspan class=\"o\"./spanspan class=\"n\"unknowns/spanspan class=\"p\")/span\n        span class=\"n\"unknowns/span span class=\"o\"=/span span class=\"bp\"self/spanspan class=\"o\"./spanspan class=\"n\"unknowns/span span class=\"o\"|/span span class=\"n\"other/spanspan class=\"o\"./spanspan class=\"n\"unknowns/span span class=\"o\"|/span span class=\"n\"val_borrows/span\n        span class=\"n\"ones/span span class=\"o\"=/span span class=\"n\"diff_ones/span span class=\"o\"amp;/span span class=\"o\"~/spanspan class=\"n\"unknowns/span\n        span class=\"k\"return/span span class=\"n\"KnownBits/spanspan class=\"p\"(/spanspan class=\"n\"ones/spanspan class=\"p\",/span span class=\"n\"unknowns/spanspan class=\"p\")/span\n\n\nspan class=\"k\"def/span span class=\"nf\"test_add/spanspan class=\"p\"():/span\n    span class=\"n\"k1/span span class=\"o\"=/span span class=\"n\"KnownBits/spanspan class=\"o\"./spanspan class=\"n\"from_str/spanspan class=\"p\"(/spanspan class=\"s1\"'0?10?10?10'/spanspan class=\"p\")/span\n    span class=\"n\"k2/span span class=\"o\"=/span span class=\"n\"KnownBits/spanspan class=\"o\"./spanspan class=\"n\"from_str/spanspan class=\"p\"(/spanspan class=\"s1\"'0???111000'/spanspan class=\"p\")/span\n    span class=\"n\"res/span span class=\"o\"=/span span class=\"n\"k1/spanspan class=\"o\"./spanspan class=\"n\"abstract_add/spanspan class=\"p\"(/spanspan class=\"n\"k2/spanspan class=\"p\")/span\n    span class=\"k\"assert/span span class=\"nb\"str/spanspan class=\"p\"(/spanspan class=\"n\"res/spanspan class=\"p\")/span span class=\"o\"==/span   span class=\"s2\"\"?????01?10\"/span\n\nspan class=\"k\"def/span span class=\"nf\"test_sub/spanspan class=\"p\"():/span\n    span class=\"n\"k1/span span class=\"o\"=/span span class=\"n\"KnownBits/spanspan class=\"o\"./spanspan class=\"n\"from_str/spanspan class=\"p\"(/spanspan class=\"s1\"'0?10?10?10'/spanspan class=\"p\")/span\n    span class=\"n\"k2/span span class=\"o\"=/span span class=\"n\"KnownBits/spanspan class=\"o\"./spanspan class=\"n\"from_str/spanspan class=\"p\"(/spanspan class=\"s1\"'0???111000'/spanspan class=\"p\")/span\n    span class=\"n\"res/span span class=\"o\"=/span span class=\"n\"k1/spanspan class=\"o\"./spanspan class=\"n\"abstract_sub/spanspan class=\"p\"(/spanspan class=\"n\"k2/spanspan class=\"p\")/span\n    span class=\"k\"assert/span span class=\"nb\"str/spanspan class=\"p\"(/spanspan class=\"n\"res/spanspan class=\"p\")/span span class=\"o\"==/span   span class=\"s2\"\"...?11?10\"/span\n    span class=\"n\"k1/span span class=\"o\"=/span span class=\"n\"KnownBits/spanspan class=\"o\"./spanspan class=\"n\"from_str/spanspan class=\"p\"(/span    span class=\"s1\"'...1?10?10?10'/spanspan class=\"p\")/span\n    span class=\"n\"k2/span span class=\"o\"=/span span class=\"n\"KnownBits/spanspan class=\"o\"./spanspan class=\"n\"from_str/spanspan class=\"p\"(/spanspan class=\"s1\"'...10000???111000'/spanspan class=\"p\")/span\n    span class=\"n\"res/span span class=\"o\"=/span span class=\"n\"k1/spanspan class=\"o\"./spanspan class=\"n\"abstract_sub/spanspan class=\"p\"(/spanspan class=\"n\"k2/spanspan class=\"p\")/span\n    span class=\"k\"assert/span span class=\"nb\"str/spanspan class=\"p\"(/spanspan class=\"n\"res/spanspan class=\"p\")/span span class=\"o\"==/span   span class=\"s2\"\"111?????11?10\"/span\n\nspan class=\"nd\"@given/spanspan class=\"p\"(/spanspan class=\"n\"knownbits_and_contained_number/spanspan class=\"p\",/span span class=\"n\"knownbits_and_contained_number/spanspan class=\"p\")/span\nspan class=\"k\"def/span span class=\"nf\"test_hypothesis_add/spanspan class=\"p\"(/spanspan class=\"n\"t1/spanspan class=\"p\",/span span class=\"n\"t2/spanspan class=\"p\"):/span\n    span class=\"n\"k1/spanspan class=\"p\",/span span class=\"n\"n1/span span class=\"o\"=/span span class=\"n\"t1/span\n    span class=\"n\"k2/spanspan class=\"p\",/span span class=\"n\"n2/span span class=\"o\"=/span span class=\"n\"t2/span\n    span class=\"n\"k3/span span class=\"o\"=/span span class=\"n\"k1/spanspan class=\"o\"./spanspan class=\"n\"abstract_add/spanspan class=\"p\"(/spanspan class=\"n\"k2/spanspan class=\"p\")/span\n    span class=\"n\"n3/span span class=\"o\"=/span span class=\"n\"n1/span span class=\"o\"+/span span class=\"n\"n2/span\n    span class=\"k\"assert/span span class=\"n\"k3/spanspan class=\"o\"./spanspan class=\"n\"contains/spanspan class=\"p\"(/spanspan class=\"n\"n3/spanspan class=\"p\")/span\n\nspan class=\"nd\"@given/spanspan class=\"p\"(/spanspan class=\"n\"knownbits_and_contained_number/spanspan class=\"p\",/span span class=\"n\"knownbits_and_contained_number/spanspan class=\"p\")/span\nspan class=\"k\"def/span span class=\"nf\"test_hypothesis_sub/spanspan class=\"p\"(/spanspan class=\"n\"t1/spanspan class=\"p\",/span span class=\"n\"t2/spanspan class=\"p\"):/span\n    span class=\"n\"k1/spanspan class=\"p\",/span span class=\"n\"n1/span span class=\"o\"=/span span class=\"n\"t1/span\n    span class=\"n\"k2/spanspan class=\"p\",/span span class=\"n\"n2/span span class=\"o\"=/span span class=\"n\"t2/span\n    span class=\"n\"k3/span span class=\"o\"=/span span class=\"n\"k1/spanspan class=\"o\"./spanspan class=\"n\"abstract_sub/spanspan class=\"p\"(/spanspan class=\"n\"k2/spanspan class=\"p\")/span\n    span class=\"n\"n3/span span class=\"o\"=/span span class=\"n\"n1/span span class=\"o\"-/span span class=\"n\"n2/span\n    span class=\"k\"assert/span span class=\"n\"k3/spanspan class=\"o\"./spanspan class=\"n\"contains/spanspan class=\"p\"(/spanspan class=\"n\"n3/spanspan class=\"p\")/span\n/pre/div\n\npNow we are in a pretty good situation, and have implemented abstract versions\nfor a bunch of important arithmetic and binary functions. What's also surprising\nis that the implementation of all of the transfer functions is quite efficient.\nWe didn't have to write loops over the individual bits at all, instead we found\nclosed form expressions using primitive operations on the underlying integers\ncodeones/code and codeunknowns/code. This means that computing the results of abstract\noperations is quite efficient, which is important when using the abstract domain\nin the context of a JIT compiler./p\nh3 id=\"proving-correctness-of-the-transfer-functions-with-z3\"Proving correctness of the transfer functions with Z3/h3\npAs one can probably tell from my recent posts, I've been thinking about\ncompiler correctness a lot. Getting the transfer functions absolutely\ncorrect is really crucial, because a bug in them would lead to miscompilation of\nPython code when the abstract domain is added to the JIT. While the randomized\ntests are great, it's still entirely possible for them to miss bugs. The state\nspace for the arguments of a binary transfer function is code3**64 * 3**64/code, and if\nonly a small part of that contains wrong behaviour it would be really unlikely\nfor us to find it with random tests by chance. Therefore I was reluctant to\nmerge the PyPy branch that contained the new abstract domain for a long time./p\npTo increase our confidence in the correctness of the transfer functions further,\nwe can use Z3 to emprove/em their correctness, which gives us much stronger\nguarantees (not 100%, obviously). In this subsection I will show how to do that./p\npHere's an attempt to do this manually in the Python repl:/p\ndiv class=\"code\"pre class=\"code literal-block\"span class=\"o\"gt;gt;gt;gt;/spanspan class=\"w\" /spanspan class=\"kn\"import/spanspan class=\"w\" /spanspan class=\"nn\"z3/span\nspan class=\"o\"gt;gt;gt;gt;/spanspan class=\"w\" /spanspan class=\"n\"solver/spanspan class=\"w\" /spanspan class=\"o\"=/spanspan class=\"w\" /spanspan class=\"n\"z3/spanspan class=\"o\"./spanspan class=\"n\"Solver/spanspan class=\"p\"()/span\nspan class=\"o\"gt;gt;gt;gt;/spanspan class=\"w\" /spanspan class=\"c1\"# like last blog post, proof by failing to find counterexamples/span\nspan class=\"o\"gt;gt;gt;gt;/spanspan class=\"w\" /spanspan class=\"k\"def/spanspan class=\"w\" /spanspan class=\"nf\"prove/spanspan class=\"p\"(/spanspan class=\"n\"cond/spanspan class=\"p\"):/spanspan class=\"w\" /spanspan class=\"k\"assert/spanspan class=\"w\" /spanspan class=\"n\"solver/spanspan class=\"o\"./spanspan class=\"n\"check/spanspan class=\"p\"(/spanspan class=\"n\"z3/spanspan class=\"o\"./spanspan class=\"n\"Not/spanspan class=\"p\"(/spanspan class=\"n\"cond/spanspan class=\"p\"))/spanspan class=\"w\" /spanspan class=\"o\"==/spanspan class=\"w\" /spanspan class=\"n\"z3/spanspan class=\"o\"./spanspan class=\"n\"unsat/span\nspan class=\"o\"gt;gt;gt;gt;/span\nspan class=\"o\"gt;gt;gt;gt;/spanspan class=\"w\" /spanspan class=\"c1\"# let's set up a z3 bitvector variable for an arbitrary concrete value/span\nspan class=\"o\"gt;gt;gt;gt;/spanspan class=\"w\" /spanspan class=\"n\"n1/spanspan class=\"w\" /spanspan class=\"o\"=/spanspan class=\"w\" /spanspan class=\"n\"z3/spanspan class=\"o\"./spanspan class=\"n\"BitVec/spanspan class=\"p\"(/spanspan class=\"s1\"'concrete_value'/spanspan class=\"p\",/spanspan class=\"w\" /spanspan class=\"mi\"64/spanspan class=\"p\")/span\nspan class=\"o\"gt;gt;gt;gt;/spanspan class=\"w\" /spanspan class=\"n\"n1/span\nspan class=\"n\"concrete_value/span\nspan class=\"o\"gt;gt;gt;gt;/spanspan class=\"w\" /spanspan class=\"c1\"# due to operator overloading we can manipulate z3 formulas/span\nspan class=\"o\"gt;gt;gt;gt;/spanspan class=\"w\" /spanspan class=\"n\"n2/spanspan class=\"w\" /spanspan class=\"o\"=/spanspan class=\"w\" /spanspan class=\"o\"~/spanspan class=\"n\"n1/span\nspan class=\"o\"gt;gt;gt;gt;/spanspan class=\"w\" /spanspan class=\"n\"n2/span\nspan class=\"o\"~/spanspan class=\"n\"concrete_value/span\nspan class=\"o\"gt;gt;gt;gt;/spanspan class=\"w\" /span\nspan class=\"o\"gt;gt;gt;gt;/spanspan class=\"w\" /spanspan class=\"c1\"# now z3 bitvector variables for the ones and zeros fields/span\nspan class=\"o\"gt;gt;gt;gt;/spanspan class=\"w\" /spanspan class=\"n\"ones/spanspan class=\"w\" /spanspan class=\"o\"=/spanspan class=\"w\" /spanspan class=\"n\"z3/spanspan class=\"o\"./spanspan class=\"n\"BitVec/spanspan class=\"p\"(/spanspan class=\"s1\"'abstract_ones'/spanspan class=\"p\",/spanspan class=\"w\" /spanspan class=\"mi\"64/spanspan class=\"p\")/span\nspan class=\"o\"gt;gt;gt;gt;/spanspan class=\"w\" /spanspan class=\"n\"unknowns/spanspan class=\"w\" /spanspan class=\"o\"=/spanspan class=\"w\" /spanspan class=\"n\"z3/spanspan class=\"o\"./spanspan class=\"n\"BitVec/spanspan class=\"p\"(/spanspan class=\"s1\"'abstract_unknowns'/spanspan class=\"p\",/spanspan class=\"w\" /spanspan class=\"mi\"64/spanspan class=\"p\")/span\nspan class=\"o\"gt;gt;gt;gt;/spanspan class=\"w\" /spanspan class=\"c1\"# we construct a KnownBits instance with the z3 variables/span\nspan class=\"o\"gt;gt;gt;gt;/spanspan class=\"w\" /spanspan class=\"n\"k1/spanspan class=\"w\" /spanspan class=\"o\"=/spanspan class=\"w\" /spanspan class=\"n\"KnownBits/spanspan class=\"p\"(/spanspan class=\"n\"ones/spanspan class=\"p\",/spanspan class=\"w\" /spanspan class=\"n\"unknowns/spanspan class=\"p\")/span\nspan class=\"o\"gt;gt;gt;gt;/spanspan class=\"w\" /spanspan class=\"c1\"# due to operator overloading we can call the methods on k1:/span\nspan class=\"o\"gt;gt;gt;gt;/spanspan class=\"w\" /spanspan class=\"n\"k2/spanspan class=\"w\" /spanspan class=\"o\"=/spanspan class=\"w\" /spanspan class=\"n\"k1/spanspan class=\"o\"./spanspan class=\"n\"abstract_invert/spanspan class=\"p\"()/span\nspan class=\"o\"gt;gt;gt;gt;/spanspan class=\"w\" /spanspan class=\"n\"k2/spanspan class=\"o\"./spanspan class=\"n\"ones/span\nspan class=\"o\"~/spanspan class=\"n\"abstract_unknowns/spanspan class=\"w\" /spanspan class=\"o\"amp;/spanspan class=\"w\" /spanspan class=\"o\"~/spanspan class=\"n\"abstract_ones/span\nspan class=\"o\"gt;gt;gt;gt;/spanspan class=\"w\" /spanspan class=\"n\"k2/spanspan class=\"o\"./spanspan class=\"n\"unknowns/span\nspan class=\"n\"abstract_unknowns/span\nspan class=\"o\"gt;gt;gt;gt;/spanspan class=\"w\" /spanspan class=\"c1\"# here's the correctness condition that we want to prove:/span\nspan class=\"o\"gt;gt;gt;gt;/spanspan class=\"w\" /spanspan class=\"n\"k2/spanspan class=\"o\"./spanspan class=\"n\"contains/spanspan class=\"p\"(/spanspan class=\"n\"n2/spanspan class=\"p\")/span\nspan class=\"o\"~/spanspan class=\"n\"concrete_value/spanspan class=\"w\" /spanspan class=\"o\"amp;/spanspan class=\"w\" /spanspan class=\"o\"~/spanspan class=\"n\"abstract_unknowns/spanspan class=\"w\" /spanspan class=\"o\"==/span\nspan class=\"o\"~/spanspan class=\"n\"abstract_unknowns/spanspan class=\"w\" /spanspan class=\"o\"amp;/spanspan class=\"w\" /spanspan class=\"o\"~/spanspan class=\"n\"abstract_ones/span\nspan class=\"o\"gt;gt;gt;gt;/spanspan class=\"w\" /spanspan class=\"c1\"# let's try/span\nspan class=\"o\"gt;gt;gt;gt;/spanspan class=\"w\" /spanspan class=\"n\"prove/spanspan class=\"p\"(/spanspan class=\"n\"k2/spanspan class=\"o\"./spanspan class=\"n\"contains/spanspan class=\"p\"(/spanspan class=\"n\"n2/spanspan class=\"p\"))/span\nspan class=\"n\"Traceback/spanspan class=\"w\" /spanspan class=\"p\"(/spanspan class=\"n\"most/spanspan class=\"w\" /spanspan class=\"n\"recent/spanspan class=\"w\" /spanspan class=\"n\"call/spanspan class=\"w\" /spanspan class=\"n\"last/spanspan class=\"p\"):/span\nspan class=\"w\"  /spanspan class=\"n\"File/spanspan class=\"w\" /spanspan class=\"s2\"\"lt;stdingt;\"/spanspan class=\"p\",/spanspan class=\"w\" /spanspan class=\"n\"line/spanspan class=\"w\" /spanspan class=\"mi\"1/spanspan class=\"p\",/spanspan class=\"w\" /spanspan class=\"ow\"in/spanspan class=\"w\" /spanspan class=\"o\"lt;/spanspan class=\"n\"module/spanspan class=\"o\"gt;/span\nspan class=\"w\"  /spanspan class=\"n\"File/spanspan class=\"w\" /spanspan class=\"s2\"\"lt;stdingt;\"/spanspan class=\"p\",/spanspan class=\"w\" /spanspan class=\"n\"line/spanspan class=\"w\" /spanspan class=\"mi\"1/spanspan class=\"p\",/spanspan class=\"w\" /spanspan class=\"ow\"in/spanspan class=\"w\" /spanspan class=\"n\"prove/span\nspan class=\"n\"AssertionError/span\nspan class=\"o\"gt;gt;gt;gt;/spanspan class=\"w\" /spanspan class=\"c1\"# it doesn't work! let's look at the counterexample to see why:/span\nspan class=\"o\"gt;gt;gt;gt;/spanspan class=\"w\" /spanspan class=\"n\"solver/spanspan class=\"o\"./spanspan class=\"n\"model/spanspan class=\"p\"()/span\nspan class=\"p\"[/spanspan class=\"n\"abstract_unknowns/spanspan class=\"w\" /spanspan class=\"o\"=/spanspan class=\"w\" /spanspan class=\"mi\"0/spanspan class=\"p\",/span\nspan class=\"w\" /spanspan class=\"n\"abstract_ones/spanspan class=\"w\" /spanspan class=\"o\"=/spanspan class=\"w\" /spanspan class=\"mi\"0/spanspan class=\"p\",/span\nspan class=\"w\" /spanspan class=\"n\"concrete_value/spanspan class=\"w\" /spanspan class=\"o\"=/spanspan class=\"w\" /spanspan class=\"mi\"1/spanspan class=\"p\"]/span\nspan class=\"o\"gt;gt;gt;gt;/spanspan class=\"w\" /spanspan class=\"c1\"# we can build a KnownBits instance with the values in the/span\nspan class=\"o\"gt;gt;gt;gt;/spanspan class=\"w\" /spanspan class=\"c1\"# counterexample:/span\nspan class=\"o\"gt;gt;gt;gt;/spanspan class=\"w\" /spanspan class=\"o\"~/spanspan class=\"mi\"1/spanspan class=\"w\" /spanspan class=\"c1\"# concrete result/span\nspan class=\"o\"-/spanspan class=\"mi\"2/span\nspan class=\"o\"gt;gt;gt;gt;/spanspan class=\"w\" /spanspan class=\"n\"counter_example_k1/spanspan class=\"w\" /spanspan class=\"o\"=/spanspan class=\"w\" /spanspan class=\"n\"KnownBits/spanspan class=\"p\"(/spanspan class=\"mi\"0/spanspan class=\"p\",/spanspan class=\"w\" /spanspan class=\"mi\"0/spanspan class=\"p\")/span\nspan class=\"o\"gt;gt;gt;gt;/spanspan class=\"w\" /spanspan class=\"n\"counter_example_k1/span\nspan class=\"n\"KnownBits/spanspan class=\"o\"./spanspan class=\"n\"from_constant/spanspan class=\"p\"(/spanspan class=\"mi\"0/spanspan class=\"p\")/span\nspan class=\"o\"gt;gt;gt;gt;/spanspan class=\"w\" /spanspan class=\"n\"counter_example_k2/spanspan class=\"w\" /spanspan class=\"o\"=/spanspan class=\"w\" /spanspan class=\"n\"counter_example_k1/spanspan class=\"o\"./spanspan class=\"n\"abstract_invert/spanspan class=\"p\"()/span\nspan class=\"o\"gt;gt;gt;gt;/spanspan class=\"w\" /spanspan class=\"n\"counter_example_k2/span\nspan class=\"n\"KnownBits/spanspan class=\"o\"./spanspan class=\"n\"from_constant/spanspan class=\"p\"(/spanspan class=\"o\"-/spanspan class=\"mi\"1/spanspan class=\"p\")/span\nspan class=\"o\"gt;gt;gt;gt;/spanspan class=\"w\" /spanspan class=\"c1\"# let's check the failing condition/span\nspan class=\"o\"gt;gt;gt;gt;/spanspan class=\"w\" /spanspan class=\"n\"counter_example_k2/spanspan class=\"o\"./spanspan class=\"n\"contains/spanspan class=\"p\"(/spanspan class=\"o\"~/spanspan class=\"mi\"1/spanspan class=\"p\")/span\nspan class=\"kc\"False/span\n/pre/div\n\npWhat is the problem here? We didn't tell Z3 that coden1/code was supposed to be a\nmember of codek1/code. We can add this as a precondition to the solver, and then the\nprove works:/p\ndiv class=\"code\"pre class=\"code literal-block\"gt;gt;gt;gt; solver.add(k1.contains(n1))\ngt;gt;gt;gt; prove(k2.contains(n2)) # works!\n/pre/div\n\npThis is super cool! It's really a proof about the actual implementation, because\nwe call the implementation methods directly, and due to the operator overloading\nthat Z3 does we can be sure that we are actually checking a formula that\ncorresponds to the Python code. This eliminates one source of errors in formal\nmethods./p\npDoing the proof manually on the Python REPL is kind of annoying though, and we\nalso would like to make sure that the proofs are re-done when we change the\ncode. What we would really like to do is writing the proofs as a unit-test that\nwe can run while developing and in CI. Doing this is possible, and the unit\ntests that really perform proofs look pleasingly similar to the\nHypothesis-based ones./p\npFirst we need to set up a bit of infrastructure:/p\ndiv class=\"code\"pre class=\"code literal-block\"span class=\"n\"INTEGER_WIDTH/span span class=\"o\"=/span span class=\"mi\"64/span\n\nspan class=\"k\"def/span span class=\"nf\"BitVec/spanspan class=\"p\"(/spanspan class=\"n\"name/spanspan class=\"p\"):/span\n    span class=\"k\"return/span span class=\"n\"z3/spanspan class=\"o\"./spanspan class=\"n\"BitVec/spanspan class=\"p\"(/spanspan class=\"n\"name/spanspan class=\"p\",/span span class=\"n\"INTEGER_WIDTH/spanspan class=\"p\")/span\n\nspan class=\"k\"def/span span class=\"nf\"BitVecVal/spanspan class=\"p\"(/spanspan class=\"n\"val/spanspan class=\"p\"):/span\n    span class=\"k\"return/span span class=\"n\"z3/spanspan class=\"o\"./spanspan class=\"n\"BitVecVal/spanspan class=\"p\"(/spanspan class=\"n\"val/spanspan class=\"p\",/span span class=\"n\"INTEGER_WIDTH/spanspan class=\"p\")/span\n\nspan class=\"k\"def/span span class=\"nf\"z3_setup_variables/spanspan class=\"p\"():/span\n    span class=\"c1\"# instantiate a solver/span\n    span class=\"n\"solver/span span class=\"o\"=/span span class=\"n\"z3/spanspan class=\"o\"./spanspan class=\"n\"Solver/spanspan class=\"p\"()/span\n\n    span class=\"c1\"# a Z3 variable for the first concrete value/span\n    span class=\"n\"n1/span span class=\"o\"=/span span class=\"n\"BitVec/spanspan class=\"p\"(/spanspan class=\"s2\"\"n1\"/spanspan class=\"p\")/span\n    span class=\"c1\"# a KnownBits instances that uses Z3 variables as its ones and unknowns,/span\n    span class=\"c1\"# representing the first abstract value/span\n    span class=\"n\"k1/span span class=\"o\"=/span span class=\"n\"KnownBits/spanspan class=\"p\"(/spanspan class=\"n\"BitVec/spanspan class=\"p\"(/spanspan class=\"s2\"\"n1_ones\"/spanspan class=\"p\"),/span span class=\"n\"BitVec/spanspan class=\"p\"(/spanspan class=\"s2\"\"n1_unkowns\"/spanspan class=\"p\"))/span\n    span class=\"c1\"# add the precondition to the solver that the concrete value n1 must be a/span\n    span class=\"c1\"# member of the abstract value k1/span\n    span class=\"n\"solver/spanspan class=\"o\"./spanspan class=\"n\"add/spanspan class=\"p\"(/spanspan class=\"n\"k1/spanspan class=\"o\"./spanspan class=\"n\"contains/spanspan class=\"p\"(/spanspan class=\"n\"n1/spanspan class=\"p\"))/span\n\n    span class=\"c1\"# a Z3 variable for the second concrete value/span\n    span class=\"n\"n2/span span class=\"o\"=/span span class=\"n\"BitVec/spanspan class=\"p\"(/spanspan class=\"s2\"\"n2\"/spanspan class=\"p\")/span\n    span class=\"c1\"# a KnownBits instances for the second abstract value/span\n    span class=\"n\"k2/span span class=\"o\"=/span span class=\"n\"KnownBits/spanspan class=\"p\"(/spanspan class=\"n\"BitVec/spanspan class=\"p\"(/spanspan class=\"s2\"\"n2_ones\"/spanspan class=\"p\"),/span span class=\"n\"BitVec/spanspan class=\"p\"(/spanspan class=\"s2\"\"n2_unkowns\"/spanspan class=\"p\"))/span\n    span class=\"c1\"# add the precondition linking n2 and k2 to the solver/span\n    span class=\"n\"solver/spanspan class=\"o\"./spanspan class=\"n\"add/spanspan class=\"p\"(/spanspan class=\"n\"k2/spanspan class=\"o\"./spanspan class=\"n\"contains/spanspan class=\"p\"(/spanspan class=\"n\"n2/spanspan class=\"p\"))/span\n    span class=\"k\"return/span span class=\"n\"solver/spanspan class=\"p\",/span span class=\"n\"k1/spanspan class=\"p\",/span span class=\"n\"n1/spanspan class=\"p\",/span span class=\"n\"k2/spanspan class=\"p\",/span span class=\"n\"n2/span\n\nspan class=\"k\"def/span span class=\"nf\"prove/spanspan class=\"p\"(/spanspan class=\"n\"cond/spanspan class=\"p\",/span span class=\"n\"solver/spanspan class=\"p\"):/span\n    span class=\"n\"z3res/span span class=\"o\"=/span span class=\"n\"solver/spanspan class=\"o\"./spanspan class=\"n\"check/spanspan class=\"p\"(/spanspan class=\"n\"z3/spanspan class=\"o\"./spanspan class=\"n\"Not/spanspan class=\"p\"(/spanspan class=\"n\"cond/spanspan class=\"p\"))/span\n    span class=\"k\"if/span span class=\"n\"z3res/span span class=\"o\"!=/span span class=\"n\"z3/spanspan class=\"o\"./spanspan class=\"n\"unsat/spanspan class=\"p\":/span\n        span class=\"k\"assert/span span class=\"n\"z3res/span span class=\"o\"==/span span class=\"n\"z3/spanspan class=\"o\"./spanspan class=\"n\"sat/span span class=\"c1\"# can't be timeout, we set no timeout/span\n        span class=\"c1\"# make the model with the counterexample global, to make inspecting the/span\n        span class=\"c1\"# bug easier when running pytest --pdb/span\n        span class=\"k\"global/span span class=\"n\"model/span\n        span class=\"n\"model/span span class=\"o\"=/span span class=\"n\"solver/spanspan class=\"o\"./spanspan class=\"n\"model/spanspan class=\"p\"()/span\n        span class=\"nb\"print/spanspan class=\"p\"(/spanspan class=\"sa\"f/spanspan class=\"s2\"\"n1=/spanspan class=\"si\"{/spanspan class=\"n\"model/spanspan class=\"o\"./spanspan class=\"n\"eval/spanspan class=\"p\"(/spanspan class=\"n\"n1/spanspan class=\"p\")/spanspan class=\"si\"}/spanspan class=\"s2\", n2=/spanspan class=\"si\"{/spanspan class=\"n\"model/spanspan class=\"o\"./spanspan class=\"n\"eval/spanspan class=\"p\"(/spanspan class=\"n\"n2/spanspan class=\"p\")/spanspan class=\"si\"}/spanspan class=\"s2\"\"/spanspan class=\"p\")/span\n        span class=\"n\"counter_example_k1/span span class=\"o\"=/span span class=\"n\"KnownBits/spanspan class=\"p\"(/spanspan class=\"n\"model/spanspan class=\"o\"./spanspan class=\"n\"eval/spanspan class=\"p\"(/spanspan class=\"n\"k1/spanspan class=\"o\"./spanspan class=\"n\"ones/spanspan class=\"p\")/spanspan class=\"o\"./spanspan class=\"n\"as_signed_long/spanspan class=\"p\"(),/span\n                                       span class=\"n\"model/spanspan class=\"o\"./spanspan class=\"n\"eval/spanspan class=\"p\"(/spanspan class=\"n\"k1/spanspan class=\"o\"./spanspan class=\"n\"unknowns/spanspan class=\"p\")/spanspan class=\"o\"./spanspan class=\"n\"as_signed_long/spanspan class=\"p\"())/span\n        span class=\"n\"counter_example_k2/span span class=\"o\"=/span span class=\"n\"KnownBits/spanspan class=\"p\"(/spanspan class=\"n\"model/spanspan class=\"o\"./spanspan class=\"n\"eval/spanspan class=\"p\"(/spanspan class=\"n\"k2/spanspan class=\"o\"./spanspan class=\"n\"ones/spanspan class=\"p\")/spanspan class=\"o\"./spanspan class=\"n\"as_signed_long/spanspan class=\"p\"(),/span\n                                       span class=\"n\"model/spanspan class=\"o\"./spanspan class=\"n\"eval/spanspan class=\"p\"(/spanspan class=\"n\"k2/spanspan class=\"o\"./spanspan class=\"n\"unknowns/spanspan class=\"p\")/spanspan class=\"o\"./spanspan class=\"n\"as_signed_long/spanspan class=\"p\"())/span\n        span class=\"nb\"print/spanspan class=\"p\"(/spanspan class=\"sa\"f/spanspan class=\"s2\"\"k1=/spanspan class=\"si\"{/spanspan class=\"n\"counter_example_k1/spanspan class=\"si\"}/spanspan class=\"s2\", k2=/spanspan class=\"si\"{/spanspan class=\"n\"counter_example_k2/spanspan class=\"si\"}/spanspan class=\"s2\"\"/spanspan class=\"p\")/span\n        span class=\"nb\"print/spanspan class=\"p\"(/spanspan class=\"sa\"f/spanspan class=\"s2\"\"but /spanspan class=\"si\"{/spanspan class=\"n\"cond/spanspan class=\"si\"=}/spanspan class=\"s2\" evaluates to /spanspan class=\"si\"{/spanspan class=\"n\"model/spanspan class=\"o\"./spanspan class=\"n\"eval/spanspan class=\"p\"(/spanspan class=\"n\"cond/spanspan class=\"p\")/spanspan class=\"si\"}/spanspan class=\"s2\"\"/spanspan class=\"p\")/span\n        span class=\"k\"raise/span span class=\"ne\"ValueError/spanspan class=\"p\"(/spanspan class=\"n\"solver/spanspan class=\"o\"./spanspan class=\"n\"model/spanspan class=\"p\"())/span\n/pre/div\n\npAnd then we can write proof-unit-tests like this:/p\ndiv class=\"code\"pre class=\"code literal-block\"span class=\"k\"def/span span class=\"nf\"test_z3_abstract_invert/spanspan class=\"p\"():/span\n    span class=\"n\"solver/spanspan class=\"p\",/span span class=\"n\"k1/spanspan class=\"p\",/span span class=\"n\"n1/spanspan class=\"p\",/span span class=\"n\"_/spanspan class=\"p\",/span span class=\"n\"_/span span class=\"o\"=/span span class=\"n\"z3_setup_variables/spanspan class=\"p\"()/span\n    span class=\"n\"k2/span span class=\"o\"=/span span class=\"n\"k1/spanspan class=\"o\"./spanspan class=\"n\"abstract_invert/spanspan class=\"p\"()/span\n    span class=\"n\"n2/span span class=\"o\"=/span span class=\"o\"~/spanspan class=\"n\"n1/span\n    span class=\"n\"prove/spanspan class=\"p\"(/spanspan class=\"n\"k2/spanspan class=\"o\"./spanspan class=\"n\"contains/spanspan class=\"p\"(/spanspan class=\"n\"n2/spanspan class=\"p\"),/span span class=\"n\"solver/spanspan class=\"p\")/span\n\nspan class=\"k\"def/span span class=\"nf\"test_z3_abstract_and/spanspan class=\"p\"():/span\n    span class=\"n\"solver/spanspan class=\"p\",/span span class=\"n\"k1/spanspan class=\"p\",/span span class=\"n\"n1/spanspan class=\"p\",/span span class=\"n\"k2/spanspan class=\"p\",/span span class=\"n\"n2/span span class=\"o\"=/span span class=\"n\"z3_setup_variables/spanspan class=\"p\"()/span\n    span class=\"n\"k3/span span class=\"o\"=/span span class=\"n\"k1/spanspan class=\"o\"./spanspan class=\"n\"abstract_and/spanspan class=\"p\"(/spanspan class=\"n\"k2/spanspan class=\"p\")/span\n    span class=\"n\"n3/span span class=\"o\"=/span span class=\"n\"n1/span span class=\"o\"amp;/span span class=\"n\"n2/span\n    span class=\"n\"prove/spanspan class=\"p\"(/spanspan class=\"n\"k3/spanspan class=\"o\"./spanspan class=\"n\"contains/spanspan class=\"p\"(/spanspan class=\"n\"n3/spanspan class=\"p\"),/span span class=\"n\"solver/spanspan class=\"p\")/span\n\nspan class=\"k\"def/span span class=\"nf\"test_z3_abstract_or/spanspan class=\"p\"():/span\n    span class=\"n\"solver/spanspan class=\"p\",/span span class=\"n\"k1/spanspan class=\"p\",/span span class=\"n\"n1/spanspan class=\"p\",/span span class=\"n\"k2/spanspan class=\"p\",/span span class=\"n\"n2/span span class=\"o\"=/span span class=\"n\"z3_setup_variables/spanspan class=\"p\"()/span\n    span class=\"n\"k3/span span class=\"o\"=/span span class=\"n\"k1/spanspan class=\"o\"./spanspan class=\"n\"abstract_or/spanspan class=\"p\"(/spanspan class=\"n\"k2/spanspan class=\"p\")/span\n    span class=\"n\"n3/span span class=\"o\"=/span span class=\"n\"n1/span span class=\"o\"|/span span class=\"n\"n2/span\n    span class=\"n\"prove/spanspan class=\"p\"(/spanspan class=\"n\"k3/spanspan class=\"o\"./spanspan class=\"n\"contains/spanspan class=\"p\"(/spanspan class=\"n\"n3/spanspan class=\"p\"),/span span class=\"n\"solver/spanspan class=\"p\")/span\n\nspan class=\"k\"def/span span class=\"nf\"test_z3_abstract_add/spanspan class=\"p\"():/span\n    span class=\"n\"solver/spanspan class=\"p\",/span span class=\"n\"k1/spanspan class=\"p\",/span span class=\"n\"n1/spanspan class=\"p\",/span span class=\"n\"k2/spanspan class=\"p\",/span span class=\"n\"n2/span span class=\"o\"=/span span class=\"n\"z3_setup_variables/spanspan class=\"p\"()/span\n    span class=\"n\"k3/span span class=\"o\"=/span span class=\"n\"k1/spanspan class=\"o\"./spanspan class=\"n\"abstract_add/spanspan class=\"p\"(/spanspan class=\"n\"k2/spanspan class=\"p\")/span\n    span class=\"n\"n3/span span class=\"o\"=/span span class=\"n\"n1/span span class=\"o\"+/span span class=\"n\"n2/span\n    span class=\"n\"prove/spanspan class=\"p\"(/spanspan class=\"n\"k3/spanspan class=\"o\"./spanspan class=\"n\"contains/spanspan class=\"p\"(/spanspan class=\"n\"n3/spanspan class=\"p\"),/span span class=\"n\"solver/spanspan class=\"p\")/span\n\nspan class=\"k\"def/span span class=\"nf\"test_z3_abstract_sub/spanspan class=\"p\"():/span\n    span class=\"n\"solver/spanspan class=\"p\",/span span class=\"n\"k1/spanspan class=\"p\",/span span class=\"n\"n1/spanspan class=\"p\",/span span class=\"n\"k2/spanspan class=\"p\",/span span class=\"n\"n2/span span class=\"o\"=/span span class=\"n\"z3_setup_variables/spanspan class=\"p\"()/span\n    span class=\"n\"k3/span span class=\"o\"=/span span class=\"n\"k1/spanspan class=\"o\"./spanspan class=\"n\"abstract_sub/spanspan class=\"p\"(/spanspan class=\"n\"k2/spanspan class=\"p\")/span\n    span class=\"n\"n3/span span class=\"o\"=/span span class=\"n\"n1/span span class=\"o\"-/span span class=\"n\"n2/span\n    span class=\"n\"prove/spanspan class=\"p\"(/spanspan class=\"n\"k3/spanspan class=\"o\"./spanspan class=\"n\"contains/spanspan class=\"p\"(/spanspan class=\"n\"n3/spanspan class=\"p\"),/span span class=\"n\"solver/spanspan class=\"p\")/span\n/pre/div\n\npIt's possible to write a bit more Python-metaprogramming-magic and unify the\nHypothesis and Z3 tests into the same test definition.sup id=\"fnref:proof_bitwidths\"a class=\"footnote-ref\" href=\"https://www.pypy.org/posts/2024/08/toy-knownbits.html#fn:proof_bitwidths\"1/a/sup/p\nh3 id=\"cases-where-this-style-of-z3-proof-doesnt-work\"Cases where this style of Z3 proof doesn't work/h3\npUnfortunately the approach described in the previous section only works for a\nvery small number of cases. It breaks down as soon as the codeKnownBits/code methods\nthat we're calling contain any codeif/code conditions (including hidden ones like\nthe short-circuiting codeand/code and codeor/code in Python). Let's look at an example and\nimplement codeabstract_eq/code. codeeq/code is supposed to be an operation that compares two\nintegers and returns code0/code or code1/code if they are different or equal, respectively.\nImplementing this in knownbits looks like this (with example and hypothesis\ntests):/p\ndiv class=\"code\"pre class=\"code literal-block\"span class=\"k\"class/span span class=\"nc\"KnownBits/spanspan class=\"p\":/span\n    span class=\"o\".../span\n\n    span class=\"k\"def/span span class=\"nf\"abstract_eq/spanspan class=\"p\"(/spanspan class=\"bp\"self/spanspan class=\"p\",/span span class=\"n\"other/spanspan class=\"p\"):/span\n        span class=\"c1\"# the result is a 0, 1, or ?/span\n\n        span class=\"c1\"# if they are both the same constant, they must be equal/span\n        span class=\"k\"if/span span class=\"bp\"self/spanspan class=\"o\"./spanspan class=\"n\"is_constant/spanspan class=\"p\"()/span span class=\"ow\"and/span span class=\"n\"other/spanspan class=\"o\"./spanspan class=\"n\"is_constant/spanspan class=\"p\"()/span span class=\"ow\"and/span span class=\"bp\"self/spanspan class=\"o\"./spanspan class=\"n\"ones/span span class=\"o\"==/span span class=\"n\"other/spanspan class=\"o\"./spanspan class=\"n\"ones/spanspan class=\"p\":/span\n            span class=\"k\"return/span span class=\"n\"KnownBits/spanspan class=\"o\"./spanspan class=\"n\"from_constant/spanspan class=\"p\"(/spanspan class=\"mi\"1/spanspan class=\"p\")/span\n        span class=\"c1\"# check whether we have known disagreeing bits, then we know the result/span\n        span class=\"c1\"# is 0/span\n        span class=\"k\"if/span span class=\"bp\"self/spanspan class=\"o\"./spanspan class=\"n\"_disagrees/spanspan class=\"p\"(/spanspan class=\"n\"other/spanspan class=\"p\"):/span\n            span class=\"k\"return/span span class=\"n\"KnownBits/spanspan class=\"o\"./spanspan class=\"n\"from_constant/spanspan class=\"p\"(/spanspan class=\"mi\"0/spanspan class=\"p\")/span\n        span class=\"k\"return/span span class=\"n\"KnownBits/spanspan class=\"p\"(/spanspan class=\"mi\"0/spanspan class=\"p\",/span span class=\"mi\"1/spanspan class=\"p\")/span span class=\"c1\"# an unknown boolean/span\n\n    span class=\"k\"def/span span class=\"nf\"_disagrees/spanspan class=\"p\"(/spanspan class=\"bp\"self/spanspan class=\"p\",/span span class=\"n\"other/spanspan class=\"p\"):/span\n        span class=\"c1\"# check whether the bits disagree in any place where both are known/span\n        span class=\"n\"both_known/span span class=\"o\"=/span span class=\"bp\"self/spanspan class=\"o\"./spanspan class=\"n\"knowns/span span class=\"o\"amp;/span span class=\"n\"other/spanspan class=\"o\"./spanspan class=\"n\"knowns/span\n        span class=\"k\"return/span span class=\"bp\"self/spanspan class=\"o\"./spanspan class=\"n\"ones/span span class=\"o\"amp;/span span class=\"n\"both_known/span span class=\"o\"!=/span span class=\"n\"other/spanspan class=\"o\"./spanspan class=\"n\"ones/span span class=\"o\"amp;/span span class=\"n\"both_known/span\n\nspan class=\"k\"def/span span class=\"nf\"test_eq/spanspan class=\"p\"():/span\n    span class=\"n\"k1/span span class=\"o\"=/span span class=\"n\"KnownBits/spanspan class=\"o\"./spanspan class=\"n\"from_str/spanspan class=\"p\"(/spanspan class=\"s1\"'...?'/spanspan class=\"p\")/span\n    span class=\"n\"k2/span span class=\"o\"=/span span class=\"n\"KnownBits/spanspan class=\"o\"./spanspan class=\"n\"from_str/spanspan class=\"p\"(/spanspan class=\"s1\"'...?'/spanspan class=\"p\")/span\n    span class=\"k\"assert/span span class=\"nb\"str/spanspan class=\"p\"(/spanspan class=\"n\"k1/spanspan class=\"o\"./spanspan class=\"n\"abstract_eq/spanspan class=\"p\"(/spanspan class=\"n\"k2/spanspan class=\"p\"))/span span class=\"o\"==/span span class=\"s1\"'?'/span\n    span class=\"n\"k1/span span class=\"o\"=/span span class=\"n\"KnownBits/spanspan class=\"o\"./spanspan class=\"n\"from_constant/spanspan class=\"p\"(/spanspan class=\"mi\"10/spanspan class=\"p\")/span\n    span class=\"k\"assert/span span class=\"nb\"str/spanspan class=\"p\"(/spanspan class=\"n\"k1/spanspan class=\"o\"./spanspan class=\"n\"abstract_eq/spanspan class=\"p\"(/spanspan class=\"n\"k1/spanspan class=\"p\"))/span span class=\"o\"==/span span class=\"s1\"'1'/span\n    span class=\"n\"k1/span span class=\"o\"=/span span class=\"n\"KnownBits/spanspan class=\"o\"./spanspan class=\"n\"from_constant/spanspan class=\"p\"(/spanspan class=\"mi\"10/spanspan class=\"p\")/span\n    span class=\"n\"k2/span span class=\"o\"=/span span class=\"n\"KnownBits/spanspan class=\"o\"./spanspan class=\"n\"from_constant/spanspan class=\"p\"(/spanspan class=\"mi\"20/spanspan class=\"p\")/span\n    span class=\"k\"assert/span span class=\"nb\"str/spanspan class=\"p\"(/spanspan class=\"n\"k1/spanspan class=\"o\"./spanspan class=\"n\"abstract_eq/spanspan class=\"p\"(/spanspan class=\"n\"k2/spanspan class=\"p\"))/span span class=\"o\"==/span span class=\"s1\"'0'/span\n\nspan class=\"nd\"@given/spanspan class=\"p\"(/spanspan class=\"n\"knownbits_and_contained_number/spanspan class=\"p\",/span span class=\"n\"knownbits_and_contained_number/spanspan class=\"p\")/span\nspan class=\"k\"def/span span class=\"nf\"test_hypothesis_eq/spanspan class=\"p\"(/spanspan class=\"n\"t1/spanspan class=\"p\",/span span class=\"n\"t2/spanspan class=\"p\"):/span\n    span class=\"n\"k1/spanspan class=\"p\",/span span class=\"n\"n1/span span class=\"o\"=/span span class=\"n\"t1/span\n    span class=\"n\"k2/spanspan class=\"p\",/span span class=\"n\"n2/span span class=\"o\"=/span span class=\"n\"t2/span\n    span class=\"n\"k3/span span class=\"o\"=/span span class=\"n\"k1/spanspan class=\"o\"./spanspan class=\"n\"abstract_eq/spanspan class=\"p\"(/spanspan class=\"n\"k2/spanspan class=\"p\")/span\n    span class=\"k\"assert/span span class=\"n\"k3/spanspan class=\"o\"./spanspan class=\"n\"contains/spanspan class=\"p\"(/spanspan class=\"nb\"int/spanspan class=\"p\"(/spanspan class=\"n\"n1/span span class=\"o\"==/span span class=\"n\"n2/spanspan class=\"p\"))/span\n/pre/div\n\npTrying to do the proof in the same style as before breaks:/p\ndiv class=\"code\"pre class=\"code literal-block\"span class=\"o\"gt;gt;gt;gt;/span span class=\"n\"k3/span span class=\"o\"=/span span class=\"n\"k1/spanspan class=\"o\"./spanspan class=\"n\"abstract_eq/spanspan class=\"p\"(/spanspan class=\"n\"k2/spanspan class=\"p\")/span\nspan class=\"n\"Traceback/span span class=\"p\"(/spanspan class=\"n\"most/span span class=\"n\"recent/span span class=\"n\"call/span span class=\"n\"last/spanspan class=\"p\"):/span\n  span class=\"n\"File/span span class=\"s2\"\"lt;stdingt;\"/spanspan class=\"p\",/span span class=\"n\"line/span span class=\"mi\"1/spanspan class=\"p\",/span span class=\"ow\"in/span span class=\"o\"lt;/spanspan class=\"n\"module/spanspan class=\"o\"gt;/span\n  span class=\"n\"File/span span class=\"s2\"\"knownbits.py\"/spanspan class=\"p\",/span span class=\"n\"line/span span class=\"mi\"246/spanspan class=\"p\",/span span class=\"ow\"in/span span class=\"n\"abstract_eq/span\n    span class=\"k\"if/span span class=\"bp\"self/spanspan class=\"o\"./spanspan class=\"n\"_disagrees/spanspan class=\"p\"(/spanspan class=\"n\"other/spanspan class=\"p\"):/span\n  span class=\"n\"File/span span class=\"s2\"\"venv/site-packages/z3/z3.py\"/spanspan class=\"p\",/span span class=\"n\"line/span span class=\"mi\"381/spanspan class=\"p\",/span span class=\"ow\"in/span span class=\"fm\"__bool__/span\n    span class=\"k\"raise/span span class=\"n\"Z3Exception/spanspan class=\"p\"(/spanspan class=\"s2\"\"Symbolic expressions cannot be cast to concrete Boolean values.\"/spanspan class=\"p\")/span\nspan class=\"n\"z3/spanspan class=\"o\"./spanspan class=\"n\"z3types/spanspan class=\"o\"./spanspan class=\"n\"Z3Exception/spanspan class=\"p\":/span span class=\"n\"Symbolic/span span class=\"n\"expressions/span span class=\"n\"cannot/span span class=\"n\"be/span span class=\"n\"cast/span span class=\"n\"to/span span class=\"n\"concrete/span span class=\"n\"Boolean/span span class=\"n\"values/spanspan class=\"o\"./span\n/pre/div\n\npWe cannot call codeabstract_eq/code on a codeKnownBits/code with Z3 variables as fields,\nbecause once we hit an codeif/code statement, the whole approach of relying on the\noperator overloading breaks down. Z3 doesn't actually parse the Python code or\nanything advanced like that, we rather build an expression only by running the\ncode and letting the Z3 formulas build up./p\npTo still prove the correctness of codeabstract_eq/code we need to manually transform\nthe control flow logic of the function into a Z3 formula that uses the codez3.If/code\nexpression, using a small helper function:/p\ndiv class=\"code\"pre class=\"code literal-block\"span class=\"k\"def/span span class=\"nf\"z3_cond/spanspan class=\"p\"(/spanspan class=\"n\"b/spanspan class=\"p\",/span span class=\"n\"trueval/spanspan class=\"o\"=/spanspan class=\"mi\"1/spanspan class=\"p\",/span span class=\"n\"falseval/spanspan class=\"o\"=/spanspan class=\"mi\"0/spanspan class=\"p\"):/span\n    span class=\"k\"return/span span class=\"n\"z3/spanspan class=\"o\"./spanspan class=\"n\"If/spanspan class=\"p\"(/spanspan class=\"n\"b/spanspan class=\"p\",/span span class=\"n\"BitVecVal/spanspan class=\"p\"(/spanspan class=\"n\"trueval/spanspan class=\"p\"),/span span class=\"n\"BitVecVal/spanspan class=\"p\"(/spanspan class=\"n\"falseval/spanspan class=\"p\"))/span\n\nspan class=\"k\"def/span span class=\"nf\"z3_abstract_eq/spanspan class=\"p\"(/spanspan class=\"n\"k1/spanspan class=\"p\",/span span class=\"n\"k2/spanspan class=\"p\"):/span\n    span class=\"c1\"# follow the *logic* of abstract_eq, we can't call it due to the ifs in it/span\n    span class=\"n\"case1cond/span span class=\"o\"=/span span class=\"n\"z3/spanspan class=\"o\"./spanspan class=\"n\"And/spanspan class=\"p\"(/spanspan class=\"n\"k1/spanspan class=\"o\"./spanspan class=\"n\"is_constant/spanspan class=\"p\"(),/span span class=\"n\"k2/spanspan class=\"o\"./spanspan class=\"n\"is_constant/spanspan class=\"p\"(),/span span class=\"n\"k1/spanspan class=\"o\"./spanspan class=\"n\"ones/span span class=\"o\"==/span span class=\"n\"k2/spanspan class=\"o\"./spanspan class=\"n\"ones/spanspan class=\"p\")/span\n    span class=\"n\"case2cond/span span class=\"o\"=/span span class=\"n\"k1/spanspan class=\"o\"./spanspan class=\"n\"_disagrees/spanspan class=\"p\"(/spanspan class=\"n\"k2/spanspan class=\"p\")/span\n\n    span class=\"c1\"# ones is 1 in the first case, 0 otherwise/span\n    span class=\"n\"ones/span span class=\"o\"=/span span class=\"n\"z3_cond/spanspan class=\"p\"(/spanspan class=\"n\"case1cond/spanspan class=\"p\",/span span class=\"mi\"1/spanspan class=\"p\",/span span class=\"mi\"0/spanspan class=\"p\")/span\n\n    span class=\"c1\"# in the first two cases, unknowns is 0, 1 otherwise/span\n    span class=\"n\"unknowns/span span class=\"o\"=/span span class=\"n\"z3_cond/spanspan class=\"p\"(/spanspan class=\"n\"z3/spanspan class=\"o\"./spanspan class=\"n\"Or/spanspan class=\"p\"(/spanspan class=\"n\"case1cond/spanspan class=\"p\",/span span class=\"n\"case2cond/spanspan class=\"p\"),/span span class=\"mi\"0/spanspan class=\"p\",/span span class=\"mi\"1/spanspan class=\"p\")/span\n    span class=\"k\"return/span span class=\"n\"KnownBits/spanspan class=\"p\"(/spanspan class=\"n\"ones/spanspan class=\"p\",/span span class=\"n\"unknowns/spanspan class=\"p\")/span\n\nspan class=\"k\"def/span span class=\"nf\"test_z3_abstract_eq_logic/spanspan class=\"p\"():/span\n    span class=\"n\"solver/spanspan class=\"p\",/span span class=\"n\"k1/spanspan class=\"p\",/span span class=\"n\"n1/spanspan class=\"p\",/span span class=\"n\"k2/spanspan class=\"p\",/span span class=\"n\"n2/span span class=\"o\"=/span span class=\"n\"z3_setup_variables/spanspan class=\"p\"()/span\n    span class=\"n\"n3/span span class=\"o\"=/span span class=\"n\"z3_cond/spanspan class=\"p\"(/spanspan class=\"n\"n1/span span class=\"o\"==/span span class=\"n\"n2/spanspan class=\"p\")/span span class=\"c1\"# concrete result/span\n    span class=\"n\"k3/span span class=\"o\"=/span span class=\"n\"z3_abstract_eq/spanspan class=\"p\"(/spanspan class=\"n\"k1/spanspan class=\"p\",/span span class=\"n\"k2/spanspan class=\"p\")/span\n    span class=\"n\"prove/spanspan class=\"p\"(/spanspan class=\"n\"k3/spanspan class=\"o\"./spanspan class=\"n\"contains/spanspan class=\"p\"(/spanspan class=\"n\"n3/spanspan class=\"p\"),/span span class=\"n\"solver/spanspan class=\"p\")/span\n/pre/div\n\npThis proof works. It is a lot less satisfying than the previous ones though,\nbecause we could have done an error in the manual transcription from Python code\nto Z3 formulas (there are possibly more heavy-handed approaches where we do\nthis transformation more automatically using e.g. the codeast/code module to analyze\nthe source code, but that's a much more complicated researchy project). To\nlessen this problem somewhat we can factor out the parts of the logic that don't\nhave any conditions into small helper methods (like code_disagrees/code in this\nexample) and use them in the manual conversion of the code to Z3 formulas.sup id=\"fnref:tests_vs_proofs\"a class=\"footnote-ref\" href=\"https://www.pypy.org/posts/2024/08/toy-knownbits.html#fn:tests_vs_proofs\"2/a/sup/p\npThe final condition that Z3 checks, btw, is this one:/p\ndiv class=\"code\"pre class=\"code literal-block\"If(n1 == n2, 1, 0) amp;\n~If(Or(And(n1_unkowns == 0,\n           n2_unkowns == 0,\n           n1_ones == n2_ones),\n       n1_ones amp; ~n1_unkowns amp; ~n2_unkowns !=\n       n2_ones amp; ~n1_unkowns amp; ~n2_unkowns),\n    0, 1) ==\nIf(And(n1_unkowns == 0, n2_unkowns == 0, n1_ones == n2_ones),\n   1, 0)\n/pre/div\n\nh3 id=\"making-statements-about-precision\"Making Statements about Precision/h3\npSo far we have only used Z3 to prove statements about correctness, i.e. that\nour abstract operations overapproximate what can happen with concrete values.\nWhile proving this property is essential if we want to avoid miscompilation,\ncorrectness alone is not a very strong constraint on the implementation of our\nabstract transfer functions. We could simply return codeKnownbits.unknowns()/code for\nevery codeabstract_*/code method and the resulting overapproximation would be correct,\nbut useless in practice./p\npIt's much harder to make statements about whether the transfer functions are\nmaximally precise. There are two aspects of precision I want to discuss in this\nsection, however./p\npThe first aspect is that we would really like it if the transfer functions\ncompute the maximally precise results for singleton sets. If all abstract\narguments of an operations are constants, i.e. contain only a single concrete\nelement, then we know that the resulting set also has only a single element. We\ncan prove that all our transfer functions have this property:/p\ndiv class=\"code\"pre class=\"code literal-block\"span class=\"k\"def/span span class=\"nf\"test_z3_prove_constant_folding/spanspan class=\"p\"():/span\n    span class=\"n\"solver/spanspan class=\"p\",/span span class=\"n\"k1/spanspan class=\"p\",/span span class=\"n\"n1/spanspan class=\"p\",/span span class=\"n\"k2/spanspan class=\"p\",/span span class=\"n\"n2/span span class=\"o\"=/span span class=\"n\"z3_setup_variables/spanspan class=\"p\"()/span\n    span class=\"n\"k3/span span class=\"o\"=/span span class=\"n\"k1/spanspan class=\"o\"./spanspan class=\"n\"abstract_invert/spanspan class=\"p\"()/span\n    span class=\"n\"prove/spanspan class=\"p\"(/spanspan class=\"n\"z3/spanspan class=\"o\"./spanspan class=\"n\"Implies/spanspan class=\"p\"(/spanspan class=\"n\"k1/spanspan class=\"o\"./spanspan class=\"n\"is_constant/spanspan class=\"p\"(),/span\n                     span class=\"n\"k3/spanspan class=\"o\"./spanspan class=\"n\"is_constant/spanspan class=\"p\"()),/span span class=\"n\"solver/spanspan class=\"p\")/span\n\n    span class=\"n\"k3/span span class=\"o\"=/span span class=\"n\"k1/spanspan class=\"o\"./spanspan class=\"n\"abstract_and/spanspan class=\"p\"(/spanspan class=\"n\"k2/spanspan class=\"p\")/span\n    span class=\"n\"prove/spanspan class=\"p\"(/spanspan class=\"n\"z3/spanspan class=\"o\"./spanspan class=\"n\"Implies/spanspan class=\"p\"(/spanspan class=\"n\"z3/spanspan class=\"o\"./spanspan class=\"n\"And/spanspan class=\"p\"(/spanspan class=\"n\"k1/spanspan class=\"o\"./spanspan class=\"n\"is_constant/spanspan class=\"p\"(),/span span class=\"n\"k2/spanspan class=\"o\"./spanspan class=\"n\"is_constant/spanspan class=\"p\"()),/span\n                     span class=\"n\"k3/spanspan class=\"o\"./spanspan class=\"n\"is_constant/spanspan class=\"p\"()),/span span class=\"n\"solver/spanspan class=\"p\")/span\n\n    span class=\"n\"k3/span span class=\"o\"=/span span class=\"n\"k1/spanspan class=\"o\"./spanspan class=\"n\"abstract_or/spanspan class=\"p\"(/spanspan class=\"n\"k2/spanspan class=\"p\")/span\n    span class=\"n\"prove/spanspan class=\"p\"(/spanspan class=\"n\"z3/spanspan class=\"o\"./spanspan class=\"n\"Implies/spanspan class=\"p\"(/spanspan class=\"n\"z3/spanspan class=\"o\"./spanspan class=\"n\"And/spanspan class=\"p\"(/spanspan class=\"n\"k1/spanspan class=\"o\"./spanspan class=\"n\"is_constant/spanspan class=\"p\"(),/span span class=\"n\"k2/spanspan class=\"o\"./spanspan class=\"n\"is_constant/spanspan class=\"p\"()),/span\n                     span class=\"n\"k3/spanspan class=\"o\"./spanspan class=\"n\"is_constant/spanspan class=\"p\"()),/span span class=\"n\"solver/spanspan class=\"p\")/span\n\n    span class=\"n\"k3/span span class=\"o\"=/span span class=\"n\"k1/spanspan class=\"o\"./spanspan class=\"n\"abstract_sub/spanspan class=\"p\"(/spanspan class=\"n\"k2/spanspan class=\"p\")/span\n    span class=\"n\"prove/spanspan class=\"p\"(/spanspan class=\"n\"z3/spanspan class=\"o\"./spanspan class=\"n\"Implies/spanspan class=\"p\"(/spanspan class=\"n\"z3/spanspan class=\"o\"./spanspan class=\"n\"And/spanspan class=\"p\"(/spanspan class=\"n\"k1/spanspan class=\"o\"./spanspan class=\"n\"is_constant/spanspan class=\"p\"(),/span span class=\"n\"k2/spanspan class=\"o\"./spanspan class=\"n\"is_constant/spanspan class=\"p\"()),/span\n                     span class=\"n\"k3/spanspan class=\"o\"./spanspan class=\"n\"is_constant/spanspan class=\"p\"()),/span span class=\"n\"solver/spanspan class=\"p\")/span\n\n    span class=\"n\"k3/span span class=\"o\"=/span span class=\"n\"z3_abstract_eq/spanspan class=\"p\"(/spanspan class=\"n\"k1/spanspan class=\"p\",/span span class=\"n\"k2/spanspan class=\"p\")/span\n    span class=\"n\"prove/spanspan class=\"p\"(/spanspan class=\"n\"z3/spanspan class=\"o\"./spanspan class=\"n\"Implies/spanspan class=\"p\"(/spanspan class=\"n\"z3/spanspan class=\"o\"./spanspan class=\"n\"And/spanspan class=\"p\"(/spanspan class=\"n\"k1/spanspan class=\"o\"./spanspan class=\"n\"is_constant/spanspan class=\"p\"(),/span span class=\"n\"k2/spanspan class=\"o\"./spanspan class=\"n\"is_constant/spanspan class=\"p\"()),/span\n                     span class=\"n\"k3/spanspan class=\"o\"./spanspan class=\"n\"is_constant/spanspan class=\"p\"()),/span span class=\"n\"solver/spanspan class=\"p\")/span\n/pre/div\n\npProving with Z3 that the transfer functions are maximally precise for\nnon-constant arguments seems to be relatively hard. I tried a few completely\nrigorous approaches and failed. The paper a href=\"https://arxiv.org/pdf/2105.05398\"Sound, Precise, and Fast Abstract\nInterpretation with Tristate Numbers/a\ncontains an optimality proof for the transfer functions of addition and\nsubtraction, so we can be certain that they are as precise as is\npossible./p\npI still want to show an approach for trying to find concrete examples of\nabstract values that are less precise than they could be, using a combination\nof Hypothesis and Z3. The idea is to use hypothesis to pick random abstract\nvalues. Then we compute the abstract result using our transfer function.\nAfterwards we can ask Z3 to find us an abstract result that is better than the\none our transfer function produced. If Z3 finds a better abstract result, we\nhave a concrete example of imprecision for our transfer function. Those tests\naren't strict proofs, because they rely on generating random abstract values,\nbut they can still be valuable (not for the transfer functions in this blog\npost, which are all optimal)./p\npHere is what the code looks like (this is a little bit bonus content, I'll not\nexplain the details and can only hope that the comments are somewhat helpful):/p\ndiv class=\"code\"pre class=\"code literal-block\"span class=\"nd\"@given/spanspan class=\"p\"(/spanspan class=\"n\"random_knownbits_and_contained_number/spanspan class=\"p\",/span span class=\"n\"random_knownbits_and_contained_number/spanspan class=\"p\")/span\nspan class=\"nd\"@settings/spanspan class=\"p\"(/spanspan class=\"n\"deadline/spanspan class=\"o\"=/spanspan class=\"kc\"None/spanspan class=\"p\")/span\nspan class=\"k\"def/span span class=\"nf\"test_check_precision/spanspan class=\"p\"(/spanspan class=\"n\"t1/spanspan class=\"p\",/span span class=\"n\"t2/spanspan class=\"p\"):/span\n    span class=\"n\"k1/spanspan class=\"p\",/span span class=\"n\"n1/span span class=\"o\"=/span span class=\"n\"t1/span\n    span class=\"n\"k2/spanspan class=\"p\",/span span class=\"n\"n2/span span class=\"o\"=/span span class=\"n\"t2/span\n    span class=\"c1\"# apply transfer function/span\n    span class=\"n\"k3/span span class=\"o\"=/span span class=\"n\"k1/spanspan class=\"o\"./spanspan class=\"n\"abstract_add/spanspan class=\"p\"(/spanspan class=\"n\"k2/spanspan class=\"p\")/span\n    span class=\"n\"example_res/span span class=\"o\"=/span span class=\"n\"n1/span span class=\"o\"+/span span class=\"n\"n2/span\n\n    span class=\"c1\"# try to find a better version of k3 with Z3/span\n    span class=\"n\"solver/span span class=\"o\"=/span span class=\"n\"z3/spanspan class=\"o\"./spanspan class=\"n\"Solver/spanspan class=\"p\"()/span\n    span class=\"n\"solver/spanspan class=\"o\"./spanspan class=\"n\"set/spanspan class=\"p\"(/spanspan class=\"s2\"\"timeout\"/spanspan class=\"p\",/span span class=\"mi\"8000/spanspan class=\"p\")/span\n\n    span class=\"n\"var1/span span class=\"o\"=/span span class=\"n\"BitVec/spanspan class=\"p\"(/spanspan class=\"s1\"'v1'/spanspan class=\"p\")/span\n    span class=\"n\"var2/span span class=\"o\"=/span span class=\"n\"BitVec/spanspan class=\"p\"(/spanspan class=\"s1\"'v2'/spanspan class=\"p\")/span\n\n    span class=\"n\"ones/span span class=\"o\"=/span span class=\"n\"BitVec/spanspan class=\"p\"(/spanspan class=\"s1\"'ones'/spanspan class=\"p\")/span\n    span class=\"n\"unknowns/span span class=\"o\"=/span span class=\"n\"BitVec/spanspan class=\"p\"(/spanspan class=\"s1\"'unknowns'/spanspan class=\"p\")/span\n    span class=\"n\"better_k3/span span class=\"o\"=/span span class=\"n\"KnownBits/spanspan class=\"p\"(/spanspan class=\"n\"ones/spanspan class=\"p\",/span span class=\"n\"unknowns/spanspan class=\"p\")/span\n    span class=\"nb\"print/spanspan class=\"p\"(/spanspan class=\"n\"k1/spanspan class=\"p\",/span span class=\"n\"k2/spanspan class=\"p\",/span span class=\"n\"k3/spanspan class=\"p\")/span\n\n    span class=\"c1\"# we're trying to find an example for a better k3, so we use check, without/span\n    span class=\"c1\"# negation:/span\n    span class=\"n\"res/span span class=\"o\"=/span span class=\"n\"solver/spanspan class=\"o\"./spanspan class=\"n\"check/spanspan class=\"p\"(/spanspan class=\"n\"z3/spanspan class=\"o\"./spanspan class=\"n\"And/spanspan class=\"p\"(/span\n        span class=\"c1\"# better_k3 should be a valid knownbits instance/span\n        span class=\"n\"better_k3/spanspan class=\"o\"./spanspan class=\"n\"is_well_formed/spanspan class=\"p\"(),/span\n        span class=\"c1\"# it should be better than k3, ie there are known bits in better_k3/span\n        span class=\"c1\"# that we don't have in k3/span\n        span class=\"n\"better_k3/spanspan class=\"o\"./spanspan class=\"n\"knowns/span span class=\"o\"amp;/span span class=\"o\"~/spanspan class=\"n\"k3/spanspan class=\"o\"./spanspan class=\"n\"knowns/span span class=\"o\"!=/span span class=\"mi\"0/spanspan class=\"p\",/span\n        span class=\"c1\"# now encode the correctness condition for better_k3 with a ForAll:/span\n        span class=\"c1\"# for all concrete values var1 and var2, it must hold that if/span\n        span class=\"c1\"# var1 is in k1 and var2 is in k2 it follows that var1 + var2 is in/span\n        span class=\"c1\"# better_k3/span\n        span class=\"n\"z3/spanspan class=\"o\"./spanspan class=\"n\"ForAll/spanspan class=\"p\"(/span\n        span class=\"p\"[/spanspan class=\"n\"var1/spanspan class=\"p\",/span span class=\"n\"var2/spanspan class=\"p\"],/span\n        span class=\"n\"z3/spanspan class=\"o\"./spanspan class=\"n\"Implies/spanspan class=\"p\"(/span\n            span class=\"n\"z3/spanspan class=\"o\"./spanspan class=\"n\"And/spanspan class=\"p\"(/spanspan class=\"n\"k1/spanspan class=\"o\"./spanspan class=\"n\"contains/spanspan class=\"p\"(/spanspan class=\"n\"var1/spanspan class=\"p\"),/span span class=\"n\"k2/spanspan class=\"o\"./spanspan class=\"n\"contains/spanspan class=\"p\"(/spanspan class=\"n\"var2/spanspan class=\"p\")),/span\n            span class=\"n\"better_k3/spanspan class=\"o\"./spanspan class=\"n\"contains/spanspan class=\"p\"(/spanspan class=\"n\"var1/span span class=\"o\"+/span span class=\"n\"var2/spanspan class=\"p\")))))/span\n    span class=\"c1\"# if this query is satisfiable, we have found a better result for the/span\n    span class=\"c1\"# abstract_add/span\n    span class=\"k\"if/span span class=\"n\"res/span span class=\"o\"==/span span class=\"n\"z3/spanspan class=\"o\"./spanspan class=\"n\"sat/spanspan class=\"p\":/span\n        span class=\"n\"model/span span class=\"o\"=/span span class=\"n\"solver/spanspan class=\"o\"./spanspan class=\"n\"model/spanspan class=\"p\"()/span\n        span class=\"n\"rk3/span span class=\"o\"=/span span class=\"n\"KnownBits/spanspan class=\"p\"(/spanspan class=\"n\"model/spanspan class=\"o\"./spanspan class=\"n\"eval/spanspan class=\"p\"(/spanspan class=\"n\"ones/spanspan class=\"p\")/spanspan class=\"o\"./spanspan class=\"n\"as_signed_long/spanspan class=\"p\"(),/span span class=\"n\"model/spanspan class=\"o\"./spanspan class=\"n\"eval/spanspan class=\"p\"(/spanspan class=\"n\"unknowns/spanspan class=\"p\")/spanspan class=\"o\"./spanspan class=\"n\"as_signed_long/spanspan class=\"p\"())/span\n        span class=\"nb\"print/spanspan class=\"p\"(/spanspan class=\"s2\"\"better\"/spanspan class=\"p\",/span span class=\"n\"rk3/spanspan class=\"p\")/span\n        span class=\"k\"assert/span span class=\"mi\"0/span\n    span class=\"k\"if/span span class=\"n\"res/span span class=\"o\"==/span span class=\"n\"z3/spanspan class=\"o\"./spanspan class=\"n\"unknown/spanspan class=\"p\":/span\n        span class=\"nb\"print/spanspan class=\"p\"(/spanspan class=\"s2\"\"timeout\"/spanspan class=\"p\")/span\n/pre/div\n\npIt does not actually fail for codeabstract_add/code (nor the other abstract\nfunctions). To see the test failing we can add some imprecision to the\nimplementation of codeabstract_add/code to see Hypothesis and Z3 find examples of\nvalues that are not optimally precise (for example by setting some bits\nof codeunknowns/code in the implementation of codeabstract_add/code unconditionally)./p\nh3 id=\"using-the-abstract-domain-in-the-toy-optimizer-for-generalized-constant-folding\"Using the Abstract Domain in the Toy Optimizer for Generalized Constant Folding/h3\npNow after all this work we can finally actually use the knownbits abstract\ndomain in the toy optimizer. The code for this follows a href=\"https://bernsteinbear.com/blog/toy-abstract-interpretation/\"Max' intro post about\nabstract interpretation/a\nquite closely./p\npFor completeness sake, in the fold there's the basic infrastructure classes\nthat make up the IR again (they are identical or at least extremely close to\nthe previous toy posts)./p\ndetails\nsummarytoy infrastructure/summary\n\ndiv class=\"code\"pre class=\"code literal-block\"span class=\"k\"class/span span class=\"nc\"Value/spanspan class=\"p\":/span\n    span class=\"k\"def/span span class=\"nf\"find/spanspan class=\"p\"(/spanspan class=\"bp\"self/spanspan class=\"p\"):/span\n        span class=\"k\"raise/span span class=\"ne\"NotImplementedError/spanspan class=\"p\"(/spanspan class=\"s2\"\"abstract\"/spanspan class=\"p\")/span\n\n\nspan class=\"nd\"@dataclass/spanspan class=\"p\"(/spanspan class=\"n\"eq/spanspan class=\"o\"=/spanspan class=\"kc\"False/spanspan class=\"p\")/span\nspan class=\"k\"class/span span class=\"nc\"Operation/spanspan class=\"p\"(/spanspan class=\"n\"Value/spanspan class=\"p\"):/span\n    span class=\"n\"name/span span class=\"p\":/span span class=\"nb\"str/span\n    span class=\"n\"args/span span class=\"p\":/span span class=\"nb\"list/spanspan class=\"p\"[/spanspan class=\"n\"Value/spanspan class=\"p\"]/span\n\n    span class=\"n\"forwarded/span span class=\"p\":/span span class=\"n\"Optional/spanspan class=\"p\"[/spanspan class=\"n\"Value/spanspan class=\"p\"]/span span class=\"o\"=/span span class=\"kc\"None/span\n\n    span class=\"k\"def/span span class=\"nf\"find/spanspan class=\"p\"(/spanspan class=\"bp\"self/spanspan class=\"p\")/span span class=\"o\"-gt;/span span class=\"n\"Value/spanspan class=\"p\":/span\n        span class=\"n\"op/span span class=\"o\"=/span span class=\"bp\"self/span\n        span class=\"k\"while/span span class=\"nb\"isinstance/spanspan class=\"p\"(/spanspan class=\"n\"op/spanspan class=\"p\",/span span class=\"n\"Operation/spanspan class=\"p\"):/span\n            span class=\"nb\"next/span span class=\"o\"=/span span class=\"n\"op/spanspan class=\"o\"./spanspan class=\"n\"forwarded/span\n            span class=\"k\"if/span span class=\"nb\"next/span span class=\"ow\"is/span span class=\"kc\"None/spanspan class=\"p\":/span\n                span class=\"k\"return/span span class=\"n\"op/span\n            span class=\"n\"op/span span class=\"o\"=/span span class=\"nb\"next/span\n        span class=\"k\"return/span span class=\"n\"op/span\n\n    span class=\"k\"def/span span class=\"nf\"arg/spanspan class=\"p\"(/spanspan class=\"bp\"self/spanspan class=\"p\",/span span class=\"n\"index/spanspan class=\"p\"):/span\n        span class=\"k\"return/span span class=\"bp\"self/spanspan class=\"o\"./spanspan class=\"n\"args/spanspan class=\"p\"[/spanspan class=\"n\"index/spanspan class=\"p\"]/spanspan class=\"o\"./spanspan class=\"n\"find/spanspan class=\"p\"()/span\n\n    span class=\"k\"def/span span class=\"nf\"make_equal_to/spanspan class=\"p\"(/spanspan class=\"bp\"self/spanspan class=\"p\",/span span class=\"n\"value/span span class=\"p\":/span span class=\"n\"Value/spanspan class=\"p\"):/span\n        span class=\"bp\"self/spanspan class=\"o\"./spanspan class=\"n\"find/spanspan class=\"p\"()/spanspan class=\"o\"./spanspan class=\"n\"forwarded/span span class=\"o\"=/span span class=\"n\"value/span\n\n\nspan class=\"nd\"@dataclass/spanspan class=\"p\"(/spanspan class=\"n\"eq/spanspan class=\"o\"=/spanspan class=\"kc\"False/spanspan class=\"p\")/span\nspan class=\"k\"class/span span class=\"nc\"Constant/spanspan class=\"p\"(/spanspan class=\"n\"Value/spanspan class=\"p\"):/span\n    span class=\"n\"value/span span class=\"p\":/span span class=\"nb\"object/span\n\n    span class=\"k\"def/span span class=\"nf\"find/spanspan class=\"p\"(/spanspan class=\"bp\"self/spanspan class=\"p\"):/span\n        span class=\"k\"return/span span class=\"bp\"self/span\n\n\nspan class=\"k\"class/span span class=\"nc\"Block/spanspan class=\"p\"(/spanspan class=\"nb\"list/spanspan class=\"p\"):/span\n    span class=\"k\"def/span span class=\"fm\"__getattr__/spanspan class=\"p\"(/spanspan class=\"bp\"self/spanspan class=\"p\",/span span class=\"n\"opname/spanspan class=\"p\"):/span\n        span class=\"k\"def/span span class=\"nf\"wraparg/spanspan class=\"p\"(/spanspan class=\"n\"arg/spanspan class=\"p\"):/span\n            span class=\"k\"if/span span class=\"ow\"not/span span class=\"nb\"isinstance/spanspan class=\"p\"(/spanspan class=\"n\"arg/spanspan class=\"p\",/span span class=\"n\"Value/spanspan class=\"p\"):/span\n                span class=\"n\"arg/span span class=\"o\"=/span span class=\"n\"Constant/spanspan class=\"p\"(/spanspan class=\"n\"arg/spanspan class=\"p\")/span\n            span class=\"k\"return/span span class=\"n\"arg/span\n        span class=\"k\"def/span span class=\"nf\"make_op/spanspan class=\"p\"(/spanspan class=\"o\"*/spanspan class=\"n\"args/spanspan class=\"p\"):/span\n            span class=\"n\"op/span span class=\"o\"=/span span class=\"n\"Operation/spanspan class=\"p\"(/spanspan class=\"n\"opname/spanspan class=\"p\",/span\n                span class=\"p\"[/spanspan class=\"n\"wraparg/spanspan class=\"p\"(/spanspan class=\"n\"arg/spanspan class=\"p\")/span span class=\"k\"for/span span class=\"n\"arg/span span class=\"ow\"in/span span class=\"n\"args/spanspan class=\"p\"])/span\n            span class=\"bp\"self/spanspan class=\"o\"./spanspan class=\"n\"append/spanspan class=\"p\"(/spanspan class=\"n\"op/spanspan class=\"p\")/span\n            span class=\"k\"return/span span class=\"n\"op/span\n        span class=\"k\"return/span span class=\"n\"make_op/span\n\n\nspan class=\"k\"def/span span class=\"nf\"bb_to_str/spanspan class=\"p\"(/spanspan class=\"n\"l/span span class=\"p\":/span span class=\"n\"Block/spanspan class=\"p\",/span span class=\"n\"varprefix/span span class=\"p\":/span span class=\"nb\"str/span span class=\"o\"=/span span class=\"s2\"\"var\"/spanspan class=\"p\"):/span\n    span class=\"k\"def/span span class=\"nf\"arg_to_str/spanspan class=\"p\"(/spanspan class=\"n\"arg/span span class=\"p\":/span span class=\"n\"Value/spanspan class=\"p\"):/span\n        span class=\"k\"if/span span class=\"nb\"isinstance/spanspan class=\"p\"(/spanspan class=\"n\"arg/spanspan class=\"p\",/span span class=\"n\"Constant/spanspan class=\"p\"):/span\n            span class=\"k\"return/span span class=\"nb\"str/spanspan class=\"p\"(/spanspan class=\"n\"arg/spanspan class=\"o\"./spanspan class=\"n\"value/spanspan class=\"p\")/span\n        span class=\"k\"else/spanspan class=\"p\":/span\n            span class=\"k\"return/span span class=\"n\"varnames/spanspan class=\"p\"[/spanspan class=\"n\"arg/spanspan class=\"p\"]/span\n\n    span class=\"n\"varnames/span span class=\"o\"=/span span class=\"p\"{}/span\n    span class=\"n\"res/span span class=\"o\"=/span span class=\"p\"[]/span\n    span class=\"k\"for/span span class=\"n\"index/spanspan class=\"p\",/span span class=\"n\"op/span span class=\"ow\"in/span span class=\"nb\"enumerate/spanspan class=\"p\"(/spanspan class=\"n\"l/spanspan class=\"p\"):/span\n        span class=\"c1\"# give the operation a name used while/span\n        span class=\"c1\"# printing:/span\n        span class=\"n\"var/span span class=\"o\"=/span  span class=\"sa\"f/spanspan class=\"s2\"\"/spanspan class=\"si\"{/spanspan class=\"n\"varprefix/spanspan class=\"si\"}{/spanspan class=\"n\"index/spanspan class=\"si\"}/spanspan class=\"s2\"\"/span\n        span class=\"n\"varnames/spanspan class=\"p\"[/spanspan class=\"n\"op/spanspan class=\"p\"]/span span class=\"o\"=/span span class=\"n\"var/span\n        span class=\"n\"arguments/span span class=\"o\"=/span span class=\"s2\"\", \"/spanspan class=\"o\"./spanspan class=\"n\"join/spanspan class=\"p\"(/span\n            span class=\"n\"arg_to_str/spanspan class=\"p\"(/spanspan class=\"n\"op/spanspan class=\"o\"./spanspan class=\"n\"arg/spanspan class=\"p\"(/spanspan class=\"n\"i/spanspan class=\"p\"))/span\n                span class=\"k\"for/span span class=\"n\"i/span span class=\"ow\"in/span span class=\"nb\"range/spanspan class=\"p\"(/spanspan class=\"nb\"len/spanspan class=\"p\"(/spanspan class=\"n\"op/spanspan class=\"o\"./spanspan class=\"n\"args/spanspan class=\"p\"))/span\n        span class=\"p\")/span\n        span class=\"n\"strop/span span class=\"o\"=/span span class=\"sa\"f/spanspan class=\"s2\"\"/spanspan class=\"si\"{/spanspan class=\"n\"var/spanspan class=\"si\"}/spanspan class=\"s2\" = /spanspan class=\"si\"{/spanspan class=\"n\"op/spanspan class=\"o\"./spanspan class=\"n\"name/spanspan class=\"si\"}/spanspan class=\"s2\"(/spanspan class=\"si\"{/spanspan class=\"n\"arguments/spanspan class=\"si\"}/spanspan class=\"s2\")\"/span\n        span class=\"n\"res/spanspan class=\"o\"./spanspan class=\"n\"append/spanspan class=\"p\"(/spanspan class=\"n\"strop/spanspan class=\"p\")/span\n    span class=\"k\"return/span span class=\"s2\"\"/spanspan class=\"se\"\\n/spanspan class=\"s2\"\"/spanspan class=\"o\"./spanspan class=\"n\"join/spanspan class=\"p\"(/spanspan class=\"n\"res/spanspan class=\"p\")/span\n/pre/div\n\n\n\n/details\n\npNow we can write some first tests, the first one simply checking constant\nfolding:/p\ndiv class=\"code\"pre class=\"code literal-block\"span class=\"k\"def/span span class=\"nf\"test_constfold_two_ops/spanspan class=\"p\"():/span\n    span class=\"n\"bb/span span class=\"o\"=/span span class=\"n\"Block/spanspan class=\"p\"()/span\n    span class=\"n\"var0/span span class=\"o\"=/span span class=\"n\"bb/spanspan class=\"o\"./spanspan class=\"n\"getarg/spanspan class=\"p\"(/spanspan class=\"mi\"0/spanspan class=\"p\")/span\n    span class=\"n\"var1/span span class=\"o\"=/span span class=\"n\"bb/spanspan class=\"o\"./spanspan class=\"n\"int_add/spanspan class=\"p\"(/spanspan class=\"mi\"5/spanspan class=\"p\",/span span class=\"mi\"4/spanspan class=\"p\")/span\n    span class=\"n\"var2/span span class=\"o\"=/span span class=\"n\"bb/spanspan class=\"o\"./spanspan class=\"n\"int_add/spanspan class=\"p\"(/spanspan class=\"n\"var1/spanspan class=\"p\",/span span class=\"mi\"10/spanspan class=\"p\")/span\n    span class=\"n\"var3/span span class=\"o\"=/span span class=\"n\"bb/spanspan class=\"o\"./spanspan class=\"n\"int_add/spanspan class=\"p\"(/spanspan class=\"n\"var2/spanspan class=\"p\",/span span class=\"n\"var0/spanspan class=\"p\")/span\n\n    span class=\"n\"opt_bb/span span class=\"o\"=/span span class=\"n\"simplify/spanspan class=\"p\"(/spanspan class=\"n\"bb/spanspan class=\"p\")/span\n    span class=\"k\"assert/span span class=\"n\"bb_to_str/spanspan class=\"p\"(/spanspan class=\"n\"opt_bb/spanspan class=\"p\",/span span class=\"s2\"\"optvar\"/spanspan class=\"p\")/span span class=\"o\"==/span span class=\"s2\"\"\"\"/spanspan class=\"se\"\\/span\nspan class=\"s2\"optvar0 = getarg(0)/span\nspan class=\"s2\"optvar1 = int_add(19, optvar0)\"\"\"/span\n/pre/div\n\npCalling the transfer functions on constant codeKnownBits/code produces a constant\nresults, as we have seen. Therefore \"regular\" constant folding should hopefully\nbe achieved by optimizing with the codeKnownBits/code abstract domain too./p\npThe next two tests are slightly more complicated and can't be optimized by\nregular constant-folding. They follow the motivating examples from the start of\nthis blog post, a hundred years ago:/p\ndiv class=\"code\"pre class=\"code literal-block\"span class=\"n\"def/spanspan class=\"w\" /spanspan class=\"n\"test_constfold_via_knownbits/spanspan class=\"p\"():/span\nspan class=\"w\"    /spanspan class=\"n\"bb/spanspan class=\"w\" /spanspan class=\"o\"=/spanspan class=\"w\" /spanspan class=\"n\"Block/spanspan class=\"p\"()/span\nspan class=\"w\"    /spanspan class=\"n\"var0/spanspan class=\"w\" /spanspan class=\"o\"=/spanspan class=\"w\" /spanspan class=\"n\"bb/spanspan class=\"o\"./spanspan class=\"n\"getarg/spanspan class=\"p\"(/spanspan class=\"mi\"0/spanspan class=\"p\")/span\nspan class=\"w\"    /spanspan class=\"n\"var1/spanspan class=\"w\" /spanspan class=\"o\"=/spanspan class=\"w\" /spanspan class=\"n\"bb/spanspan class=\"o\"./spanspan class=\"n\"int_or/spanspan class=\"p\"(/spanspan class=\"n\"var0/spanspan class=\"p\",/spanspan class=\"w\" /spanspan class=\"mi\"1/spanspan class=\"p\")/span\nspan class=\"w\"    /spanspan class=\"n\"var2/spanspan class=\"w\" /spanspan class=\"o\"=/spanspan class=\"w\" /spanspan class=\"n\"bb/spanspan class=\"o\"./spanspan class=\"n\"int_and/spanspan class=\"p\"(/spanspan class=\"n\"var1/spanspan class=\"p\",/spanspan class=\"w\" /spanspan class=\"mi\"1/spanspan class=\"p\")/span\nspan class=\"w\"    /spanspan class=\"n\"var3/spanspan class=\"w\" /spanspan class=\"o\"=/spanspan class=\"w\" /spanspan class=\"n\"bb/spanspan class=\"o\"./spanspan class=\"n\"dummy/spanspan class=\"p\"(/spanspan class=\"n\"var2/spanspan class=\"p\")/span\n\nspan class=\"w\"    /spanspan class=\"n\"opt_bb/spanspan class=\"w\" /spanspan class=\"o\"=/spanspan class=\"w\" /spanspan class=\"n\"simplify/spanspan class=\"p\"(/spanspan class=\"n\"bb/spanspan class=\"p\")/span\nspan class=\"w\"    /spanspan class=\"nb\"assert/spanspan class=\"w\" /spanspan class=\"n\"bb_to_str/spanspan class=\"p\"(/spanspan class=\"n\"opt_bb/spanspan class=\"p\",/spanspan class=\"w\" /spanspan class=\"s2\"\"optvar\"/spanspan class=\"p\")/spanspan class=\"w\" /spanspan class=\"o\"==/spanspan class=\"w\" /spanspan class=\"s2\"\"\"\"/spanspan class=\"se\"\\/span\nspan class=\"s2\"optvar0 = getarg(0)/span\nspan class=\"s2\"optvar1 = int_or(optvar0, 1)/span\nspan class=\"s2\"optvar2 = dummy(1)\"\"\"/span\n\nspan class=\"n\"def/spanspan class=\"w\" /spanspan class=\"n\"test_constfold_alignment_check/spanspan class=\"p\"():/span\nspan class=\"w\"    /spanspan class=\"n\"bb/spanspan class=\"w\" /spanspan class=\"o\"=/spanspan class=\"w\" /spanspan class=\"n\"Block/spanspan class=\"p\"()/span\nspan class=\"w\"    /spanspan class=\"n\"var0/spanspan class=\"w\" /spanspan class=\"o\"=/spanspan class=\"w\" /spanspan class=\"n\"bb/spanspan class=\"o\"./spanspan class=\"n\"getarg/spanspan class=\"p\"(/spanspan class=\"mi\"0/spanspan class=\"p\")/span\nspan class=\"w\"    /spanspan class=\"n\"var1/spanspan class=\"w\" /spanspan class=\"o\"=/spanspan class=\"w\" /spanspan class=\"n\"bb/spanspan class=\"o\"./spanspan class=\"n\"int_invert/spanspan class=\"p\"(/spanspan class=\"mi\"0/spanspan class=\"n\"b111/spanspan class=\"p\")/span\nspan class=\"w\"    /spanspan class=\"c1\"# mask off the lowest three bits, thus var2 is aligned/span\nspan class=\"w\"    /spanspan class=\"n\"var2/spanspan class=\"w\" /spanspan class=\"o\"=/spanspan class=\"w\" /spanspan class=\"n\"bb/spanspan class=\"o\"./spanspan class=\"n\"int_and/spanspan class=\"p\"(/spanspan class=\"n\"var0/spanspan class=\"p\",/spanspan class=\"w\" /spanspan class=\"n\"var1/spanspan class=\"p\")/span\nspan class=\"w\"    /spanspan class=\"c1\"# add 16 to aligned quantity/span\nspan class=\"w\"    /spanspan class=\"n\"var3/spanspan class=\"w\" /spanspan class=\"o\"=/spanspan class=\"w\" /spanspan class=\"n\"bb/spanspan class=\"o\"./spanspan class=\"n\"int_add/spanspan class=\"p\"(/spanspan class=\"n\"var2/spanspan class=\"p\",/spanspan class=\"w\" /spanspan class=\"mi\"16/spanspan class=\"p\")/span\nspan class=\"w\"    /spanspan class=\"c1\"# check alignment of result/span\nspan class=\"w\"    /spanspan class=\"n\"var4/spanspan class=\"w\" /spanspan class=\"o\"=/spanspan class=\"w\" /spanspan class=\"n\"bb/spanspan class=\"o\"./spanspan class=\"n\"int_and/spanspan class=\"p\"(/spanspan class=\"n\"var3/spanspan class=\"p\",/spanspan class=\"w\" /spanspan class=\"mi\"0/spanspan class=\"n\"b111/spanspan class=\"p\")/span\nspan class=\"w\"    /spanspan class=\"n\"var5/spanspan class=\"w\" /spanspan class=\"o\"=/spanspan class=\"w\" /spanspan class=\"n\"bb/spanspan class=\"o\"./spanspan class=\"n\"int_eq/spanspan class=\"p\"(/spanspan class=\"n\"var4/spanspan class=\"p\",/spanspan class=\"w\" /spanspan class=\"mi\"0/spanspan class=\"p\")/span\nspan class=\"w\"    /spanspan class=\"c1\"# var5 should be const-folded to 1/span\nspan class=\"w\"    /spanspan class=\"n\"var6/spanspan class=\"w\" /spanspan class=\"o\"=/spanspan class=\"w\" /spanspan class=\"n\"bb/spanspan class=\"o\"./spanspan class=\"n\"dummy/spanspan class=\"p\"(/spanspan class=\"n\"var5/spanspan class=\"p\")/span\n\nspan class=\"w\"    /spanspan class=\"n\"opt_bb/spanspan class=\"w\" /spanspan class=\"o\"=/spanspan class=\"w\" /spanspan class=\"n\"simplify/spanspan class=\"p\"(/spanspan class=\"n\"bb/spanspan class=\"p\")/span\nspan class=\"w\"    /spanspan class=\"nb\"assert/spanspan class=\"w\" /spanspan class=\"n\"bb_to_str/spanspan class=\"p\"(/spanspan class=\"n\"opt_bb/spanspan class=\"p\",/spanspan class=\"w\" /spanspan class=\"s2\"\"optvar\"/spanspan class=\"p\")/spanspan class=\"w\" /spanspan class=\"o\"==/spanspan class=\"w\" /spanspan class=\"s2\"\"\"\"/spanspan class=\"se\"\\/span\nspan class=\"s2\"optvar0 = getarg(0)/span\nspan class=\"s2\"optvar1 = int_and(optvar0, -8)/span\nspan class=\"s2\"optvar2 = int_add(optvar1, 16)/span\nspan class=\"s2\"optvar3 = dummy(1)\"\"\"/span\n/pre/div\n\npHere is codesimplify/code to make these tests pass:/p\ndiv class=\"code\"pre class=\"code literal-block\"span class=\"k\"def/span span class=\"nf\"unknown_transfer_functions/spanspan class=\"p\"(/spanspan class=\"o\"*/spanspan class=\"n\"abstract_args/spanspan class=\"p\"):/span\n    span class=\"k\"return/span span class=\"n\"KnownBits/spanspan class=\"o\"./spanspan class=\"n\"all_unknown/spanspan class=\"p\"()/span\n\n\nspan class=\"k\"def/span span class=\"nf\"simplify/spanspan class=\"p\"(/spanspan class=\"n\"bb/spanspan class=\"p\":/span span class=\"n\"Block/spanspan class=\"p\")/span span class=\"o\"-gt;/span span class=\"n\"Block/spanspan class=\"p\":/span\n    span class=\"n\"abstract_values/span span class=\"o\"=/span span class=\"p\"{}/span span class=\"c1\"# dict mapping Operation to KnownBits/span\n\n    span class=\"k\"def/span span class=\"nf\"knownbits_of/spanspan class=\"p\"(/spanspan class=\"n\"val/span span class=\"p\":/span span class=\"n\"Value/spanspan class=\"p\"):/span\n        span class=\"k\"if/span span class=\"nb\"isinstance/spanspan class=\"p\"(/spanspan class=\"n\"val/spanspan class=\"p\",/span span class=\"n\"Constant/spanspan class=\"p\"):/span\n            span class=\"k\"return/span span class=\"n\"KnownBits/spanspan class=\"o\"./spanspan class=\"n\"from_constant/spanspan class=\"p\"(/spanspan class=\"n\"val/spanspan class=\"o\"./spanspan class=\"n\"value/spanspan class=\"p\")/span\n        span class=\"k\"return/span span class=\"n\"abstract_values/spanspan class=\"p\"[/spanspan class=\"n\"val/spanspan class=\"p\"]/span\n\n    span class=\"n\"opt_bb/span span class=\"o\"=/span span class=\"n\"Block/spanspan class=\"p\"()/span\n    span class=\"k\"for/span span class=\"n\"op/span span class=\"ow\"in/span span class=\"n\"bb/spanspan class=\"p\":/span\n        span class=\"c1\"# apply the transfer function on the abstract arguments/span\n        span class=\"n\"name_without_prefix/span span class=\"o\"=/span span class=\"n\"op/spanspan class=\"o\"./spanspan class=\"n\"name/spanspan class=\"o\"./spanspan class=\"n\"removeprefix/spanspan class=\"p\"(/spanspan class=\"s2\"\"int_\"/spanspan class=\"p\")/span\n        span class=\"n\"method_name/span span class=\"o\"=/span span class=\"sa\"f/spanspan class=\"s2\"\"abstract_/spanspan class=\"si\"{/spanspan class=\"n\"name_without_prefix/spanspan class=\"si\"}/spanspan class=\"s2\"\"/span\n        span class=\"n\"transfer_function/span span class=\"o\"=/span span class=\"nb\"getattr/spanspan class=\"p\"(/spanspan class=\"n\"KnownBits/spanspan class=\"p\",/span span class=\"n\"method_name/spanspan class=\"p\",/span span class=\"n\"unknown_transfer_functions/spanspan class=\"p\")/span\n        span class=\"n\"abstract_args/span span class=\"o\"=/span span class=\"p\"[/spanspan class=\"n\"knownbits_of/spanspan class=\"p\"(/spanspan class=\"n\"arg/spanspan class=\"o\"./spanspan class=\"n\"find/spanspan class=\"p\"())/span span class=\"k\"for/span span class=\"n\"arg/span span class=\"ow\"in/span span class=\"n\"op/spanspan class=\"o\"./spanspan class=\"n\"args/spanspan class=\"p\"]/span\n        span class=\"n\"abstract_res/span span class=\"o\"=/span span class=\"n\"abstract_values/spanspan class=\"p\"[/spanspan class=\"n\"op/spanspan class=\"p\"]/span span class=\"o\"=/span span class=\"n\"transfer_function/spanspan class=\"p\"(/spanspan class=\"o\"*/spanspan class=\"n\"abstract_args/spanspan class=\"p\")/span\n        span class=\"c1\"# if the result is a constant, we optimize the operation away and make/span\n        span class=\"c1\"# it equal to the constant result/span\n        span class=\"k\"if/span span class=\"n\"abstract_res/spanspan class=\"o\"./spanspan class=\"n\"is_constant/spanspan class=\"p\"():/span\n            span class=\"n\"op/spanspan class=\"o\"./spanspan class=\"n\"make_equal_to/spanspan class=\"p\"(/spanspan class=\"n\"Constant/spanspan class=\"p\"(/spanspan class=\"n\"abstract_res/spanspan class=\"o\"./spanspan class=\"n\"ones/spanspan class=\"p\"))/span\n            span class=\"k\"continue/span\n        span class=\"c1\"# otherwise emit the op/span\n        span class=\"n\"opt_bb/spanspan class=\"o\"./spanspan class=\"n\"append/spanspan class=\"p\"(/spanspan class=\"n\"op/spanspan class=\"p\")/span\n    span class=\"k\"return/span span class=\"n\"opt_bb/span\n/pre/div\n\npThe code follows the approach from the previous blog post very closely. The\nonly difference is that we apply the transfer function emfirst/em, to be able to\ndetect whether the abstract domain can tell us that the result has to always be\na constant. This code makes all three tests pass./p\nh3 id=\"using-the-knownbits-domain-for-conditional-peephole-rewrites\"Using the codeKnownBits/code Domain for Conditional Peephole Rewrites/h3\npSo far we are only using the codeKnownBits/code domain to find out that certain\noperations have to produce a constant. We can also use the codeKnownBits/code domain\nto check whether certain operation rewrites are correct. Let's use one of the\nexamples from the a href=\"https://www.pypy.org/posts/2024/07/mining-jit-traces-missing-optimizations-z3.html\"Mining JIT traces for missing optimizations with\nZ3/a\npost, where Z3 found the inefficiency code(x lt;lt; 4) amp; -0xf == x lt;lt; 4/code in PyPy JIT\ntraces. We don't have shift operations, but we want to generalize this optimization\nanyway. The general form of this rewrite is that under some circumstances codex amp;\ny == x/code, and we can use the codeKnownBits/code domain to detect situations where this\nmust be true./p\npTo understand emwhen/em codex amp; y == x/code is true, we can think about individual pairs of\nbits codea/code and codeb/code. If codea == 0/code, then codea amp; b == 0 amp; b == 0 == a/code. If codeb == 1/code\nthen codea amp; b == a amp; 1 == a/code. So if either codea == 0/code or codeb == 1/code is true,\ncodea amp; b == a/code follows. And if either of these conditions is true for emall/em the\nbits of codex/code and codey/code, we can know that codex amp; y == x/code./p\npWe can write a method on codeKnownBits/code to check for this condition:/p\ndiv class=\"code\"pre class=\"code literal-block\"span class=\"k\"class/span span class=\"nc\"KnownBits/spanspan class=\"p\":/span\n    span class=\"o\".../span\n\n    span class=\"k\"def/span span class=\"nf\"is_and_identity/spanspan class=\"p\"(/spanspan class=\"bp\"self/spanspan class=\"p\",/span span class=\"n\"other/spanspan class=\"p\"):/span\nspan class=\"w\"        /spanspan class=\"sd\"\"\"\" Return True if n1 amp; n2 == n1 for any n1 in self and n2 in other./span\nspan class=\"sd\"        (or, equivalently, return True if n1 | n2 == n2)\"\"\"/span\n        span class=\"k\"return/span span class=\"bp\"self/spanspan class=\"o\"./spanspan class=\"n\"zeros/span span class=\"o\"|/span span class=\"n\"other/spanspan class=\"o\"./spanspan class=\"n\"ones/span span class=\"o\"==/span span class=\"o\"-/spanspan class=\"mi\"1/span\n/pre/div\n\npSince my reasoning about this feels ripe for errors, let's check that our\nunderstanding is correct with Z3:/p\ndiv class=\"code\"pre class=\"code literal-block\"span class=\"k\"def/span span class=\"nf\"test_prove_is_and_identity/spanspan class=\"p\"():/span\n    span class=\"n\"solver/spanspan class=\"p\",/span span class=\"n\"k1/spanspan class=\"p\",/span span class=\"n\"n1/spanspan class=\"p\",/span span class=\"n\"k2/spanspan class=\"p\",/span span class=\"n\"n2/span span class=\"o\"=/span span class=\"n\"z3_setup_variables/spanspan class=\"p\"()/span\n    span class=\"n\"prove/spanspan class=\"p\"(/spanspan class=\"n\"z3/spanspan class=\"o\"./spanspan class=\"n\"Implies/spanspan class=\"p\"(/spanspan class=\"n\"k1/spanspan class=\"o\"./spanspan class=\"n\"is_and_identity/spanspan class=\"p\"(/spanspan class=\"n\"k2/spanspan class=\"p\"),/span span class=\"n\"n1/span span class=\"o\"amp;/span span class=\"n\"n2/span span class=\"o\"==/span span class=\"n\"n1/spanspan class=\"p\"),/span span class=\"n\"solver/spanspan class=\"p\")/span\n/pre/div\n\npNow let's use this in the toy optimizer. Here are two tests for this rewrite:/p\ndiv class=\"code\"pre class=\"code literal-block\"span class=\"k\"def/span span class=\"nf\"test_remove_redundant_and/spanspan class=\"p\"():/span\n    span class=\"n\"bb/span span class=\"o\"=/span span class=\"n\"Block/spanspan class=\"p\"()/span\n    span class=\"n\"var0/span span class=\"o\"=/span span class=\"n\"bb/spanspan class=\"o\"./spanspan class=\"n\"getarg/spanspan class=\"p\"(/spanspan class=\"mi\"0/spanspan class=\"p\")/span\n    span class=\"n\"var1/span span class=\"o\"=/span span class=\"n\"bb/spanspan class=\"o\"./spanspan class=\"n\"int_invert/spanspan class=\"p\"(/spanspan class=\"mb\"0b1111/spanspan class=\"p\")/span\n    span class=\"c1\"# mask off the lowest four bits/span\n    span class=\"n\"var2/span span class=\"o\"=/span span class=\"n\"bb/spanspan class=\"o\"./spanspan class=\"n\"int_and/spanspan class=\"p\"(/spanspan class=\"n\"var0/spanspan class=\"p\",/span span class=\"n\"var1/spanspan class=\"p\")/span\n    span class=\"c1\"# applying the same mask is not redundant/span\n    span class=\"n\"var3/span span class=\"o\"=/span span class=\"n\"bb/spanspan class=\"o\"./spanspan class=\"n\"int_and/spanspan class=\"p\"(/spanspan class=\"n\"var2/spanspan class=\"p\",/span span class=\"n\"var1/spanspan class=\"p\")/span\n    span class=\"n\"var4/span span class=\"o\"=/span span class=\"n\"bb/spanspan class=\"o\"./spanspan class=\"n\"dummy/spanspan class=\"p\"(/spanspan class=\"n\"var3/spanspan class=\"p\")/span\n\n    span class=\"n\"opt_bb/span span class=\"o\"=/span span class=\"n\"simplify/spanspan class=\"p\"(/spanspan class=\"n\"bb/spanspan class=\"p\")/span\n    span class=\"k\"assert/span span class=\"n\"bb_to_str/spanspan class=\"p\"(/spanspan class=\"n\"opt_bb/spanspan class=\"p\",/span span class=\"s2\"\"optvar\"/spanspan class=\"p\")/span span class=\"o\"==/span span class=\"s2\"\"\"\"/spanspan class=\"se\"\\/span\nspan class=\"s2\"optvar0 = getarg(0)/span\nspan class=\"s2\"optvar1 = int_and(optvar0, -16)/span\nspan class=\"s2\"optvar2 = dummy(optvar1)\"\"\"/span\n\nspan class=\"k\"def/span span class=\"nf\"test_remove_redundant_and_more_complex/spanspan class=\"p\"():/span\n    span class=\"n\"bb/span span class=\"o\"=/span span class=\"n\"Block/spanspan class=\"p\"()/span\n    span class=\"n\"var0/span span class=\"o\"=/span span class=\"n\"bb/spanspan class=\"o\"./spanspan class=\"n\"getarg/spanspan class=\"p\"(/spanspan class=\"mi\"0/spanspan class=\"p\")/span\n    span class=\"n\"var1/span span class=\"o\"=/span span class=\"n\"bb/spanspan class=\"o\"./spanspan class=\"n\"getarg/spanspan class=\"p\"(/spanspan class=\"mi\"1/spanspan class=\"p\")/span\n    span class=\"c1\"# var2 has bit pattern ????/span\n    span class=\"n\"var2/span span class=\"o\"=/span span class=\"n\"bb/spanspan class=\"o\"./spanspan class=\"n\"int_and/spanspan class=\"p\"(/spanspan class=\"n\"var0/spanspan class=\"p\",/span span class=\"mb\"0b1111/spanspan class=\"p\")/span\n    span class=\"c1\"# var3 has bit pattern ...?1111/span\n    span class=\"n\"var3/span span class=\"o\"=/span span class=\"n\"bb/spanspan class=\"o\"./spanspan class=\"n\"int_or/spanspan class=\"p\"(/spanspan class=\"n\"var1/spanspan class=\"p\",/span span class=\"mb\"0b1111/spanspan class=\"p\")/span\n    span class=\"c1\"# var4 is just var2/span\n    span class=\"n\"var4/span span class=\"o\"=/span span class=\"n\"bb/spanspan class=\"o\"./spanspan class=\"n\"int_and/spanspan class=\"p\"(/spanspan class=\"n\"var2/spanspan class=\"p\",/span span class=\"n\"var3/spanspan class=\"p\")/span\n    span class=\"n\"var5/span span class=\"o\"=/span span class=\"n\"bb/spanspan class=\"o\"./spanspan class=\"n\"dummy/spanspan class=\"p\"(/spanspan class=\"n\"var4/spanspan class=\"p\")/span\n\n    span class=\"n\"opt_bb/span span class=\"o\"=/span span class=\"n\"simplify/spanspan class=\"p\"(/spanspan class=\"n\"bb/spanspan class=\"p\")/span\n    span class=\"k\"assert/span span class=\"n\"bb_to_str/spanspan class=\"p\"(/spanspan class=\"n\"opt_bb/spanspan class=\"p\",/span span class=\"s2\"\"optvar\"/spanspan class=\"p\")/span span class=\"o\"==/span span class=\"s2\"\"\"\"/spanspan class=\"se\"\\/span\nspan class=\"s2\"optvar0 = getarg(0)/span\nspan class=\"s2\"optvar1 = getarg(1)/span\nspan class=\"s2\"optvar2 = int_and(optvar0, 15)/span\nspan class=\"s2\"optvar3 = int_or(optvar1, 15)/span\nspan class=\"s2\"optvar4 = dummy(optvar2)\"\"\"/span\n/pre/div\n\npThe first test could also be made to pass by implementing a reassociation\noptimization that turns code(x amp; c1) amp; c2/code into codex amp; (c1 amp; c2)/code and then constant-folds the second codeand/code. But here we want to\nuse codeKnownBits/code and conditionally rewrite codeint_and/code to its first argument. So to make the tests pass,\nwe can change codesimplify/code like this:/p\ndiv class=\"code\"pre class=\"code literal-block\"span class=\"k\"def/span span class=\"nf\"simplify/spanspan class=\"p\"(/spanspan class=\"n\"bb/spanspan class=\"p\":/span span class=\"n\"Block/spanspan class=\"p\")/span span class=\"o\"-gt;/span span class=\"n\"Block/spanspan class=\"p\":/span\n    span class=\"n\"abstract_values/span span class=\"o\"=/span span class=\"p\"{}/span span class=\"c1\"# dict mapping Operation to KnownBits/span\n\n    span class=\"k\"def/span span class=\"nf\"knownbits_of/spanspan class=\"p\"(/spanspan class=\"n\"val/span span class=\"p\":/span span class=\"n\"Value/spanspan class=\"p\"):/span\n        span class=\"o\".../span\n\n    span class=\"n\"opt_bb/span span class=\"o\"=/span span class=\"n\"Block/spanspan class=\"p\"()/span\n    span class=\"k\"for/span span class=\"n\"op/span span class=\"ow\"in/span span class=\"n\"bb/spanspan class=\"p\":/span\n        span class=\"c1\"# apply the transfer function on the abstract arguments/span\n        span class=\"n\"name_without_prefix/span span class=\"o\"=/span span class=\"n\"op/spanspan class=\"o\"./spanspan class=\"n\"name/spanspan class=\"o\"./spanspan class=\"n\"removeprefix/spanspan class=\"p\"(/spanspan class=\"s2\"\"int_\"/spanspan class=\"p\")/span\n        span class=\"n\"method_name/span span class=\"o\"=/span span class=\"sa\"f/spanspan class=\"s2\"\"abstract_/spanspan class=\"si\"{/spanspan class=\"n\"name_without_prefix/spanspan class=\"si\"}/spanspan class=\"s2\"\"/span\n        span class=\"n\"transfer_function/span span class=\"o\"=/span span class=\"nb\"getattr/spanspan class=\"p\"(/spanspan class=\"n\"KnownBits/spanspan class=\"p\",/span span class=\"n\"method_name/spanspan class=\"p\",/span span class=\"n\"unknown_transfer_functions/spanspan class=\"p\")/span\n        span class=\"n\"abstract_args/span span class=\"o\"=/span span class=\"p\"[/spanspan class=\"n\"knownbits_of/spanspan class=\"p\"(/spanspan class=\"n\"arg/spanspan class=\"o\"./spanspan class=\"n\"find/spanspan class=\"p\"())/span span class=\"k\"for/span span class=\"n\"arg/span span class=\"ow\"in/span span class=\"n\"op/spanspan class=\"o\"./spanspan class=\"n\"args/spanspan class=\"p\"]/span\n        span class=\"n\"abstract_res/span span class=\"o\"=/span span class=\"n\"abstract_values/spanspan class=\"p\"[/spanspan class=\"n\"op/spanspan class=\"p\"]/span span class=\"o\"=/span span class=\"n\"transfer_function/spanspan class=\"p\"(/spanspan class=\"o\"*/spanspan class=\"n\"abstract_args/spanspan class=\"p\")/span\n        span class=\"c1\"# if the result is a constant, we optimize the operation away and make/span\n        span class=\"c1\"# it equal to the constant result/span\n        span class=\"k\"if/span span class=\"n\"abstract_res/spanspan class=\"o\"./spanspan class=\"n\"is_constant/spanspan class=\"p\"():/span\n            span class=\"n\"op/spanspan class=\"o\"./spanspan class=\"n\"make_equal_to/spanspan class=\"p\"(/spanspan class=\"n\"Constant/spanspan class=\"p\"(/spanspan class=\"n\"abstract_res/spanspan class=\"o\"./spanspan class=\"n\"ones/spanspan class=\"p\"))/span\n            span class=\"k\"continue/span\n        span class=\"c1\"# lt;lt;lt;lt; new code/span\n        span class=\"c1\"# conditionally rewrite int_and(x, y) to x/span\n        span class=\"k\"if/span span class=\"n\"op/spanspan class=\"o\"./spanspan class=\"n\"name/span span class=\"o\"==/span span class=\"s2\"\"int_and\"/spanspan class=\"p\":/span\n            span class=\"n\"k1/spanspan class=\"p\",/span span class=\"n\"k2/span span class=\"o\"=/span span class=\"n\"abstract_args/span\n            span class=\"k\"if/span span class=\"n\"k1/spanspan class=\"o\"./spanspan class=\"n\"is_and_identity/spanspan class=\"p\"(/spanspan class=\"n\"k2/spanspan class=\"p\"):/span\n                span class=\"n\"op/spanspan class=\"o\"./spanspan class=\"n\"make_equal_to/spanspan class=\"p\"(/spanspan class=\"n\"op/spanspan class=\"o\"./spanspan class=\"n\"arg/spanspan class=\"p\"(/spanspan class=\"mi\"0/spanspan class=\"p\"))/span\n                span class=\"k\"continue/span\n        span class=\"c1\"# gt;gt;gt;gt; end changes/span\n        span class=\"n\"opt_bb/spanspan class=\"o\"./spanspan class=\"n\"append/spanspan class=\"p\"(/spanspan class=\"n\"op/spanspan class=\"p\")/span\n    span class=\"k\"return/span span class=\"n\"opt_bb/span\n/pre/div\n\npAnd with that, the new tests pass as well. A real implementation would also\ncheck the other argument order, but we leave that out for the sake of brevity./p\npThis rewrite also generalizes the a href=\"https://pypy.org/posts/2024/07/finding-simple-rewrite-rules-jit-z3.html\"rewrites/a codeint_and(0, x) -gt; 0/code and\ncodeint_and(-1, x) -gt; x/code, let's add a test for those:/p\ndiv class=\"code\"pre class=\"code literal-block\"span class=\"k\"def/span span class=\"nf\"test_remove_and_simple/spanspan class=\"p\"():/span\n    span class=\"n\"bb/span span class=\"o\"=/span span class=\"n\"Block/spanspan class=\"p\"()/span\n    span class=\"n\"var0/span span class=\"o\"=/span span class=\"n\"bb/spanspan class=\"o\"./spanspan class=\"n\"getarg/spanspan class=\"p\"(/spanspan class=\"mi\"0/spanspan class=\"p\")/span\n    span class=\"n\"var1/span span class=\"o\"=/span span class=\"n\"bb/spanspan class=\"o\"./spanspan class=\"n\"getarg/spanspan class=\"p\"(/spanspan class=\"mi\"1/spanspan class=\"p\")/span\n    span class=\"n\"var2/span span class=\"o\"=/span span class=\"n\"bb/spanspan class=\"o\"./spanspan class=\"n\"int_and/spanspan class=\"p\"(/spanspan class=\"mi\"0/spanspan class=\"p\",/span span class=\"n\"var0/spanspan class=\"p\")/span span class=\"c1\"# == 0/span\n    span class=\"n\"var3/span span class=\"o\"=/span span class=\"n\"bb/spanspan class=\"o\"./spanspan class=\"n\"int_invert/spanspan class=\"p\"(/spanspan class=\"n\"var2/spanspan class=\"p\")/span span class=\"c1\"# == -1/span\n    span class=\"n\"var4/span span class=\"o\"=/span span class=\"n\"bb/spanspan class=\"o\"./spanspan class=\"n\"int_and/spanspan class=\"p\"(/spanspan class=\"n\"var1/spanspan class=\"p\",/span span class=\"n\"var3/spanspan class=\"p\")/span span class=\"c1\"# == var1/span\n    span class=\"n\"var5/span span class=\"o\"=/span span class=\"n\"bb/spanspan class=\"o\"./spanspan class=\"n\"dummy/spanspan class=\"p\"(/spanspan class=\"n\"var4/spanspan class=\"p\")/span\n\n    span class=\"n\"opt_bb/span span class=\"o\"=/span span class=\"n\"simplify/spanspan class=\"p\"(/spanspan class=\"n\"bb/spanspan class=\"p\")/span\n    span class=\"k\"assert/span span class=\"n\"bb_to_str/spanspan class=\"p\"(/spanspan class=\"n\"opt_bb/spanspan class=\"p\",/span span class=\"s2\"\"optvar\"/spanspan class=\"p\")/span span class=\"o\"==/span span class=\"s2\"\"\"\"/spanspan class=\"se\"\\/span\nspan class=\"s2\"optvar0 = getarg(0)/span\nspan class=\"s2\"optvar1 = getarg(1)/span\nspan class=\"s2\"optvar2 = dummy(optvar1)\"\"\"/span\n/pre/div\n\npThis test just passes. And that's it for this post!/p\nh3 id=\"conclusion\"Conclusion/h3\npIn this post we've seen the implementation, testing and proofs about a 'known\nbits' abstract domain, as well as its use in the toy optimizer to generalize\nconstant folding, and to implement conditional peephole rewrites./p\npIn the next posts I'll write about the real implementation of a knownbits\ndomain in PyPy's JIT, its combination with the existing interval abstract\ndomain, how to deal with gaining information from conditions in the program,\nand some lose ends./p\npSources:/p\nul\nlia href=\"https://github.com/llvm/llvm-project/blob/main/llvm/lib/Support/KnownBits.cpp\"Known bits in LLVM/a/li\nlia href=\"https://github.com/torvalds/linux/blob/master/kernel/bpf/tnum.c\"Tristate numbers for known bits in Linux eBPF/a/li\nlia href=\"https://arxiv.org/abs/2105.05398\"Sound, Precise, and Fast Abstract Interpretation with Tristate Numbers/a/li\nlia href=\"https://people.cs.rutgers.edu/~sn349/papers/agni-cav2023.pdf\"Verifying the Verier: eBPF Range Analysis Verication/a/li\nlia href=\"https://dougallj.wordpress.com/2020/01/13/bit-twiddling-addition-with-unknown-bits/\"Bit-Twiddling: Addition with Unknown\n  Bits/a\n  is a super readable blog post by Dougall J. I've taken the codeones/code and\n  codeunknowns/code naming from this post, which I find significantly clearer than\n  codevalue/code and codemask/code, which the Linux kernel uses./li\nlia href=\"https://bitmath.blogspot.com/\"Bits, Math and Performance(?)/a, a fantastic\n  blog by a href=\"https://mastodon.gamedev.place/@harold\"Harold Aptroot/a. There are a\n  lot of relevant posts about known bits, range analysis etc. Harold is also\n  the author of a href=\"http://haroldbot.nl/\"Haroldbot/a, a website that can be used\n  for bitvector calculations, and also checks bitvector identities./li\nlia href=\"https://cea.hal.science/cea-01795779/document\"Sharpening Constraint Programming approaches for Bit-Vector Theory/a/li\nlia href=\"https://users.cs.utah.edu/~regehr/papers/lctes06_2/fp019-regehr.pdf\"Deriving Abstract Transfer Functions for Analyzing Embedded Software/a/li\nlia href=\"https://arxiv.org/abs/2105.00493\"Synthesizing Abstract Transformers/a/li\n/ul\ndiv class=\"footnote\"\nhr\nol\nli id=\"fn:proof_bitwidths\"\npThere's a subtletly about the Z3 proofs that I'm sort of\nglossing over here. Python integers are of arbitrary width, and the\ncodeKnownBits/code code is actually carefully written to work for integers of any\nsize. This property is tested by the Hypothesis tests, which don't limit\nthe sizes of the generated random integers. However, the Z3 proofs only\ncheck bitvectors of a fixed bitwidth of 64. There are various ways to deal\nwith this situation. For most \"real\" compilers, the bitwidth of integers\nwould be fixed anyway. Then the components codeones/code and codeunknowns/code of the\ncodeKnownBits/code class would use the number of bits the corresponding integer\nvariable has, and the Z3 proofs would use the same width. This is what we\ndo in the PyPy JIT. a class=\"footnote-backref\" href=\"https://www.pypy.org/posts/2024/08/toy-knownbits.html#fnref:proof_bitwidths\" title=\"Jump back to footnote 1 in the text\"/a/p\n/li\nli id=\"fn:tests_vs_proofs\"\npThe less close connection between implementation and proof\nfor codeabstract_eq/code is one of the reasons why it makes sense to do\nunit-testing emin addition/em to proofs. For a more detailed explanation of\nwhy both tests and proofs are good to\nhave, see a href=\"https://siek.blogspot.com/2024/06/data-structures-and-algorithms-correctly.html#correct-software-via-write-test-and-prove:~:text=We%20recognize%20that%20once%20step,detect%20most%20of%20the%20bugs\"Jeremy Siek's blog\npost/a,\nas well as the a href=\"https://www-cs-faculty.stanford.edu/~knuth/faq.html#:~:text=What's%20the%20exact%20citation%20of%20your%20oft%2Dcited%20comment%20about%20bugs?\"Knuth\nquote/a. a class=\"footnote-backref\" href=\"https://www.pypy.org/posts/2024/08/toy-knownbits.html#fnref:tests_vs_proofs\" title=\"Jump back to footnote 2 in the text\"/a/p\n/li\n/ol\n/div",
      "link": "https://www.pypy.org/posts/2024/08/toy-knownbits.html",
      "links": [],
      "published": "2024-08-03T14:00:00+00:00",
      "summary": "",
      "title": "A Knownbits Abstract Domain for the Toy Optimizer, Correctly"
    },
    {
      "author": "Max Bernstein",
      "content": [
        {
          "type": "text/html",
          "value": "pThis is a a href=\"https://bernsteinbear.com/blog/toy-abstract-interpretation/\" rel=\"canonical\"cross-post/a\nfrom Max Bernstein from his excellent blog where he writes about programming\nlanguages, compilers, optimizations, virtual machines. He's looking for a\n(dynamic language runtime or compiler related) job too./p\nhr\npCF Bolz-Tereick wrote some excellent posts in which they a href=\"https://pypy.org/posts/2022/07/toy-optimizer.html\"introduce a small IR\nand optimizer/a and a href=\"https://pypy.org/posts/2022/10/toy-optimizer-allocation-removal.html\"extend it with allocation\nremoval/a. We also did a live stream together in which\nwe did a href=\"https://www.youtube.com/watch?v=w-UHg0yOPSE\"some more heap optimizations/a./p\npIn this blog post, I'm going to write a small abstract interpreter for the Toy\nIR and then show how we can use it to do some simple optimizations. It assumes\nthat you are familiar with the little IR, which I have reproduced unchanged in\na href=\"https://gist.github.com/tekknolagi/4425b28d5267e7bae8b0d7ef8fb4a671\"a GitHub Gist/a./p\npAbstract interpretation is a general framework for efficiently computing\nproperties that must be true for all possible executions of a program. It's a\nwidely used approach both in compiler optimizations as well as offline static\nanalysis for finding bugs. I'm writing this post to pave the way for CF's next\npost on proving abstract interpreters correct for range analysis and known bits\nanalysis inside PyPy./p\npBefore we begin, I want to note a couple of things:/p\nul\nliThe Toy IR is in SSA form, which means that every variable is defined exactly\n  once. This means that abstract properties of each variable are easy to track./li\nliThe Toy IR represents a linear trace without control flow, meaning we won't\n  talk about meet/join or fixpoints. They only make sense if the IR has a\n  notion of conditional branches or back edges (loops)./li\n/ul\npAlright, let's get started./p\nh3 id=\"welcome-to-abstract-interpretation\"Welcome to abstract interpretation/h3\npAbstract interpretation means a couple different things to different people.\nThere's rigorous mathematical formalism thanks to Patrick and Radhia Cousot,\nour favorite power couple, and there's also sketchy hand-wavy stuff like what\nwill follow in this post. In the end, all people are trying to do is reason\nabout program behavior without running it./p\npIn particular, abstract interpretation is an emover-approximation/em of the\nbehavior of a program. Correctly implemented abstract interpreters never lie,\nbut they might be a little bit pessimistic. This is because instead of using\nreal values and running the program---which would produce a concrete result and\nsome real-world behavior---we \"run\" the program with a parallel universe of\nemabstract/em values. This abstract run gives us information about all possible\nruns of the program.sup id=\"fnref:logozzo\"a class=\"footnote-ref\" href=\"https://www.pypy.org/posts/2024/07/toy-abstract-interpretation.html#fn:logozzo\"1/a/sup/p\npAbstract values always represent sets of concrete values. Instead of literally\nstoring a set (in the world of integers, for example, it could get pretty\nbig...there are a lot of integers), we group them into a finite number of named\nsubsets.sup id=\"fnref:lattices\"a class=\"footnote-ref\" href=\"https://www.pypy.org/posts/2024/07/toy-abstract-interpretation.html#fn:lattices\"2/a/sup/p\npLet's learn a little about abstract interpretation with an example program and\nexample abstract domain. Here's the example program:/p\ndiv class=\"code\"pre class=\"code literal-block\"span class=\"n\"v0/span span class=\"o\"=/span span class=\"mi\"1/span\nspan class=\"n\"v1/span span class=\"o\"=/span span class=\"mi\"2/span\nspan class=\"n\"v2/span span class=\"o\"=/span span class=\"n\"add/spanspan class=\"p\"(/spanspan class=\"n\"v0/spanspan class=\"p\",/span span class=\"n\"v1/spanspan class=\"p\")/span\n/pre/div\n\npAnd our abstract domain is \"is the number positive\" (where \"positive\" means\nnonnegative, but I wanted to keep the words distinct):/p\ndiv class=\"code\"pre class=\"code literal-block\"       top\n    /       \\\npositive    negative\n    \\       /\n      bottom\n/pre/div\n\npThe special emtop/em value means \"I don't know\" and the special embottom/em value\nmeans \"empty set\" or \"unreachable\". The empositive/em and emnegative/em values\nrepresent the sets of all positive and negative numbers, respectively./p\npWe initialize all the variables codev0/code, codev1/code, and codev2/code to embottom/em and then walk\nour IR, updating our knowledge as we go./p\ndiv class=\"code\"pre class=\"code literal-block\"span class=\"c1\"# here/span\nspan class=\"n\"v0/spanspan class=\"p\":/spanspan class=\"n\"bottom/span span class=\"o\"=/span span class=\"mi\"1/span\nspan class=\"n\"v1/spanspan class=\"p\":/spanspan class=\"n\"bottom/span span class=\"o\"=/span span class=\"mi\"2/span\nspan class=\"n\"v2/spanspan class=\"p\":/spanspan class=\"n\"bottom/span span class=\"o\"=/span span class=\"n\"add/spanspan class=\"p\"(/spanspan class=\"n\"v0/spanspan class=\"p\",/span span class=\"n\"v1/spanspan class=\"p\")/span\n/pre/div\n\npIn order to do that, we have to have emtransfer functions/em for each operation.\nFor constants, the transfer function is easy: determine if the constant is\npositive or negative. For other operations, we have to define a function that\ntakes the abstract values of the operands and returns the abstract value of the\nresult./p\npIn order to be correct, transfer functions for operations have to be compatible\nwith the behavior of their corresponding concrete implementations. You can\nthink of them having an implicit universal quantifier emforall/em in front of\nthem./p\npLet's step through the constants at least:/p\ndiv class=\"code\"pre class=\"code literal-block\"span class=\"n\"v0/spanspan class=\"p\":/spanspan class=\"n\"positive/span span class=\"o\"=/span span class=\"mi\"1/span\nspan class=\"n\"v1/spanspan class=\"p\":/spanspan class=\"n\"positive/span span class=\"o\"=/span span class=\"mi\"2/span\nspan class=\"c1\"# here/span\nspan class=\"n\"v2/spanspan class=\"p\":/spanspan class=\"n\"bottom/span span class=\"o\"=/span span class=\"n\"add/spanspan class=\"p\"(/spanspan class=\"n\"v0/spanspan class=\"p\",/span span class=\"n\"v1/spanspan class=\"p\")/span\n/pre/div\n\npNow we need to figure out the transfer function for codeadd/code. It's kind of tricky\nright now because we haven't specified our abstract domain very well. I keep\nsaying \"numbers\", but what kinds of numbers? Integers? Real numbers? Floating\npoint? Some kind of fixed-width bit vector (codeint8/code, codeuint32/code, ...) like an\nactual machine \"integer\"?/p\npFor this post, I am going to use the mathematical definition of integer, which\nmeans that the values are not bounded in size and therefore do not overflow.\nActual hardware memory constraints aside, this is kind of like a Python codeint/code./p\npSo let's look at what happens when we add two abstract numbers:/p\ntable\nthead\ntr\nth/th\nthtop/th\nthpositive/th\nthnegative/th\nthbottom/th\n/tr\n/thead\ntbody\ntr\ntdstrongtop/strong/td\ntdtop/td\ntdtop/td\ntdtop/td\ntdbottom/td\n/tr\ntr\ntdstrongpositive/strong/td\ntdtop/td\ntdpositive/td\ntdtop/td\ntdbottom/td\n/tr\ntr\ntdstrongnegative/strong/td\ntdtop/td\ntdtop/td\ntdnegative/td\ntdbottom/td\n/tr\ntr\ntdstrongbottom/strong/td\ntdbottom/td\ntdbottom/td\ntdbottom/td\ntdbottom/td\n/tr\n/tbody\n/table\npAs an example, let's try to add two numbers codea/code and codeb/code, where codea/code is positive\nand codeb/code is negative. We don't know anything about their values other than their\nsigns. They could be code5/code and code-3/code, where the result is code2/code, or they could be\ncode1/code and code-100/code, where the result is code-99/code. This is why we can't say anything\nabout the result of this operation and have to return emtop/em./p\npThe short of this table is that we only really know the result of an addition\nif both operands are positive or both operands are negative. Thankfully, in\nthis example, both operands are known positive. So we can learn something about\ncodev2/code:/p\ndiv class=\"code\"pre class=\"code literal-block\"span class=\"n\"v0/spanspan class=\"p\":/spanspan class=\"n\"positive/span span class=\"o\"=/span span class=\"mi\"1/span\nspan class=\"n\"v1/spanspan class=\"p\":/spanspan class=\"n\"positive/span span class=\"o\"=/span span class=\"mi\"2/span\nspan class=\"n\"v2/spanspan class=\"p\":/spanspan class=\"n\"positive/span span class=\"o\"=/span span class=\"n\"add/spanspan class=\"p\"(/spanspan class=\"n\"v0/spanspan class=\"p\",/span span class=\"n\"v1/spanspan class=\"p\")/span\nspan class=\"c1\"# here/span\n/pre/div\n\npThis may not seem useful in isolation, but analyzing more complex programs even\nwith this simple domain may be able to remove checks such as codeif (v2 lt; 0) { ... }/code./p\npLet's take a look at another example using an sample codeabsval/code (absolute value)\nIR operation:/p\ndiv class=\"code\"pre class=\"code literal-block\"span class=\"n\"v0/span span class=\"o\"=/span span class=\"n\"getarg/spanspan class=\"p\"(/spanspan class=\"mi\"0/spanspan class=\"p\")/span\nspan class=\"n\"v1/span span class=\"o\"=/span span class=\"n\"getarg/spanspan class=\"p\"(/spanspan class=\"mi\"1/spanspan class=\"p\")/span\nspan class=\"n\"v2/span span class=\"o\"=/span span class=\"n\"absval/spanspan class=\"p\"(/spanspan class=\"n\"v0/spanspan class=\"p\")/span\nspan class=\"n\"v3/span span class=\"o\"=/span span class=\"n\"absval/spanspan class=\"p\"(/spanspan class=\"n\"v1/spanspan class=\"p\")/span\nspan class=\"n\"v4/span span class=\"o\"=/span span class=\"n\"add/spanspan class=\"p\"(/spanspan class=\"n\"v2/spanspan class=\"p\",/span span class=\"n\"v3/spanspan class=\"p\")/span\nspan class=\"n\"v5/span span class=\"o\"=/span span class=\"n\"absval/spanspan class=\"p\"(/spanspan class=\"n\"v4/spanspan class=\"p\")/span\n/pre/div\n\npEven though we have no constant/concrete values, we can still learn something\nabout the states of values throughout the program. Since we know that codeabsval/code\nalways returns a positive number, we learn that codev2/code, codev3/code, and codev4/code are all\npositive. This means that we can optimize out the codeabsval/code operation on codev5/code:/p\ndiv class=\"code\"pre class=\"code literal-block\"span class=\"n\"v0/spanspan class=\"p\":/spanspan class=\"n\"top/span span class=\"o\"=/span span class=\"n\"getarg/spanspan class=\"p\"(/spanspan class=\"mi\"0/spanspan class=\"p\")/span\nspan class=\"n\"v1/spanspan class=\"p\":/spanspan class=\"n\"top/span span class=\"o\"=/span span class=\"n\"getarg/spanspan class=\"p\"(/spanspan class=\"mi\"1/spanspan class=\"p\")/span\nspan class=\"n\"v2/spanspan class=\"p\":/spanspan class=\"n\"positive/span span class=\"o\"=/span span class=\"n\"absval/spanspan class=\"p\"(/spanspan class=\"n\"v0/spanspan class=\"p\")/span\nspan class=\"n\"v3/spanspan class=\"p\":/spanspan class=\"n\"positive/span span class=\"o\"=/span span class=\"n\"absval/spanspan class=\"p\"(/spanspan class=\"n\"v1/spanspan class=\"p\")/span\nspan class=\"n\"v4/spanspan class=\"p\":/spanspan class=\"n\"positive/span span class=\"o\"=/span span class=\"n\"add/spanspan class=\"p\"(/spanspan class=\"n\"v2/spanspan class=\"p\",/span span class=\"n\"v3/spanspan class=\"p\")/span\nspan class=\"n\"v5/spanspan class=\"p\":/spanspan class=\"n\"positive/span span class=\"o\"=/span span class=\"n\"v4/span\n/pre/div\n\npOther interesting lattices include:/p\nul\nliConstants (where the middle row is pretty wide)/li\nliRange analysis (bounds on min and max of a number)/li\nliKnown bits (using a bitvector representation of a number, which bits are\n  always 0 or 1)/li\n/ul\npFor the rest of this blog post, we are going to do a very limited version of\n\"known bits\", called emparity/em. This analysis only tracks the least significant\nbit of a number, which indicates if it is even or odd./p\nh3 id=\"parity\"Parity/h3\npThe lattice is pretty similar to the positive/negative lattice:/p\ndiv class=\"code\"pre class=\"code literal-block\"    top\n  /     \\\neven    odd\n  \\     /\n   bottom\n/pre/div\n\npLet's define a data structure to represent this in Python code:/p\ndiv class=\"code\"pre class=\"code literal-block\"span class=\"k\"class/span span class=\"nc\"Parity/spanspan class=\"p\":/span\n    span class=\"k\"def/span span class=\"fm\"__init__/spanspan class=\"p\"(/spanspan class=\"bp\"self/spanspan class=\"p\",/span span class=\"n\"name/spanspan class=\"p\"):/span\n        span class=\"bp\"self/spanspan class=\"o\"./spanspan class=\"n\"name/span span class=\"o\"=/span span class=\"n\"name/span\n\n    span class=\"k\"def/span span class=\"fm\"__repr__/spanspan class=\"p\"(/spanspan class=\"bp\"self/spanspan class=\"p\"):/span\n        span class=\"k\"return/span span class=\"bp\"self/spanspan class=\"o\"./spanspan class=\"n\"name/span\n/pre/div\n\npAnd instantiate the members of the lattice:/p\ndiv class=\"code\"pre class=\"code literal-block\"span class=\"n\"TOP/span span class=\"o\"=/span span class=\"n\"Parity/spanspan class=\"p\"(/spanspan class=\"s2\"\"top\"/spanspan class=\"p\")/span\nspan class=\"n\"EVEN/span span class=\"o\"=/span span class=\"n\"Parity/spanspan class=\"p\"(/spanspan class=\"s2\"\"even\"/spanspan class=\"p\")/span\nspan class=\"n\"ODD/span span class=\"o\"=/span span class=\"n\"Parity/spanspan class=\"p\"(/spanspan class=\"s2\"\"odd\"/spanspan class=\"p\")/span\nspan class=\"n\"BOTTOM/span span class=\"o\"=/span span class=\"n\"Parity/spanspan class=\"p\"(/spanspan class=\"s2\"\"bottom\"/spanspan class=\"p\")/span\n/pre/div\n\npNow let's write a forward flow analysis of a basic block using this lattice.\nWe'll do that by assuming that a method on codeParity/code is defined for each IR\noperation. For example, codeParity.add/code, codeParity.lshift/code, etc./p\ndiv class=\"code\"pre class=\"code literal-block\"span class=\"k\"def/span span class=\"nf\"analyze/spanspan class=\"p\"(/spanspan class=\"n\"block/spanspan class=\"p\":/span span class=\"n\"Block/spanspan class=\"p\")/span span class=\"o\"-gt;/span span class=\"kc\"None/spanspan class=\"p\":/span\n    span class=\"n\"parity/span span class=\"o\"=/span span class=\"p\"{/spanspan class=\"n\"v/spanspan class=\"p\":/span span class=\"n\"BOTTOM/span span class=\"k\"for/span span class=\"n\"v/span span class=\"ow\"in/span span class=\"n\"block/spanspan class=\"p\"}/span\n\n    span class=\"k\"def/span span class=\"nf\"parity_of/spanspan class=\"p\"(/spanspan class=\"n\"value/spanspan class=\"p\"):/span\n        span class=\"k\"if/span span class=\"nb\"isinstance/spanspan class=\"p\"(/spanspan class=\"n\"value/spanspan class=\"p\",/span span class=\"n\"Constant/spanspan class=\"p\"):/span\n            span class=\"k\"return/span span class=\"n\"Parity/spanspan class=\"o\"./spanspan class=\"n\"const/spanspan class=\"p\"(/spanspan class=\"n\"value/spanspan class=\"p\")/span\n        span class=\"k\"return/span span class=\"n\"parity/spanspan class=\"p\"[/spanspan class=\"n\"value/spanspan class=\"p\"]/span\n\n    span class=\"k\"for/span span class=\"n\"op/span span class=\"ow\"in/span span class=\"n\"block/spanspan class=\"p\":/span\n        span class=\"n\"transfer/span span class=\"o\"=/span span class=\"nb\"getattr/spanspan class=\"p\"(/spanspan class=\"n\"Parity/spanspan class=\"p\",/span span class=\"n\"op/spanspan class=\"o\"./spanspan class=\"n\"name/spanspan class=\"p\")/span\n        span class=\"n\"args/span span class=\"o\"=/span span class=\"p\"[/spanspan class=\"n\"parity_of/spanspan class=\"p\"(/spanspan class=\"n\"arg/spanspan class=\"o\"./spanspan class=\"n\"find/spanspan class=\"p\"())/span span class=\"k\"for/span span class=\"n\"arg/span span class=\"ow\"in/span span class=\"n\"op/spanspan class=\"o\"./spanspan class=\"n\"args/spanspan class=\"p\"]/span\n        span class=\"n\"parity/spanspan class=\"p\"[/spanspan class=\"n\"op/spanspan class=\"p\"]/span span class=\"o\"=/span span class=\"n\"transfer/spanspan class=\"p\"(/spanspan class=\"o\"*/spanspan class=\"n\"args/spanspan class=\"p\")/span\n/pre/div\n\npFor every operation, we compute the abstract value---the parity---of the\narguments and then call the corresponding method on codeParity/code to get the\nabstract result./p\n!-- TODO maybe learn more about different IRs and how they do constants.\napparently pypy/llvm are free-floating; cinder is not --\npWe need to special case codeConstant/codes due to a quirk of how the Toy IR is\nconstructed: the constants don't appear in the instruction stream and instead\nare free-floating./p\npLet's start by looking at the abstraction function for concrete\nvalues---constants:/p\ndiv class=\"code\"pre class=\"code literal-block\"span class=\"k\"class/span span class=\"nc\"Parity/spanspan class=\"p\":/span\n    span class=\"c1\"# .../span\n    span class=\"nd\"@staticmethod/span\n    span class=\"k\"def/span span class=\"nf\"const/spanspan class=\"p\"(/spanspan class=\"n\"value/spanspan class=\"p\"):/span\n        span class=\"k\"if/span span class=\"n\"value/spanspan class=\"o\"./spanspan class=\"n\"value/span span class=\"o\"%/span span class=\"mi\"2/span span class=\"o\"==/span span class=\"mi\"0/spanspan class=\"p\":/span\n            span class=\"k\"return/span span class=\"n\"EVEN/span\n        span class=\"k\"else/spanspan class=\"p\":/span\n            span class=\"k\"return/span span class=\"n\"ODD/span\n/pre/div\n\npSeems reasonable enough. Let's pause on operations for a moment and consider an\nexample program:/p\ndiv class=\"code\"pre class=\"code literal-block\"span class=\"n\"v0/span span class=\"o\"=/span span class=\"n\"getarg/spanspan class=\"p\"(/spanspan class=\"mi\"0/spanspan class=\"p\")/span\nspan class=\"n\"v1/span span class=\"o\"=/span span class=\"n\"getarg/spanspan class=\"p\"(/spanspan class=\"mi\"1/spanspan class=\"p\")/span\nspan class=\"n\"v2/span span class=\"o\"=/span span class=\"n\"lshift/spanspan class=\"p\"(/spanspan class=\"n\"v0/spanspan class=\"p\",/span span class=\"mi\"1/spanspan class=\"p\")/span\nspan class=\"n\"v3/span span class=\"o\"=/span span class=\"n\"lshift/spanspan class=\"p\"(/spanspan class=\"n\"v1/spanspan class=\"p\",/span span class=\"mi\"1/spanspan class=\"p\")/span\nspan class=\"n\"v4/span span class=\"o\"=/span span class=\"n\"add/spanspan class=\"p\"(/spanspan class=\"n\"v2/spanspan class=\"p\",/span span class=\"n\"v3/spanspan class=\"p\")/span\nspan class=\"n\"v5/span span class=\"o\"=/span span class=\"n\"dummy/spanspan class=\"p\"(/spanspan class=\"n\"v4/spanspan class=\"p\")/span\n/pre/div\n\npThis function (which is admittedly a little contrived) takes two inputs, shifts\nthem left by one bit, adds the result, and then checks the least significant\nbit of the addition result. It then passes that result into a codedummy/code function,\nwhich you can think of as \"return\" or \"escape\"./p\npTo do some abstract interpretation on this program, we'll need to implement the\ntransfer functions for codelshift/code and codeadd/code (codedummy/code will just always return\ncodeTOP/code). We'll start with codeadd/code. Remember that adding two even numbers returns\nan even number, adding two odd numbers returns an even number, and mixing even\nand odd returns an odd number./p\ndiv class=\"code\"pre class=\"code literal-block\"span class=\"k\"class/span span class=\"nc\"Parity/spanspan class=\"p\":/span\n    span class=\"c1\"# .../span\n    span class=\"k\"def/span span class=\"nf\"add/spanspan class=\"p\"(/spanspan class=\"bp\"self/spanspan class=\"p\",/span span class=\"n\"other/spanspan class=\"p\"):/span\n        span class=\"k\"if/span span class=\"bp\"self/span span class=\"ow\"is/span span class=\"n\"BOTTOM/span span class=\"ow\"or/span span class=\"n\"other/span span class=\"ow\"is/span span class=\"n\"BOTTOM/spanspan class=\"p\":/span\n            span class=\"k\"return/span span class=\"n\"BOTTOM/span\n        span class=\"k\"if/span span class=\"bp\"self/span span class=\"ow\"is/span span class=\"n\"TOP/span span class=\"ow\"or/span span class=\"n\"other/span span class=\"ow\"is/span span class=\"n\"TOP/spanspan class=\"p\":/span\n            span class=\"k\"return/span span class=\"n\"TOP/span\n        span class=\"k\"if/span span class=\"bp\"self/span span class=\"ow\"is/span span class=\"n\"EVEN/span span class=\"ow\"and/span span class=\"n\"other/span span class=\"ow\"is/span span class=\"n\"EVEN/spanspan class=\"p\":/span\n            span class=\"k\"return/span span class=\"n\"EVEN/span\n        span class=\"k\"if/span span class=\"bp\"self/span span class=\"ow\"is/span span class=\"n\"ODD/span span class=\"ow\"and/span span class=\"n\"other/span span class=\"ow\"is/span span class=\"n\"ODD/spanspan class=\"p\":/span\n            span class=\"k\"return/span span class=\"n\"EVEN/span\n        span class=\"k\"return/span span class=\"n\"ODD/span\n/pre/div\n\npWe also need to fill in the other cases where the operands are emtop/em or\nembottom/em. In this case, they are both \"contagious\"; if either operand is\nbottom, the result is as well. If neither is bottom but either operand is top,\nthe result is as well./p\npNow let's look at codelshift/code. Shifting any number left by a non-zero number of\nbits will always result in an even number, but we need to be careful about the\nzero case! Shifting by zero doesn't change the number at all. Unfortunately,\nsince our lattice has no notion of zero, we have to over-approximate here:/p\ndiv class=\"code\"pre class=\"code literal-block\"span class=\"k\"class/span span class=\"nc\"Parity/spanspan class=\"p\":/span\n    span class=\"c1\"# .../span\n    span class=\"k\"def/span span class=\"nf\"lshift/spanspan class=\"p\"(/spanspan class=\"bp\"self/spanspan class=\"p\",/span span class=\"n\"other/spanspan class=\"p\"):/span\n        span class=\"c1\"# self lt;lt; other/span\n        span class=\"k\"if/span span class=\"n\"other/span span class=\"ow\"is/span span class=\"n\"ODD/spanspan class=\"p\":/span\n            span class=\"k\"return/span span class=\"n\"EVEN/span\n        span class=\"k\"return/span span class=\"n\"TOP/span\n/pre/div\n\npThis means that we will miss some opportunities to optimize, but it's a\ntradeoff that's just part of the game. (We could also add more elements to our\nlattice, but that's a topic for another day.)/p\npNow, if we run our abstract interpretation, we'll collect some interesting\nproperties about the program. If we temporarily hack on the internals of\ncodebb_to_str/code, we can print out parity information alongside the IR operations:/p\ndiv class=\"code\"pre class=\"code literal-block\"span class=\"n\"v0/spanspan class=\"p\":/spanspan class=\"n\"top/span span class=\"o\"=/span span class=\"n\"getarg/spanspan class=\"p\"(/spanspan class=\"mi\"0/spanspan class=\"p\")/span\nspan class=\"n\"v1/spanspan class=\"p\":/spanspan class=\"n\"top/span span class=\"o\"=/span span class=\"n\"getarg/spanspan class=\"p\"(/spanspan class=\"mi\"1/spanspan class=\"p\")/span\nspan class=\"n\"v2/spanspan class=\"p\":/spanspan class=\"n\"even/span span class=\"o\"=/span span class=\"n\"lshift/spanspan class=\"p\"(/spanspan class=\"n\"v0/spanspan class=\"p\",/span span class=\"mi\"1/spanspan class=\"p\")/span\nspan class=\"n\"v3/spanspan class=\"p\":/spanspan class=\"n\"even/span span class=\"o\"=/span span class=\"n\"lshift/spanspan class=\"p\"(/spanspan class=\"n\"v1/spanspan class=\"p\",/span span class=\"mi\"1/spanspan class=\"p\")/span\nspan class=\"n\"v4/spanspan class=\"p\":/spanspan class=\"n\"even/span span class=\"o\"=/span span class=\"n\"add/spanspan class=\"p\"(/spanspan class=\"n\"v2/spanspan class=\"p\",/span span class=\"n\"v3/spanspan class=\"p\")/span\nspan class=\"n\"v5/spanspan class=\"p\":/spanspan class=\"n\"top/span span class=\"o\"=/span span class=\"n\"dummy/spanspan class=\"p\"(/spanspan class=\"n\"v4/spanspan class=\"p\")/span\n/pre/div\n\npThis is pretty awesome, because we can see that codev4/code, the result of the\naddition, is emalways/em even. Maybe we can do something with that information./p\nh3 id=\"optimization\"Optimization/h3\npOne way that a program might check if a number is odd is by checking the least\nsignificant bit. This is a common pattern in C code, where you might see code\nlike codey = x amp; 1/code. Let's introduce a codebitand/code IR operation that acts like the\ncodeamp;/code operator in C/Python. Here is an example of use of it in our program:/p\ndiv class=\"code\"pre class=\"code literal-block\"span class=\"n\"v0/span span class=\"o\"=/span span class=\"n\"getarg/spanspan class=\"p\"(/spanspan class=\"mi\"0/spanspan class=\"p\")/span\nspan class=\"n\"v1/span span class=\"o\"=/span span class=\"n\"getarg/spanspan class=\"p\"(/spanspan class=\"mi\"1/spanspan class=\"p\")/span\nspan class=\"n\"v2/span span class=\"o\"=/span span class=\"n\"lshift/spanspan class=\"p\"(/spanspan class=\"n\"v0/spanspan class=\"p\",/span span class=\"mi\"1/spanspan class=\"p\")/span\nspan class=\"n\"v3/span span class=\"o\"=/span span class=\"n\"lshift/spanspan class=\"p\"(/spanspan class=\"n\"v1/spanspan class=\"p\",/span span class=\"mi\"1/spanspan class=\"p\")/span\nspan class=\"n\"v4/span span class=\"o\"=/span span class=\"n\"add/spanspan class=\"p\"(/spanspan class=\"n\"v2/spanspan class=\"p\",/span span class=\"n\"v3/spanspan class=\"p\")/span\nspan class=\"n\"v5/span span class=\"o\"=/span span class=\"n\"bitand/spanspan class=\"p\"(/spanspan class=\"n\"v4/spanspan class=\"p\",/span span class=\"mi\"1/spanspan class=\"p\")/span  span class=\"c1\"# new!/span\nspan class=\"n\"v6/span span class=\"o\"=/span span class=\"n\"dummy/spanspan class=\"p\"(/spanspan class=\"n\"v5/spanspan class=\"p\")/span\n/pre/div\n\npWe'll hold off on implementing the transfer function for it---that's left as an\nexercise for the reader---and instead do something different./p\npInstead, we'll see if we can optimize operations of the form codebitand(X, 1)/code. If\nwe statically know the parity as a result of abstract interpretation, we can\nreplace the codebitand/code with a constant code0/code or code1/code./p\npWe'll first modify the codeanalyze/code function (and rename it) to return a new\ncodeBlock/code containing optimized instructions:/p\ndiv class=\"code\"pre class=\"code literal-block\"span class=\"k\"def/span span class=\"nf\"simplify/spanspan class=\"p\"(/spanspan class=\"n\"block/spanspan class=\"p\":/span span class=\"n\"Block/spanspan class=\"p\")/span span class=\"o\"-gt;/span span class=\"n\"Block/spanspan class=\"p\":/span\n    span class=\"n\"parity/span span class=\"o\"=/span span class=\"p\"{/spanspan class=\"n\"v/spanspan class=\"p\":/span span class=\"n\"BOTTOM/span span class=\"k\"for/span span class=\"n\"v/span span class=\"ow\"in/span span class=\"n\"block/spanspan class=\"p\"}/span\n\n    span class=\"k\"def/span span class=\"nf\"parity_of/spanspan class=\"p\"(/spanspan class=\"n\"value/spanspan class=\"p\"):/span\n        span class=\"k\"if/span span class=\"nb\"isinstance/spanspan class=\"p\"(/spanspan class=\"n\"value/spanspan class=\"p\",/span span class=\"n\"Constant/spanspan class=\"p\"):/span\n            span class=\"k\"return/span span class=\"n\"Parity/spanspan class=\"o\"./spanspan class=\"n\"const/spanspan class=\"p\"(/spanspan class=\"n\"value/spanspan class=\"p\")/span\n        span class=\"k\"return/span span class=\"n\"parity/spanspan class=\"p\"[/spanspan class=\"n\"value/spanspan class=\"p\"]/span\n\n    span class=\"n\"result/span span class=\"o\"=/span span class=\"n\"Block/spanspan class=\"p\"()/span\n    span class=\"k\"for/span span class=\"n\"op/span span class=\"ow\"in/span span class=\"n\"block/spanspan class=\"p\":/span\n        span class=\"c1\"# TODO: Optimize op/span\n        span class=\"c1\"# Emit/span\n        span class=\"n\"result/spanspan class=\"o\"./spanspan class=\"n\"append/spanspan class=\"p\"(/spanspan class=\"n\"op/spanspan class=\"p\")/span\n        span class=\"c1\"# Analyze/span\n        span class=\"n\"transfer/span span class=\"o\"=/span span class=\"nb\"getattr/spanspan class=\"p\"(/spanspan class=\"n\"Parity/spanspan class=\"p\",/span span class=\"n\"op/spanspan class=\"o\"./spanspan class=\"n\"name/spanspan class=\"p\")/span\n        span class=\"n\"args/span span class=\"o\"=/span span class=\"p\"[/spanspan class=\"n\"parity_of/spanspan class=\"p\"(/spanspan class=\"n\"arg/spanspan class=\"o\"./spanspan class=\"n\"find/spanspan class=\"p\"())/span span class=\"k\"for/span span class=\"n\"arg/span span class=\"ow\"in/span span class=\"n\"op/spanspan class=\"o\"./spanspan class=\"n\"args/spanspan class=\"p\"]/span\n        span class=\"n\"parity/spanspan class=\"p\"[/spanspan class=\"n\"op/spanspan class=\"p\"]/span span class=\"o\"=/span span class=\"n\"transfer/spanspan class=\"p\"(/spanspan class=\"o\"*/spanspan class=\"n\"args/spanspan class=\"p\")/span\n    span class=\"k\"return/span span class=\"n\"result/span\n/pre/div\n\npWe're approaching this the way that PyPy does things under the hood, which is\nall in roughly a single pass. It tries to optimize an instruction away, and if\nit can't, it copies it into the new block./p\npNow let's add in the codebitand/code optimization. It's mostly some gross-looking\npattern matching that checks if the right hand side of a bitwise codeand/code\noperation is code1/code (TODO: the left hand side, too). CF had some neat ideas on how\nto make this more ergonomic, which I might save for later.sup id=\"fnref:match-args\"a class=\"footnote-ref\" href=\"https://www.pypy.org/posts/2024/07/toy-abstract-interpretation.html#fn:match-args\"3/a/sup/p\npThen, if we know the parity, optimize the codebitand/code into a constant./p\ndiv class=\"code\"pre class=\"code literal-block\"span class=\"k\"def/span span class=\"nf\"simplify/spanspan class=\"p\"(/spanspan class=\"n\"block/spanspan class=\"p\":/span span class=\"n\"Block/spanspan class=\"p\")/span span class=\"o\"-gt;/span span class=\"n\"Block/spanspan class=\"p\":/span\n    span class=\"n\"parity/span span class=\"o\"=/span span class=\"p\"{/spanspan class=\"n\"v/spanspan class=\"p\":/span span class=\"n\"BOTTOM/span span class=\"k\"for/span span class=\"n\"v/span span class=\"ow\"in/span span class=\"n\"block/spanspan class=\"p\"}/span\n\n    span class=\"k\"def/span span class=\"nf\"parity_of/spanspan class=\"p\"(/spanspan class=\"n\"value/spanspan class=\"p\"):/span\n        span class=\"k\"if/span span class=\"nb\"isinstance/spanspan class=\"p\"(/spanspan class=\"n\"value/spanspan class=\"p\",/span span class=\"n\"Constant/spanspan class=\"p\"):/span\n            span class=\"k\"return/span span class=\"n\"Parity/spanspan class=\"o\"./spanspan class=\"n\"const/spanspan class=\"p\"(/spanspan class=\"n\"value/spanspan class=\"p\")/span\n        span class=\"k\"return/span span class=\"n\"parity/spanspan class=\"p\"[/spanspan class=\"n\"value/spanspan class=\"p\"]/span\n\n    span class=\"n\"result/span span class=\"o\"=/span span class=\"n\"Block/spanspan class=\"p\"()/span\n    span class=\"k\"for/span span class=\"n\"op/span span class=\"ow\"in/span span class=\"n\"block/spanspan class=\"p\":/span\n        span class=\"c1\"# Try to simplify/span\n        span class=\"k\"if/span span class=\"nb\"isinstance/spanspan class=\"p\"(/spanspan class=\"n\"op/spanspan class=\"p\",/span span class=\"n\"Operation/spanspan class=\"p\")/span span class=\"ow\"and/span span class=\"n\"op/spanspan class=\"o\"./spanspan class=\"n\"name/span span class=\"o\"==/span span class=\"s2\"\"bitand\"/spanspan class=\"p\":/span\n            span class=\"n\"arg/span span class=\"o\"=/span span class=\"n\"op/spanspan class=\"o\"./spanspan class=\"n\"arg/spanspan class=\"p\"(/spanspan class=\"mi\"0/spanspan class=\"p\")/span\n            span class=\"n\"mask/span span class=\"o\"=/span span class=\"n\"op/spanspan class=\"o\"./spanspan class=\"n\"arg/spanspan class=\"p\"(/spanspan class=\"mi\"1/spanspan class=\"p\")/span\n            span class=\"k\"if/span span class=\"nb\"isinstance/spanspan class=\"p\"(/spanspan class=\"n\"mask/spanspan class=\"p\",/span span class=\"n\"Constant/spanspan class=\"p\")/span span class=\"ow\"and/span span class=\"n\"mask/spanspan class=\"o\"./spanspan class=\"n\"value/span span class=\"o\"==/span span class=\"mi\"1/spanspan class=\"p\":/span\n                span class=\"k\"if/span span class=\"n\"parity_of/spanspan class=\"p\"(/spanspan class=\"n\"arg/spanspan class=\"p\")/span span class=\"ow\"is/span span class=\"n\"EVEN/spanspan class=\"p\":/span\n                    span class=\"n\"op/spanspan class=\"o\"./spanspan class=\"n\"make_equal_to/spanspan class=\"p\"(/spanspan class=\"n\"Constant/spanspan class=\"p\"(/spanspan class=\"mi\"0/spanspan class=\"p\"))/span\n                    span class=\"k\"continue/span\n                span class=\"k\"elif/span span class=\"n\"parity_of/spanspan class=\"p\"(/spanspan class=\"n\"arg/spanspan class=\"p\")/span span class=\"ow\"is/span span class=\"n\"ODD/spanspan class=\"p\":/span\n                    span class=\"n\"op/spanspan class=\"o\"./spanspan class=\"n\"make_equal_to/spanspan class=\"p\"(/spanspan class=\"n\"Constant/spanspan class=\"p\"(/spanspan class=\"mi\"1/spanspan class=\"p\"))/span\n                    span class=\"k\"continue/span\n        span class=\"c1\"# Emit/span\n        span class=\"n\"result/spanspan class=\"o\"./spanspan class=\"n\"append/spanspan class=\"p\"(/spanspan class=\"n\"op/spanspan class=\"p\")/span\n        span class=\"c1\"# Analyze/span\n        span class=\"n\"transfer/span span class=\"o\"=/span span class=\"nb\"getattr/spanspan class=\"p\"(/spanspan class=\"n\"Parity/spanspan class=\"p\",/span span class=\"n\"op/spanspan class=\"o\"./spanspan class=\"n\"name/spanspan class=\"p\")/span\n        span class=\"n\"args/span span class=\"o\"=/span span class=\"p\"[/spanspan class=\"n\"parity_of/spanspan class=\"p\"(/spanspan class=\"n\"arg/spanspan class=\"o\"./spanspan class=\"n\"find/spanspan class=\"p\"())/span span class=\"k\"for/span span class=\"n\"arg/span span class=\"ow\"in/span span class=\"n\"op/spanspan class=\"o\"./spanspan class=\"n\"args/spanspan class=\"p\"]/span\n        span class=\"n\"parity/spanspan class=\"p\"[/spanspan class=\"n\"op/spanspan class=\"p\"]/span span class=\"o\"=/span span class=\"n\"transfer/spanspan class=\"p\"(/spanspan class=\"o\"*/spanspan class=\"n\"args/spanspan class=\"p\")/span\n    span class=\"k\"return/span span class=\"n\"result/span\n/pre/div\n\npRemember: because we use union-find to rewrite instructions in the optimizer\n(codemake_equal_to/code), later uses of the same instruction get the new\noptimized version \"for free\" (codefind/code)./p\npLet's see how it works on our IR:/p\ndiv class=\"code\"pre class=\"code literal-block\"span class=\"n\"v0/span span class=\"o\"=/span span class=\"n\"getarg/spanspan class=\"p\"(/spanspan class=\"mi\"0/spanspan class=\"p\")/span\nspan class=\"n\"v1/span span class=\"o\"=/span span class=\"n\"getarg/spanspan class=\"p\"(/spanspan class=\"mi\"1/spanspan class=\"p\")/span\nspan class=\"n\"v2/span span class=\"o\"=/span span class=\"n\"lshift/spanspan class=\"p\"(/spanspan class=\"n\"v0/spanspan class=\"p\",/span span class=\"mi\"1/spanspan class=\"p\")/span\nspan class=\"n\"v3/span span class=\"o\"=/span span class=\"n\"lshift/spanspan class=\"p\"(/spanspan class=\"n\"v1/spanspan class=\"p\",/span span class=\"mi\"1/spanspan class=\"p\")/span\nspan class=\"n\"v4/span span class=\"o\"=/span span class=\"n\"add/spanspan class=\"p\"(/spanspan class=\"n\"v2/spanspan class=\"p\",/span span class=\"n\"v3/spanspan class=\"p\")/span\nspan class=\"n\"v6/span span class=\"o\"=/span span class=\"n\"dummy/spanspan class=\"p\"(/spanspan class=\"mi\"0/spanspan class=\"p\")/span\n/pre/div\n\npHey, neat! codebitand/code disappeared and the argument to codedummy/code is now the constant\ncode0/code because we know the lowest bit./p\nh3 id=\"wrapping-up\"Wrapping up/h3\npHopefully you have gained a little bit of an intuitive understanding of\nabstract interpretation. Last year, being able to write some code made me more\ncomfortable with the math. Now being more comfortable with the math is helping\nme write the code. It's nice upward spiral./p\npThe two abstract domains we used in this post are simple and not very useful in\npractice but it's possible to get very far using slightly more complicated\nabstract domains. Common domains include: constant propagation, type inference,\nrange analysis, effect inference, liveness, etc. For example, here is a a\nsample lattice for constant propagation:/p\nfigure style=\"display: block; margin: 0 auto;\"\n!--\ndigraph G {\n    rankdir=\"BT\";\n    top [shape=Msquare];\n    bottom [shape=Msquare];\n\n    bottom - \"-inf\";\n    bottom - \"-2\";\n    bottom - \"-1\";\n    bottom - 0;\n    bottom - 1;\n    bottom - 2;\n    bottom - \"+inf\";\n\n    \"-inf\" - negative;\n    \"-2\" - negative;\n    \"-1\" - negative;\n    0 - top;\n    1 - nonnegative;\n    2 - nonnegative;\n    \"+inf\" - nonnegative;\n\n    negative - nonzero;\n    nonnegative - nonzero;\n    nonzero-top;\n\n    {rank=same; \"-inf\"; \"-2\"; \"-1\"; 0; 1; 2; \"+inf\"}\n    {rank=same; nonnegative; negative;}\n}\n--\n    object class=\"svg\" type=\"image/svg+xml\" data=\"https://www.pypy.org/images/2024-complex-lattice.svg\"\n    /object\n/figure\n\npIt has multiple levels to indicate more and less precision. For example, you\nmight learn that a variable is either code1/code or code2/code and be able to encode that as\ncodenonnegative/code instead of just going straight to codetop/code./p\npCheck out some real-world abstract interpretation in open source projects:/p\nul\nlia href=\"https://github.com/llvm/llvm-project/blob/main/llvm/lib/Support/KnownBits.cpp\"Known bits in LLVM/a/li\nlia href=\"https://github.com/llvm/llvm-project/blob/main/llvm/lib/IR/ConstantRange.cpp\"Constant range in LLVM/a/li\nliBut I am told that the ranges don't form a lattice (see a href=\"https://dl.acm.org/doi/10.1145/2651360\"Interval Analysis and Machine Arithmetic: Why Signedness Ignorance Is Bliss/a)/li\nlia href=\"https://github.com/torvalds/linux/blob/master/kernel/bpf/tnum.c\"Tristate numbers for known bits in Linux eBPF/a/li\nlia href=\"https://github.com/torvalds/linux/blob/28bbe4ea686a023929d907cc168430b61094811c/kernel/bpf/verifier.c#L13335\"Range analysis in Linux eBPF/a/li\nlia href=\"https://github.com/bminor/binutils-gdb/blob/master/gdb/prologue-value.c\"GDB prologue analysis/a\n  of assembly to understand the stack and find frame pointers without using\n  DWARF (a href=\"https://sourceware.org/gdb/wiki/Internals/Prologue%20Analysis\"some\n  docs/a)/li\n/ul\npIf you have some readable examples, please share them so I can add./p\nh3 id=\"acknowledgements\"Acknowledgements/h3\npThank you to a href=\"https://cfbolz.de/\"CF Bolz-Tereick/a for the toy optimizer and\nhelping edit this post!/p\ndiv class=\"footnote\"\nhr\nol\nli id=\"fn:logozzo\"\npIn the words of abstract interpretation researchers Vincent Laviron\nand Francesco Logozzo in their paper emRefining Abstract\nInterpretation-based Static Analyses with Hints/em (APLAS 2009):/p\nblockquote\npThe three main elements of an abstract interpretation are: (i) the\nabstract elements (\"which properties am I interested in?\"); (ii) the\nabstract transfer functions (\"which is the abstract semantics of basic\nstatements?\"); and (iii) the abstract operations (\"how do I combine the\nabstract elements?\")./p\n/blockquote\npWe don't have any of these \"abstract operations\" in this post because\nthere's no control flow but you can read about them elsewhere! a class=\"footnote-backref\" href=\"https://www.pypy.org/posts/2024/07/toy-abstract-interpretation.html#fnref:logozzo\" title=\"Jump back to footnote 1 in the text\"/a/p\n/li\nli id=\"fn:lattices\"\npThese abstract values are arranged in a emlattice/em, which is a\nmathematical structure with some properties but the most important ones are\nthat it has a top, a bottom, a partial order, a meet operation, and values\ncan only move in one direction on the lattice./p\npUsing abstract values from a lattice promises two things:/p\nul\nliThe analysis will terminate/li\nliThe analysis will be correct for emany/em run of the program, not just one\n  sample run/li\n/ul\npa class=\"footnote-backref\" href=\"https://www.pypy.org/posts/2024/07/toy-abstract-interpretation.html#fnref:lattices\" title=\"Jump back to footnote 2 in the text\"/a/p\n/li\nli id=\"fn:match-args\"\npSomething about code__match_args__/code and code@property/code... a class=\"footnote-backref\" href=\"https://www.pypy.org/posts/2024/07/toy-abstract-interpretation.html#fnref:match-args\" title=\"Jump back to footnote 3 in the text\"/a/p\n/li\n/ol\n/div"
        }
      ],
      "description": "pThis is a a href=\"https://bernsteinbear.com/blog/toy-abstract-interpretation/\" rel=\"canonical\"cross-post/a\nfrom Max Bernstein from his excellent blog where he writes about programming\nlanguages, compilers, optimizations, virtual machines. He's looking for a\n(dynamic language runtime or compiler related) job too./p\nhr\npCF Bolz-Tereick wrote some excellent posts in which they a href=\"https://pypy.org/posts/2022/07/toy-optimizer.html\"introduce a small IR\nand optimizer/a and a href=\"https://pypy.org/posts/2022/10/toy-optimizer-allocation-removal.html\"extend it with allocation\nremoval/a. We also did a live stream together in which\nwe did a href=\"https://www.youtube.com/watch?v=w-UHg0yOPSE\"some more heap optimizations/a./p\npIn this blog post, I'm going to write a small abstract interpreter for the Toy\nIR and then show how we can use it to do some simple optimizations. It assumes\nthat you are familiar with the little IR, which I have reproduced unchanged in\na href=\"https://gist.github.com/tekknolagi/4425b28d5267e7bae8b0d7ef8fb4a671\"a GitHub Gist/a./p\npAbstract interpretation is a general framework for efficiently computing\nproperties that must be true for all possible executions of a program. It's a\nwidely used approach both in compiler optimizations as well as offline static\nanalysis for finding bugs. I'm writing this post to pave the way for CF's next\npost on proving abstract interpreters correct for range analysis and known bits\nanalysis inside PyPy./p\npBefore we begin, I want to note a couple of things:/p\nul\nliThe Toy IR is in SSA form, which means that every variable is defined exactly\n  once. This means that abstract properties of each variable are easy to track./li\nliThe Toy IR represents a linear trace without control flow, meaning we won't\n  talk about meet/join or fixpoints. They only make sense if the IR has a\n  notion of conditional branches or back edges (loops)./li\n/ul\npAlright, let's get started./p\nh3 id=\"welcome-to-abstract-interpretation\"Welcome to abstract interpretation/h3\npAbstract interpretation means a couple different things to different people.\nThere's rigorous mathematical formalism thanks to Patrick and Radhia Cousot,\nour favorite power couple, and there's also sketchy hand-wavy stuff like what\nwill follow in this post. In the end, all people are trying to do is reason\nabout program behavior without running it./p\npIn particular, abstract interpretation is an emover-approximation/em of the\nbehavior of a program. Correctly implemented abstract interpreters never lie,\nbut they might be a little bit pessimistic. This is because instead of using\nreal values and running the program---which would produce a concrete result and\nsome real-world behavior---we \"run\" the program with a parallel universe of\nemabstract/em values. This abstract run gives us information about all possible\nruns of the program.sup id=\"fnref:logozzo\"a class=\"footnote-ref\" href=\"https://www.pypy.org/posts/2024/07/toy-abstract-interpretation.html#fn:logozzo\"1/a/sup/p\npAbstract values always represent sets of concrete values. Instead of literally\nstoring a set (in the world of integers, for example, it could get pretty\nbig...there are a lot of integers), we group them into a finite number of named\nsubsets.sup id=\"fnref:lattices\"a class=\"footnote-ref\" href=\"https://www.pypy.org/posts/2024/07/toy-abstract-interpretation.html#fn:lattices\"2/a/sup/p\npLet's learn a little about abstract interpretation with an example program and\nexample abstract domain. Here's the example program:/p\ndiv class=\"code\"pre class=\"code literal-block\"span class=\"n\"v0/span span class=\"o\"=/span span class=\"mi\"1/span\nspan class=\"n\"v1/span span class=\"o\"=/span span class=\"mi\"2/span\nspan class=\"n\"v2/span span class=\"o\"=/span span class=\"n\"add/spanspan class=\"p\"(/spanspan class=\"n\"v0/spanspan class=\"p\",/span span class=\"n\"v1/spanspan class=\"p\")/span\n/pre/div\n\npAnd our abstract domain is \"is the number positive\" (where \"positive\" means\nnonnegative, but I wanted to keep the words distinct):/p\ndiv class=\"code\"pre class=\"code literal-block\"       top\n    /       \\\npositive    negative\n    \\       /\n      bottom\n/pre/div\n\npThe special emtop/em value means \"I don't know\" and the special embottom/em value\nmeans \"empty set\" or \"unreachable\". The empositive/em and emnegative/em values\nrepresent the sets of all positive and negative numbers, respectively./p\npWe initialize all the variables codev0/code, codev1/code, and codev2/code to embottom/em and then walk\nour IR, updating our knowledge as we go./p\ndiv class=\"code\"pre class=\"code literal-block\"span class=\"c1\"# here/span\nspan class=\"n\"v0/spanspan class=\"p\":/spanspan class=\"n\"bottom/span span class=\"o\"=/span span class=\"mi\"1/span\nspan class=\"n\"v1/spanspan class=\"p\":/spanspan class=\"n\"bottom/span span class=\"o\"=/span span class=\"mi\"2/span\nspan class=\"n\"v2/spanspan class=\"p\":/spanspan class=\"n\"bottom/span span class=\"o\"=/span span class=\"n\"add/spanspan class=\"p\"(/spanspan class=\"n\"v0/spanspan class=\"p\",/span span class=\"n\"v1/spanspan class=\"p\")/span\n/pre/div\n\npIn order to do that, we have to have emtransfer functions/em for each operation.\nFor constants, the transfer function is easy: determine if the constant is\npositive or negative. For other operations, we have to define a function that\ntakes the abstract values of the operands and returns the abstract value of the\nresult./p\npIn order to be correct, transfer functions for operations have to be compatible\nwith the behavior of their corresponding concrete implementations. You can\nthink of them having an implicit universal quantifier emforall/em in front of\nthem./p\npLet's step through the constants at least:/p\ndiv class=\"code\"pre class=\"code literal-block\"span class=\"n\"v0/spanspan class=\"p\":/spanspan class=\"n\"positive/span span class=\"o\"=/span span class=\"mi\"1/span\nspan class=\"n\"v1/spanspan class=\"p\":/spanspan class=\"n\"positive/span span class=\"o\"=/span span class=\"mi\"2/span\nspan class=\"c1\"# here/span\nspan class=\"n\"v2/spanspan class=\"p\":/spanspan class=\"n\"bottom/span span class=\"o\"=/span span class=\"n\"add/spanspan class=\"p\"(/spanspan class=\"n\"v0/spanspan class=\"p\",/span span class=\"n\"v1/spanspan class=\"p\")/span\n/pre/div\n\npNow we need to figure out the transfer function for codeadd/code. It's kind of tricky\nright now because we haven't specified our abstract domain very well. I keep\nsaying \"numbers\", but what kinds of numbers? Integers? Real numbers? Floating\npoint? Some kind of fixed-width bit vector (codeint8/code, codeuint32/code, ...) like an\nactual machine \"integer\"?/p\npFor this post, I am going to use the mathematical definition of integer, which\nmeans that the values are not bounded in size and therefore do not overflow.\nActual hardware memory constraints aside, this is kind of like a Python codeint/code./p\npSo let's look at what happens when we add two abstract numbers:/p\ntable\nthead\ntr\nth/th\nthtop/th\nthpositive/th\nthnegative/th\nthbottom/th\n/tr\n/thead\ntbody\ntr\ntdstrongtop/strong/td\ntdtop/td\ntdtop/td\ntdtop/td\ntdbottom/td\n/tr\ntr\ntdstrongpositive/strong/td\ntdtop/td\ntdpositive/td\ntdtop/td\ntdbottom/td\n/tr\ntr\ntdstrongnegative/strong/td\ntdtop/td\ntdtop/td\ntdnegative/td\ntdbottom/td\n/tr\ntr\ntdstrongbottom/strong/td\ntdbottom/td\ntdbottom/td\ntdbottom/td\ntdbottom/td\n/tr\n/tbody\n/table\npAs an example, let's try to add two numbers codea/code and codeb/code, where codea/code is positive\nand codeb/code is negative. We don't know anything about their values other than their\nsigns. They could be code5/code and code-3/code, where the result is code2/code, or they could be\ncode1/code and code-100/code, where the result is code-99/code. This is why we can't say anything\nabout the result of this operation and have to return emtop/em./p\npThe short of this table is that we only really know the result of an addition\nif both operands are positive or both operands are negative. Thankfully, in\nthis example, both operands are known positive. So we can learn something about\ncodev2/code:/p\ndiv class=\"code\"pre class=\"code literal-block\"span class=\"n\"v0/spanspan class=\"p\":/spanspan class=\"n\"positive/span span class=\"o\"=/span span class=\"mi\"1/span\nspan class=\"n\"v1/spanspan class=\"p\":/spanspan class=\"n\"positive/span span class=\"o\"=/span span class=\"mi\"2/span\nspan class=\"n\"v2/spanspan class=\"p\":/spanspan class=\"n\"positive/span span class=\"o\"=/span span class=\"n\"add/spanspan class=\"p\"(/spanspan class=\"n\"v0/spanspan class=\"p\",/span span class=\"n\"v1/spanspan class=\"p\")/span\nspan class=\"c1\"# here/span\n/pre/div\n\npThis may not seem useful in isolation, but analyzing more complex programs even\nwith this simple domain may be able to remove checks such as codeif (v2 lt; 0) { ... }/code./p\npLet's take a look at another example using an sample codeabsval/code (absolute value)\nIR operation:/p\ndiv class=\"code\"pre class=\"code literal-block\"span class=\"n\"v0/span span class=\"o\"=/span span class=\"n\"getarg/spanspan class=\"p\"(/spanspan class=\"mi\"0/spanspan class=\"p\")/span\nspan class=\"n\"v1/span span class=\"o\"=/span span class=\"n\"getarg/spanspan class=\"p\"(/spanspan class=\"mi\"1/spanspan class=\"p\")/span\nspan class=\"n\"v2/span span class=\"o\"=/span span class=\"n\"absval/spanspan class=\"p\"(/spanspan class=\"n\"v0/spanspan class=\"p\")/span\nspan class=\"n\"v3/span span class=\"o\"=/span span class=\"n\"absval/spanspan class=\"p\"(/spanspan class=\"n\"v1/spanspan class=\"p\")/span\nspan class=\"n\"v4/span span class=\"o\"=/span span class=\"n\"add/spanspan class=\"p\"(/spanspan class=\"n\"v2/spanspan class=\"p\",/span span class=\"n\"v3/spanspan class=\"p\")/span\nspan class=\"n\"v5/span span class=\"o\"=/span span class=\"n\"absval/spanspan class=\"p\"(/spanspan class=\"n\"v4/spanspan class=\"p\")/span\n/pre/div\n\npEven though we have no constant/concrete values, we can still learn something\nabout the states of values throughout the program. Since we know that codeabsval/code\nalways returns a positive number, we learn that codev2/code, codev3/code, and codev4/code are all\npositive. This means that we can optimize out the codeabsval/code operation on codev5/code:/p\ndiv class=\"code\"pre class=\"code literal-block\"span class=\"n\"v0/spanspan class=\"p\":/spanspan class=\"n\"top/span span class=\"o\"=/span span class=\"n\"getarg/spanspan class=\"p\"(/spanspan class=\"mi\"0/spanspan class=\"p\")/span\nspan class=\"n\"v1/spanspan class=\"p\":/spanspan class=\"n\"top/span span class=\"o\"=/span span class=\"n\"getarg/spanspan class=\"p\"(/spanspan class=\"mi\"1/spanspan class=\"p\")/span\nspan class=\"n\"v2/spanspan class=\"p\":/spanspan class=\"n\"positive/span span class=\"o\"=/span span class=\"n\"absval/spanspan class=\"p\"(/spanspan class=\"n\"v0/spanspan class=\"p\")/span\nspan class=\"n\"v3/spanspan class=\"p\":/spanspan class=\"n\"positive/span span class=\"o\"=/span span class=\"n\"absval/spanspan class=\"p\"(/spanspan class=\"n\"v1/spanspan class=\"p\")/span\nspan class=\"n\"v4/spanspan class=\"p\":/spanspan class=\"n\"positive/span span class=\"o\"=/span span class=\"n\"add/spanspan class=\"p\"(/spanspan class=\"n\"v2/spanspan class=\"p\",/span span class=\"n\"v3/spanspan class=\"p\")/span\nspan class=\"n\"v5/spanspan class=\"p\":/spanspan class=\"n\"positive/span span class=\"o\"=/span span class=\"n\"v4/span\n/pre/div\n\npOther interesting lattices include:/p\nul\nliConstants (where the middle row is pretty wide)/li\nliRange analysis (bounds on min and max of a number)/li\nliKnown bits (using a bitvector representation of a number, which bits are\n  always 0 or 1)/li\n/ul\npFor the rest of this blog post, we are going to do a very limited version of\n\"known bits\", called emparity/em. This analysis only tracks the least significant\nbit of a number, which indicates if it is even or odd./p\nh3 id=\"parity\"Parity/h3\npThe lattice is pretty similar to the positive/negative lattice:/p\ndiv class=\"code\"pre class=\"code literal-block\"    top\n  /     \\\neven    odd\n  \\     /\n   bottom\n/pre/div\n\npLet's define a data structure to represent this in Python code:/p\ndiv class=\"code\"pre class=\"code literal-block\"span class=\"k\"class/span span class=\"nc\"Parity/spanspan class=\"p\":/span\n    span class=\"k\"def/span span class=\"fm\"__init__/spanspan class=\"p\"(/spanspan class=\"bp\"self/spanspan class=\"p\",/span span class=\"n\"name/spanspan class=\"p\"):/span\n        span class=\"bp\"self/spanspan class=\"o\"./spanspan class=\"n\"name/span span class=\"o\"=/span span class=\"n\"name/span\n\n    span class=\"k\"def/span span class=\"fm\"__repr__/spanspan class=\"p\"(/spanspan class=\"bp\"self/spanspan class=\"p\"):/span\n        span class=\"k\"return/span span class=\"bp\"self/spanspan class=\"o\"./spanspan class=\"n\"name/span\n/pre/div\n\npAnd instantiate the members of the lattice:/p\ndiv class=\"code\"pre class=\"code literal-block\"span class=\"n\"TOP/span span class=\"o\"=/span span class=\"n\"Parity/spanspan class=\"p\"(/spanspan class=\"s2\"\"top\"/spanspan class=\"p\")/span\nspan class=\"n\"EVEN/span span class=\"o\"=/span span class=\"n\"Parity/spanspan class=\"p\"(/spanspan class=\"s2\"\"even\"/spanspan class=\"p\")/span\nspan class=\"n\"ODD/span span class=\"o\"=/span span class=\"n\"Parity/spanspan class=\"p\"(/spanspan class=\"s2\"\"odd\"/spanspan class=\"p\")/span\nspan class=\"n\"BOTTOM/span span class=\"o\"=/span span class=\"n\"Parity/spanspan class=\"p\"(/spanspan class=\"s2\"\"bottom\"/spanspan class=\"p\")/span\n/pre/div\n\npNow let's write a forward flow analysis of a basic block using this lattice.\nWe'll do that by assuming that a method on codeParity/code is defined for each IR\noperation. For example, codeParity.add/code, codeParity.lshift/code, etc./p\ndiv class=\"code\"pre class=\"code literal-block\"span class=\"k\"def/span span class=\"nf\"analyze/spanspan class=\"p\"(/spanspan class=\"n\"block/spanspan class=\"p\":/span span class=\"n\"Block/spanspan class=\"p\")/span span class=\"o\"-gt;/span span class=\"kc\"None/spanspan class=\"p\":/span\n    span class=\"n\"parity/span span class=\"o\"=/span span class=\"p\"{/spanspan class=\"n\"v/spanspan class=\"p\":/span span class=\"n\"BOTTOM/span span class=\"k\"for/span span class=\"n\"v/span span class=\"ow\"in/span span class=\"n\"block/spanspan class=\"p\"}/span\n\n    span class=\"k\"def/span span class=\"nf\"parity_of/spanspan class=\"p\"(/spanspan class=\"n\"value/spanspan class=\"p\"):/span\n        span class=\"k\"if/span span class=\"nb\"isinstance/spanspan class=\"p\"(/spanspan class=\"n\"value/spanspan class=\"p\",/span span class=\"n\"Constant/spanspan class=\"p\"):/span\n            span class=\"k\"return/span span class=\"n\"Parity/spanspan class=\"o\"./spanspan class=\"n\"const/spanspan class=\"p\"(/spanspan class=\"n\"value/spanspan class=\"p\")/span\n        span class=\"k\"return/span span class=\"n\"parity/spanspan class=\"p\"[/spanspan class=\"n\"value/spanspan class=\"p\"]/span\n\n    span class=\"k\"for/span span class=\"n\"op/span span class=\"ow\"in/span span class=\"n\"block/spanspan class=\"p\":/span\n        span class=\"n\"transfer/span span class=\"o\"=/span span class=\"nb\"getattr/spanspan class=\"p\"(/spanspan class=\"n\"Parity/spanspan class=\"p\",/span span class=\"n\"op/spanspan class=\"o\"./spanspan class=\"n\"name/spanspan class=\"p\")/span\n        span class=\"n\"args/span span class=\"o\"=/span span class=\"p\"[/spanspan class=\"n\"parity_of/spanspan class=\"p\"(/spanspan class=\"n\"arg/spanspan class=\"o\"./spanspan class=\"n\"find/spanspan class=\"p\"())/span span class=\"k\"for/span span class=\"n\"arg/span span class=\"ow\"in/span span class=\"n\"op/spanspan class=\"o\"./spanspan class=\"n\"args/spanspan class=\"p\"]/span\n        span class=\"n\"parity/spanspan class=\"p\"[/spanspan class=\"n\"op/spanspan class=\"p\"]/span span class=\"o\"=/span span class=\"n\"transfer/spanspan class=\"p\"(/spanspan class=\"o\"*/spanspan class=\"n\"args/spanspan class=\"p\")/span\n/pre/div\n\npFor every operation, we compute the abstract value---the parity---of the\narguments and then call the corresponding method on codeParity/code to get the\nabstract result./p\n!-- TODO maybe learn more about different IRs and how they do constants.\napparently pypy/llvm are free-floating; cinder is not --\npWe need to special case codeConstant/codes due to a quirk of how the Toy IR is\nconstructed: the constants don't appear in the instruction stream and instead\nare free-floating./p\npLet's start by looking at the abstraction function for concrete\nvalues---constants:/p\ndiv class=\"code\"pre class=\"code literal-block\"span class=\"k\"class/span span class=\"nc\"Parity/spanspan class=\"p\":/span\n    span class=\"c1\"# .../span\n    span class=\"nd\"@staticmethod/span\n    span class=\"k\"def/span span class=\"nf\"const/spanspan class=\"p\"(/spanspan class=\"n\"value/spanspan class=\"p\"):/span\n        span class=\"k\"if/span span class=\"n\"value/spanspan class=\"o\"./spanspan class=\"n\"value/span span class=\"o\"%/span span class=\"mi\"2/span span class=\"o\"==/span span class=\"mi\"0/spanspan class=\"p\":/span\n            span class=\"k\"return/span span class=\"n\"EVEN/span\n        span class=\"k\"else/spanspan class=\"p\":/span\n            span class=\"k\"return/span span class=\"n\"ODD/span\n/pre/div\n\npSeems reasonable enough. Let's pause on operations for a moment and consider an\nexample program:/p\ndiv class=\"code\"pre class=\"code literal-block\"span class=\"n\"v0/span span class=\"o\"=/span span class=\"n\"getarg/spanspan class=\"p\"(/spanspan class=\"mi\"0/spanspan class=\"p\")/span\nspan class=\"n\"v1/span span class=\"o\"=/span span class=\"n\"getarg/spanspan class=\"p\"(/spanspan class=\"mi\"1/spanspan class=\"p\")/span\nspan class=\"n\"v2/span span class=\"o\"=/span span class=\"n\"lshift/spanspan class=\"p\"(/spanspan class=\"n\"v0/spanspan class=\"p\",/span span class=\"mi\"1/spanspan class=\"p\")/span\nspan class=\"n\"v3/span span class=\"o\"=/span span class=\"n\"lshift/spanspan class=\"p\"(/spanspan class=\"n\"v1/spanspan class=\"p\",/span span class=\"mi\"1/spanspan class=\"p\")/span\nspan class=\"n\"v4/span span class=\"o\"=/span span class=\"n\"add/spanspan class=\"p\"(/spanspan class=\"n\"v2/spanspan class=\"p\",/span span class=\"n\"v3/spanspan class=\"p\")/span\nspan class=\"n\"v5/span span class=\"o\"=/span span class=\"n\"dummy/spanspan class=\"p\"(/spanspan class=\"n\"v4/spanspan class=\"p\")/span\n/pre/div\n\npThis function (which is admittedly a little contrived) takes two inputs, shifts\nthem left by one bit, adds the result, and then checks the least significant\nbit of the addition result. It then passes that result into a codedummy/code function,\nwhich you can think of as \"return\" or \"escape\"./p\npTo do some abstract interpretation on this program, we'll need to implement the\ntransfer functions for codelshift/code and codeadd/code (codedummy/code will just always return\ncodeTOP/code). We'll start with codeadd/code. Remember that adding two even numbers returns\nan even number, adding two odd numbers returns an even number, and mixing even\nand odd returns an odd number./p\ndiv class=\"code\"pre class=\"code literal-block\"span class=\"k\"class/span span class=\"nc\"Parity/spanspan class=\"p\":/span\n    span class=\"c1\"# .../span\n    span class=\"k\"def/span span class=\"nf\"add/spanspan class=\"p\"(/spanspan class=\"bp\"self/spanspan class=\"p\",/span span class=\"n\"other/spanspan class=\"p\"):/span\n        span class=\"k\"if/span span class=\"bp\"self/span span class=\"ow\"is/span span class=\"n\"BOTTOM/span span class=\"ow\"or/span span class=\"n\"other/span span class=\"ow\"is/span span class=\"n\"BOTTOM/spanspan class=\"p\":/span\n            span class=\"k\"return/span span class=\"n\"BOTTOM/span\n        span class=\"k\"if/span span class=\"bp\"self/span span class=\"ow\"is/span span class=\"n\"TOP/span span class=\"ow\"or/span span class=\"n\"other/span span class=\"ow\"is/span span class=\"n\"TOP/spanspan class=\"p\":/span\n            span class=\"k\"return/span span class=\"n\"TOP/span\n        span class=\"k\"if/span span class=\"bp\"self/span span class=\"ow\"is/span span class=\"n\"EVEN/span span class=\"ow\"and/span span class=\"n\"other/span span class=\"ow\"is/span span class=\"n\"EVEN/spanspan class=\"p\":/span\n            span class=\"k\"return/span span class=\"n\"EVEN/span\n        span class=\"k\"if/span span class=\"bp\"self/span span class=\"ow\"is/span span class=\"n\"ODD/span span class=\"ow\"and/span span class=\"n\"other/span span class=\"ow\"is/span span class=\"n\"ODD/spanspan class=\"p\":/span\n            span class=\"k\"return/span span class=\"n\"EVEN/span\n        span class=\"k\"return/span span class=\"n\"ODD/span\n/pre/div\n\npWe also need to fill in the other cases where the operands are emtop/em or\nembottom/em. In this case, they are both \"contagious\"; if either operand is\nbottom, the result is as well. If neither is bottom but either operand is top,\nthe result is as well./p\npNow let's look at codelshift/code. Shifting any number left by a non-zero number of\nbits will always result in an even number, but we need to be careful about the\nzero case! Shifting by zero doesn't change the number at all. Unfortunately,\nsince our lattice has no notion of zero, we have to over-approximate here:/p\ndiv class=\"code\"pre class=\"code literal-block\"span class=\"k\"class/span span class=\"nc\"Parity/spanspan class=\"p\":/span\n    span class=\"c1\"# .../span\n    span class=\"k\"def/span span class=\"nf\"lshift/spanspan class=\"p\"(/spanspan class=\"bp\"self/spanspan class=\"p\",/span span class=\"n\"other/spanspan class=\"p\"):/span\n        span class=\"c1\"# self lt;lt; other/span\n        span class=\"k\"if/span span class=\"n\"other/span span class=\"ow\"is/span span class=\"n\"ODD/spanspan class=\"p\":/span\n            span class=\"k\"return/span span class=\"n\"EVEN/span\n        span class=\"k\"return/span span class=\"n\"TOP/span\n/pre/div\n\npThis means that we will miss some opportunities to optimize, but it's a\ntradeoff that's just part of the game. (We could also add more elements to our\nlattice, but that's a topic for another day.)/p\npNow, if we run our abstract interpretation, we'll collect some interesting\nproperties about the program. If we temporarily hack on the internals of\ncodebb_to_str/code, we can print out parity information alongside the IR operations:/p\ndiv class=\"code\"pre class=\"code literal-block\"span class=\"n\"v0/spanspan class=\"p\":/spanspan class=\"n\"top/span span class=\"o\"=/span span class=\"n\"getarg/spanspan class=\"p\"(/spanspan class=\"mi\"0/spanspan class=\"p\")/span\nspan class=\"n\"v1/spanspan class=\"p\":/spanspan class=\"n\"top/span span class=\"o\"=/span span class=\"n\"getarg/spanspan class=\"p\"(/spanspan class=\"mi\"1/spanspan class=\"p\")/span\nspan class=\"n\"v2/spanspan class=\"p\":/spanspan class=\"n\"even/span span class=\"o\"=/span span class=\"n\"lshift/spanspan class=\"p\"(/spanspan class=\"n\"v0/spanspan class=\"p\",/span span class=\"mi\"1/spanspan class=\"p\")/span\nspan class=\"n\"v3/spanspan class=\"p\":/spanspan class=\"n\"even/span span class=\"o\"=/span span class=\"n\"lshift/spanspan class=\"p\"(/spanspan class=\"n\"v1/spanspan class=\"p\",/span span class=\"mi\"1/spanspan class=\"p\")/span\nspan class=\"n\"v4/spanspan class=\"p\":/spanspan class=\"n\"even/span span class=\"o\"=/span span class=\"n\"add/spanspan class=\"p\"(/spanspan class=\"n\"v2/spanspan class=\"p\",/span span class=\"n\"v3/spanspan class=\"p\")/span\nspan class=\"n\"v5/spanspan class=\"p\":/spanspan class=\"n\"top/span span class=\"o\"=/span span class=\"n\"dummy/spanspan class=\"p\"(/spanspan class=\"n\"v4/spanspan class=\"p\")/span\n/pre/div\n\npThis is pretty awesome, because we can see that codev4/code, the result of the\naddition, is emalways/em even. Maybe we can do something with that information./p\nh3 id=\"optimization\"Optimization/h3\npOne way that a program might check if a number is odd is by checking the least\nsignificant bit. This is a common pattern in C code, where you might see code\nlike codey = x amp; 1/code. Let's introduce a codebitand/code IR operation that acts like the\ncodeamp;/code operator in C/Python. Here is an example of use of it in our program:/p\ndiv class=\"code\"pre class=\"code literal-block\"span class=\"n\"v0/span span class=\"o\"=/span span class=\"n\"getarg/spanspan class=\"p\"(/spanspan class=\"mi\"0/spanspan class=\"p\")/span\nspan class=\"n\"v1/span span class=\"o\"=/span span class=\"n\"getarg/spanspan class=\"p\"(/spanspan class=\"mi\"1/spanspan class=\"p\")/span\nspan class=\"n\"v2/span span class=\"o\"=/span span class=\"n\"lshift/spanspan class=\"p\"(/spanspan class=\"n\"v0/spanspan class=\"p\",/span span class=\"mi\"1/spanspan class=\"p\")/span\nspan class=\"n\"v3/span span class=\"o\"=/span span class=\"n\"lshift/spanspan class=\"p\"(/spanspan class=\"n\"v1/spanspan class=\"p\",/span span class=\"mi\"1/spanspan class=\"p\")/span\nspan class=\"n\"v4/span span class=\"o\"=/span span class=\"n\"add/spanspan class=\"p\"(/spanspan class=\"n\"v2/spanspan class=\"p\",/span span class=\"n\"v3/spanspan class=\"p\")/span\nspan class=\"n\"v5/span span class=\"o\"=/span span class=\"n\"bitand/spanspan class=\"p\"(/spanspan class=\"n\"v4/spanspan class=\"p\",/span span class=\"mi\"1/spanspan class=\"p\")/span  span class=\"c1\"# new!/span\nspan class=\"n\"v6/span span class=\"o\"=/span span class=\"n\"dummy/spanspan class=\"p\"(/spanspan class=\"n\"v5/spanspan class=\"p\")/span\n/pre/div\n\npWe'll hold off on implementing the transfer function for it---that's left as an\nexercise for the reader---and instead do something different./p\npInstead, we'll see if we can optimize operations of the form codebitand(X, 1)/code. If\nwe statically know the parity as a result of abstract interpretation, we can\nreplace the codebitand/code with a constant code0/code or code1/code./p\npWe'll first modify the codeanalyze/code function (and rename it) to return a new\ncodeBlock/code containing optimized instructions:/p\ndiv class=\"code\"pre class=\"code literal-block\"span class=\"k\"def/span span class=\"nf\"simplify/spanspan class=\"p\"(/spanspan class=\"n\"block/spanspan class=\"p\":/span span class=\"n\"Block/spanspan class=\"p\")/span span class=\"o\"-gt;/span span class=\"n\"Block/spanspan class=\"p\":/span\n    span class=\"n\"parity/span span class=\"o\"=/span span class=\"p\"{/spanspan class=\"n\"v/spanspan class=\"p\":/span span class=\"n\"BOTTOM/span span class=\"k\"for/span span class=\"n\"v/span span class=\"ow\"in/span span class=\"n\"block/spanspan class=\"p\"}/span\n\n    span class=\"k\"def/span span class=\"nf\"parity_of/spanspan class=\"p\"(/spanspan class=\"n\"value/spanspan class=\"p\"):/span\n        span class=\"k\"if/span span class=\"nb\"isinstance/spanspan class=\"p\"(/spanspan class=\"n\"value/spanspan class=\"p\",/span span class=\"n\"Constant/spanspan class=\"p\"):/span\n            span class=\"k\"return/span span class=\"n\"Parity/spanspan class=\"o\"./spanspan class=\"n\"const/spanspan class=\"p\"(/spanspan class=\"n\"value/spanspan class=\"p\")/span\n        span class=\"k\"return/span span class=\"n\"parity/spanspan class=\"p\"[/spanspan class=\"n\"value/spanspan class=\"p\"]/span\n\n    span class=\"n\"result/span span class=\"o\"=/span span class=\"n\"Block/spanspan class=\"p\"()/span\n    span class=\"k\"for/span span class=\"n\"op/span span class=\"ow\"in/span span class=\"n\"block/spanspan class=\"p\":/span\n        span class=\"c1\"# TODO: Optimize op/span\n        span class=\"c1\"# Emit/span\n        span class=\"n\"result/spanspan class=\"o\"./spanspan class=\"n\"append/spanspan class=\"p\"(/spanspan class=\"n\"op/spanspan class=\"p\")/span\n        span class=\"c1\"# Analyze/span\n        span class=\"n\"transfer/span span class=\"o\"=/span span class=\"nb\"getattr/spanspan class=\"p\"(/spanspan class=\"n\"Parity/spanspan class=\"p\",/span span class=\"n\"op/spanspan class=\"o\"./spanspan class=\"n\"name/spanspan class=\"p\")/span\n        span class=\"n\"args/span span class=\"o\"=/span span class=\"p\"[/spanspan class=\"n\"parity_of/spanspan class=\"p\"(/spanspan class=\"n\"arg/spanspan class=\"o\"./spanspan class=\"n\"find/spanspan class=\"p\"())/span span class=\"k\"for/span span class=\"n\"arg/span span class=\"ow\"in/span span class=\"n\"op/spanspan class=\"o\"./spanspan class=\"n\"args/spanspan class=\"p\"]/span\n        span class=\"n\"parity/spanspan class=\"p\"[/spanspan class=\"n\"op/spanspan class=\"p\"]/span span class=\"o\"=/span span class=\"n\"transfer/spanspan class=\"p\"(/spanspan class=\"o\"*/spanspan class=\"n\"args/spanspan class=\"p\")/span\n    span class=\"k\"return/span span class=\"n\"result/span\n/pre/div\n\npWe're approaching this the way that PyPy does things under the hood, which is\nall in roughly a single pass. It tries to optimize an instruction away, and if\nit can't, it copies it into the new block./p\npNow let's add in the codebitand/code optimization. It's mostly some gross-looking\npattern matching that checks if the right hand side of a bitwise codeand/code\noperation is code1/code (TODO: the left hand side, too). CF had some neat ideas on how\nto make this more ergonomic, which I might save for later.sup id=\"fnref:match-args\"a class=\"footnote-ref\" href=\"https://www.pypy.org/posts/2024/07/toy-abstract-interpretation.html#fn:match-args\"3/a/sup/p\npThen, if we know the parity, optimize the codebitand/code into a constant./p\ndiv class=\"code\"pre class=\"code literal-block\"span class=\"k\"def/span span class=\"nf\"simplify/spanspan class=\"p\"(/spanspan class=\"n\"block/spanspan class=\"p\":/span span class=\"n\"Block/spanspan class=\"p\")/span span class=\"o\"-gt;/span span class=\"n\"Block/spanspan class=\"p\":/span\n    span class=\"n\"parity/span span class=\"o\"=/span span class=\"p\"{/spanspan class=\"n\"v/spanspan class=\"p\":/span span class=\"n\"BOTTOM/span span class=\"k\"for/span span class=\"n\"v/span span class=\"ow\"in/span span class=\"n\"block/spanspan class=\"p\"}/span\n\n    span class=\"k\"def/span span class=\"nf\"parity_of/spanspan class=\"p\"(/spanspan class=\"n\"value/spanspan class=\"p\"):/span\n        span class=\"k\"if/span span class=\"nb\"isinstance/spanspan class=\"p\"(/spanspan class=\"n\"value/spanspan class=\"p\",/span span class=\"n\"Constant/spanspan class=\"p\"):/span\n            span class=\"k\"return/span span class=\"n\"Parity/spanspan class=\"o\"./spanspan class=\"n\"const/spanspan class=\"p\"(/spanspan class=\"n\"value/spanspan class=\"p\")/span\n        span class=\"k\"return/span span class=\"n\"parity/spanspan class=\"p\"[/spanspan class=\"n\"value/spanspan class=\"p\"]/span\n\n    span class=\"n\"result/span span class=\"o\"=/span span class=\"n\"Block/spanspan class=\"p\"()/span\n    span class=\"k\"for/span span class=\"n\"op/span span class=\"ow\"in/span span class=\"n\"block/spanspan class=\"p\":/span\n        span class=\"c1\"# Try to simplify/span\n        span class=\"k\"if/span span class=\"nb\"isinstance/spanspan class=\"p\"(/spanspan class=\"n\"op/spanspan class=\"p\",/span span class=\"n\"Operation/spanspan class=\"p\")/span span class=\"ow\"and/span span class=\"n\"op/spanspan class=\"o\"./spanspan class=\"n\"name/span span class=\"o\"==/span span class=\"s2\"\"bitand\"/spanspan class=\"p\":/span\n            span class=\"n\"arg/span span class=\"o\"=/span span class=\"n\"op/spanspan class=\"o\"./spanspan class=\"n\"arg/spanspan class=\"p\"(/spanspan class=\"mi\"0/spanspan class=\"p\")/span\n            span class=\"n\"mask/span span class=\"o\"=/span span class=\"n\"op/spanspan class=\"o\"./spanspan class=\"n\"arg/spanspan class=\"p\"(/spanspan class=\"mi\"1/spanspan class=\"p\")/span\n            span class=\"k\"if/span span class=\"nb\"isinstance/spanspan class=\"p\"(/spanspan class=\"n\"mask/spanspan class=\"p\",/span span class=\"n\"Constant/spanspan class=\"p\")/span span class=\"ow\"and/span span class=\"n\"mask/spanspan class=\"o\"./spanspan class=\"n\"value/span span class=\"o\"==/span span class=\"mi\"1/spanspan class=\"p\":/span\n                span class=\"k\"if/span span class=\"n\"parity_of/spanspan class=\"p\"(/spanspan class=\"n\"arg/spanspan class=\"p\")/span span class=\"ow\"is/span span class=\"n\"EVEN/spanspan class=\"p\":/span\n                    span class=\"n\"op/spanspan class=\"o\"./spanspan class=\"n\"make_equal_to/spanspan class=\"p\"(/spanspan class=\"n\"Constant/spanspan class=\"p\"(/spanspan class=\"mi\"0/spanspan class=\"p\"))/span\n                    span class=\"k\"continue/span\n                span class=\"k\"elif/span span class=\"n\"parity_of/spanspan class=\"p\"(/spanspan class=\"n\"arg/spanspan class=\"p\")/span span class=\"ow\"is/span span class=\"n\"ODD/spanspan class=\"p\":/span\n                    span class=\"n\"op/spanspan class=\"o\"./spanspan class=\"n\"make_equal_to/spanspan class=\"p\"(/spanspan class=\"n\"Constant/spanspan class=\"p\"(/spanspan class=\"mi\"1/spanspan class=\"p\"))/span\n                    span class=\"k\"continue/span\n        span class=\"c1\"# Emit/span\n        span class=\"n\"result/spanspan class=\"o\"./spanspan class=\"n\"append/spanspan class=\"p\"(/spanspan class=\"n\"op/spanspan class=\"p\")/span\n        span class=\"c1\"# Analyze/span\n        span class=\"n\"transfer/span span class=\"o\"=/span span class=\"nb\"getattr/spanspan class=\"p\"(/spanspan class=\"n\"Parity/spanspan class=\"p\",/span span class=\"n\"op/spanspan class=\"o\"./spanspan class=\"n\"name/spanspan class=\"p\")/span\n        span class=\"n\"args/span span class=\"o\"=/span span class=\"p\"[/spanspan class=\"n\"parity_of/spanspan class=\"p\"(/spanspan class=\"n\"arg/spanspan class=\"o\"./spanspan class=\"n\"find/spanspan class=\"p\"())/span span class=\"k\"for/span span class=\"n\"arg/span span class=\"ow\"in/span span class=\"n\"op/spanspan class=\"o\"./spanspan class=\"n\"args/spanspan class=\"p\"]/span\n        span class=\"n\"parity/spanspan class=\"p\"[/spanspan class=\"n\"op/spanspan class=\"p\"]/span span class=\"o\"=/span span class=\"n\"transfer/spanspan class=\"p\"(/spanspan class=\"o\"*/spanspan class=\"n\"args/spanspan class=\"p\")/span\n    span class=\"k\"return/span span class=\"n\"result/span\n/pre/div\n\npRemember: because we use union-find to rewrite instructions in the optimizer\n(codemake_equal_to/code), later uses of the same instruction get the new\noptimized version \"for free\" (codefind/code)./p\npLet's see how it works on our IR:/p\ndiv class=\"code\"pre class=\"code literal-block\"span class=\"n\"v0/span span class=\"o\"=/span span class=\"n\"getarg/spanspan class=\"p\"(/spanspan class=\"mi\"0/spanspan class=\"p\")/span\nspan class=\"n\"v1/span span class=\"o\"=/span span class=\"n\"getarg/spanspan class=\"p\"(/spanspan class=\"mi\"1/spanspan class=\"p\")/span\nspan class=\"n\"v2/span span class=\"o\"=/span span class=\"n\"lshift/spanspan class=\"p\"(/spanspan class=\"n\"v0/spanspan class=\"p\",/span span class=\"mi\"1/spanspan class=\"p\")/span\nspan class=\"n\"v3/span span class=\"o\"=/span span class=\"n\"lshift/spanspan class=\"p\"(/spanspan class=\"n\"v1/spanspan class=\"p\",/span span class=\"mi\"1/spanspan class=\"p\")/span\nspan class=\"n\"v4/span span class=\"o\"=/span span class=\"n\"add/spanspan class=\"p\"(/spanspan class=\"n\"v2/spanspan class=\"p\",/span span class=\"n\"v3/spanspan class=\"p\")/span\nspan class=\"n\"v6/span span class=\"o\"=/span span class=\"n\"dummy/spanspan class=\"p\"(/spanspan class=\"mi\"0/spanspan class=\"p\")/span\n/pre/div\n\npHey, neat! codebitand/code disappeared and the argument to codedummy/code is now the constant\ncode0/code because we know the lowest bit./p\nh3 id=\"wrapping-up\"Wrapping up/h3\npHopefully you have gained a little bit of an intuitive understanding of\nabstract interpretation. Last year, being able to write some code made me more\ncomfortable with the math. Now being more comfortable with the math is helping\nme write the code. It's nice upward spiral./p\npThe two abstract domains we used in this post are simple and not very useful in\npractice but it's possible to get very far using slightly more complicated\nabstract domains. Common domains include: constant propagation, type inference,\nrange analysis, effect inference, liveness, etc. For example, here is a a\nsample lattice for constant propagation:/p\nfigure style=\"display: block; margin: 0 auto;\"\n!--\ndigraph G {\n    rankdir=\"BT\";\n    top [shape=Msquare];\n    bottom [shape=Msquare];\n\n    bottom - \"-inf\";\n    bottom - \"-2\";\n    bottom - \"-1\";\n    bottom - 0;\n    bottom - 1;\n    bottom - 2;\n    bottom - \"+inf\";\n\n    \"-inf\" - negative;\n    \"-2\" - negative;\n    \"-1\" - negative;\n    0 - top;\n    1 - nonnegative;\n    2 - nonnegative;\n    \"+inf\" - nonnegative;\n\n    negative - nonzero;\n    nonnegative - nonzero;\n    nonzero-top;\n\n    {rank=same; \"-inf\"; \"-2\"; \"-1\"; 0; 1; 2; \"+inf\"}\n    {rank=same; nonnegative; negative;}\n}\n--\n    object class=\"svg\" type=\"image/svg+xml\" data=\"https://www.pypy.org/images/2024-complex-lattice.svg\"\n    /object\n/figure\n\npIt has multiple levels to indicate more and less precision. For example, you\nmight learn that a variable is either code1/code or code2/code and be able to encode that as\ncodenonnegative/code instead of just going straight to codetop/code./p\npCheck out some real-world abstract interpretation in open source projects:/p\nul\nlia href=\"https://github.com/llvm/llvm-project/blob/main/llvm/lib/Support/KnownBits.cpp\"Known bits in LLVM/a/li\nlia href=\"https://github.com/llvm/llvm-project/blob/main/llvm/lib/IR/ConstantRange.cpp\"Constant range in LLVM/a/li\nliBut I am told that the ranges don't form a lattice (see a href=\"https://dl.acm.org/doi/10.1145/2651360\"Interval Analysis and Machine Arithmetic: Why Signedness Ignorance Is Bliss/a)/li\nlia href=\"https://github.com/torvalds/linux/blob/master/kernel/bpf/tnum.c\"Tristate numbers for known bits in Linux eBPF/a/li\nlia href=\"https://github.com/torvalds/linux/blob/28bbe4ea686a023929d907cc168430b61094811c/kernel/bpf/verifier.c#L13335\"Range analysis in Linux eBPF/a/li\nlia href=\"https://github.com/bminor/binutils-gdb/blob/master/gdb/prologue-value.c\"GDB prologue analysis/a\n  of assembly to understand the stack and find frame pointers without using\n  DWARF (a href=\"https://sourceware.org/gdb/wiki/Internals/Prologue%20Analysis\"some\n  docs/a)/li\n/ul\npIf you have some readable examples, please share them so I can add./p\nh3 id=\"acknowledgements\"Acknowledgements/h3\npThank you to a href=\"https://cfbolz.de/\"CF Bolz-Tereick/a for the toy optimizer and\nhelping edit this post!/p\ndiv class=\"footnote\"\nhr\nol\nli id=\"fn:logozzo\"\npIn the words of abstract interpretation researchers Vincent Laviron\nand Francesco Logozzo in their paper emRefining Abstract\nInterpretation-based Static Analyses with Hints/em (APLAS 2009):/p\nblockquote\npThe three main elements of an abstract interpretation are: (i) the\nabstract elements (\"which properties am I interested in?\"); (ii) the\nabstract transfer functions (\"which is the abstract semantics of basic\nstatements?\"); and (iii) the abstract operations (\"how do I combine the\nabstract elements?\")./p\n/blockquote\npWe don't have any of these \"abstract operations\" in this post because\nthere's no control flow but you can read about them elsewhere! a class=\"footnote-backref\" href=\"https://www.pypy.org/posts/2024/07/toy-abstract-interpretation.html#fnref:logozzo\" title=\"Jump back to footnote 1 in the text\"/a/p\n/li\nli id=\"fn:lattices\"\npThese abstract values are arranged in a emlattice/em, which is a\nmathematical structure with some properties but the most important ones are\nthat it has a top, a bottom, a partial order, a meet operation, and values\ncan only move in one direction on the lattice./p\npUsing abstract values from a lattice promises two things:/p\nul\nliThe analysis will terminate/li\nliThe analysis will be correct for emany/em run of the program, not just one\n  sample run/li\n/ul\npa class=\"footnote-backref\" href=\"https://www.pypy.org/posts/2024/07/toy-abstract-interpretation.html#fnref:lattices\" title=\"Jump back to footnote 2 in the text\"/a/p\n/li\nli id=\"fn:match-args\"\npSomething about code__match_args__/code and code@property/code... a class=\"footnote-backref\" href=\"https://www.pypy.org/posts/2024/07/toy-abstract-interpretation.html#fnref:match-args\" title=\"Jump back to footnote 3 in the text\"/a/p\n/li\n/ol\n/div",
      "link": "https://www.pypy.org/posts/2024/07/toy-abstract-interpretation.html",
      "links": [],
      "published": "2024-07-24T14:48:00+00:00",
      "summary": "",
      "title": "Abstract interpretation in the Toy Optimizer"
    },
    {
      "author": "CF Bolz-Tereick",
      "content": [
        {
          "type": "text/html",
          "value": "pIn my last post I've described a href=\"https://www.pypy.org/posts/2024/07/finding-simple-rewrite-rules-jit-z3.html\"how to use Z3 to find simple local peephole\noptimization patterns/a\nfor the integer operations in PyPy's JIT. An example is codeint_and(x, 0) -gt;\n0/code. In this post I want to scale up the problem of identifying possible\noptimizations to much bigger instruction sequences, also using Z3. For that, I\nam starting with the JIT traces of strongreal benchmarks/strong, after they have been\noptimized by the optimizer of PyPy's JIT. Then we can ask Z3 to find\ninefficient integer operations in those traces./p\npStarting from the optimized traces of real programs has some big\nadvantages over the \"classical\" superoptimization approach of generating and\nthen trying all possible sequences of instructions. It avoids the\ncombinatorial explosion that happens with the latter approach. Also, starting\nfrom the traces of benchmarks or (even better) actual programs makes sure that\nwe actually care about the missing optimizations\nthat are found in this way. And because the traces are analyzed after they have\nbeen optimized by PyPy's optimizer, we only get reports for emmissing/em\noptimizations, that the JIT isn't able to do (yet)./p\npThe techniques and experiments I describe in this post are again the result of\na bunch of discussions with John Regehr at a conference a few weeks ago, as\nwell as reading his blog posts and papers. Thanks John! Also thanks to a href=\"https://bernsteinbear.com/\"Max\nBernstein/a for super helpful feedback on the drafts\nof this blog post (and for poking me to write things in general)./p\nh3 id=\"high-level-approach\"High-Level Approach/h3\npThe approach that I took works as follows:/p\nul\nliRun benchmarks or other interesting programs and then dump the IR of the JIT\n  traces into a file. The traces have at that point been already optimized by\n  the PyPy JIT's optimizer./li\nliFor every trace, ignore all the operations on non-integer variables./li\nliTranslate every integer operation into a Z3 formula./li\nliFor every operation, use Z3 to find out whether the operation is redundant\n  (how that is done is described below)./li\nliIf the operation is redundant, the trace is less efficient than it could have\n  been, because the optimizer could also have removed the operation. Report the\n  inefficiency./li\nliMinimize the inefficient programs by removing as many operations as possible\n  to make the problem easier to understand./li\n/ul\npIn the post I will describe the details and show some pseudocode of the\napproach. I'll also make the proper code public eventually (but it needs a\nhealthy dose of cleanups first)./p\nh3 id=\"dumping-pypy-traces\"Dumping PyPy Traces/h3\npPyPy will write its JIT traces into the file codeout/code if the environment variable\na href=\"https://doc.pypy.org/en/latest/man/pypy.1.html\"codePYPYLOG/code/a is set as follows:/p\ndiv class=\"code\"pre class=\"code literal-block\"PYPYLOG=jit-log-opt:out pypy lt;program.pygt;\n/pre/div\n\npThis environment variable works for PyPy, but also for other virtual machines\nbuilt with RPython./p\np(This is really a side point for the rest of the blog post, but since the\nquestion came up I wanted to clarify it: Operations on integers in the Python\nprogram that the JIT is running don't all correspond 1-to-1 with the codeint_.../code\noperations in the traces. The codeint_.../code trace operations always operate on\nmachine words. The Python codeint/code type supports arbitrarily large integers. PyPy\nwill optimistically try to lower the operations on Python integers into machine\nword operations, but adds the necessary guards into the trace to make sure that\noverflow outside of the range of machine words is caught. In case one of these\nguards fails the interpreter switches to a big integer heap-allocated\nrepresentation.)/p\nh3 id=\"encoding-traces-as-z3-formulas\"Encoding Traces as Z3 formulas/h3\npThe last blog post already contained the code to encode the results of\nindividual trace operations into Z3 formulas, so we don't need to repeat that\nhere. To encode traces of operations we introduce a Z3 variable for every\noperation in the trace and then call the codez3_expression/code function for every\nsingle one of the operations in the trace./p\npFor example, for the following trace:/p\ndiv class=\"code\"pre class=\"code literal-block\"span class=\"k\"[i1]/span\nspan class=\"na\"i2/spanspan class=\"w\" /spanspan class=\"o\"=/spanspan class=\"w\" /spanspan class=\"s\"uint_rshift(i1, 32)/span\nspan class=\"na\"i3/spanspan class=\"w\" /spanspan class=\"o\"=/spanspan class=\"w\" /spanspan class=\"s\"int_and(i2, 65535)/span\nspan class=\"na\"i4/spanspan class=\"w\" /spanspan class=\"o\"=/spanspan class=\"w\" /spanspan class=\"s\"uint_rshift(i1, 48)/span\nspan class=\"na\"i5/spanspan class=\"w\" /spanspan class=\"o\"=/spanspan class=\"w\" /spanspan class=\"s\"int_lshift(i4, 16)/span\nspan class=\"na\"i6/spanspan class=\"w\" /spanspan class=\"o\"=/spanspan class=\"w\" /spanspan class=\"s\"int_or(i5, i3)/span\nspan class=\"na\"jump(i6, i2) # equal/span\n/pre/div\n\npWe would get the Z3 formula:/p\ndiv class=\"code\"pre class=\"code literal-block\"z3.And(i2 == LShR(i1, 32),\n       i3 == i2 amp; 65535,\n       i4 == LShR(i1, 48),\n       i5 == i4 lt;lt; 16)\n/pre/div\n\npUsually we won't ask for the formula of the whole trace at once. Instead we go\nthrough the trace operation by operation and try to find inefficiencies in the\ncurrent one we are looking at. Roughly like this (pseudo-)code:/p\ndiv class=\"code\"pre class=\"code literal-block\"span class=\"k\"def/span span class=\"nf\"newvar/spanspan class=\"p\"(/spanspan class=\"n\"name/spanspan class=\"p\"):/span\n    span class=\"k\"return/span span class=\"n\"z3/spanspan class=\"o\"./spanspan class=\"n\"BitVec/spanspan class=\"p\"(/spanspan class=\"n\"name/spanspan class=\"p\",/span span class=\"n\"INTEGER_WIDTH/spanspan class=\"p\")/span\n\nspan class=\"k\"def/span span class=\"nf\"find_inefficiencies/spanspan class=\"p\"(/spanspan class=\"n\"trace/spanspan class=\"p\"):/span\n    span class=\"n\"solver/span span class=\"o\"=/span span class=\"n\"z3/spanspan class=\"o\"./spanspan class=\"n\"Solver/spanspan class=\"p\"()/span\n    span class=\"n\"var_to_z3var/span span class=\"o\"=/span span class=\"p\"{}/span\n    span class=\"k\"for/span span class=\"n\"input_argument/span span class=\"ow\"in/span span class=\"n\"trace/spanspan class=\"o\"./spanspan class=\"n\"inputargs/spanspan class=\"p\":/span\n        span class=\"n\"var_to_z3var/spanspan class=\"p\"[/spanspan class=\"n\"input_argument/spanspan class=\"p\"]/span span class=\"o\"=/span span class=\"n\"newz3var/spanspan class=\"p\"(/spanspan class=\"n\"input_argument/spanspan class=\"p\")/span\n    span class=\"k\"for/span span class=\"n\"op/span span class=\"ow\"in/span span class=\"n\"trace/spanspan class=\"p\":/span\n        span class=\"n\"var_to_z3var/spanspan class=\"p\"[/spanspan class=\"n\"op/spanspan class=\"p\"]/span span class=\"o\"=/span span class=\"n\"z3resultvar/span span class=\"o\"=/span span class=\"n\"newz3var/spanspan class=\"p\"(/spanspan class=\"n\"op/spanspan class=\"o\"./spanspan class=\"n\"resultvarname/spanspan class=\"p\")/span\n        span class=\"n\"arg0/span span class=\"o\"=/span span class=\"n\"op/spanspan class=\"o\"./spanspan class=\"n\"args/spanspan class=\"p\"[/spanspan class=\"mi\"0/spanspan class=\"p\"]/span\n        span class=\"n\"z3arg0/span span class=\"o\"=/span span class=\"n\"var_to_z3var/spanspan class=\"p\"[/spanspan class=\"n\"arg0/spanspan class=\"p\"]/span\n        span class=\"k\"if/span span class=\"nb\"len/spanspan class=\"p\"(/spanspan class=\"n\"op/spanspan class=\"o\"./spanspan class=\"n\"args/spanspan class=\"p\")/span span class=\"o\"==/span span class=\"mi\"2/spanspan class=\"p\":/span\n            span class=\"n\"arg1/span span class=\"o\"=/span span class=\"n\"op/spanspan class=\"o\"./spanspan class=\"n\"args/spanspan class=\"p\"[/spanspan class=\"mi\"1/spanspan class=\"p\"]/span\n            span class=\"n\"z3arg1/span span class=\"o\"=/span span class=\"n\"var_to_z3var/spanspan class=\"p\"[/spanspan class=\"n\"arg1/spanspan class=\"p\"]/span\n        span class=\"k\"else/spanspan class=\"p\":/span\n            span class=\"n\"z3arg1/span span class=\"o\"=/span span class=\"kc\"None/span\n        span class=\"n\"res/spanspan class=\"p\",/span span class=\"n\"valid_if/span span class=\"o\"=/span span class=\"n\"z3_expression/spanspan class=\"p\"(/spanspan class=\"n\"op/spanspan class=\"o\"./spanspan class=\"n\"name/spanspan class=\"p\",/span span class=\"n\"z3arg0/spanspan class=\"p\",/span span class=\"n\"z3arg1/spanspan class=\"p\")/span\n        span class=\"c1\"# checking for inefficiencies, see the next sections/span\n        span class=\"o\".../span\n        span class=\"k\"if/span span class=\"o\".../spanspan class=\"p\":/span\n            span class=\"k\"return/span span class=\"s2\"\"inefficient\"/spanspan class=\"p\",/span span class=\"n\"op/span\n\n        span class=\"c1\"# not inefficient, assert op into the solver and continue with the next op/span\n        span class=\"n\"solver/spanspan class=\"o\"./spanspan class=\"n\"add/spanspan class=\"p\"(/spanspan class=\"n\"z3resultvar/span span class=\"o\"==/span span class=\"n\"res/spanspan class=\"p\")/span\n    span class=\"k\"return/span span class=\"kc\"None/span span class=\"c1\"# no inefficiency found/span\n/pre/div\n\nh3 id=\"identifying-constant-booleans-with-z3\"Identifying constant booleans with Z3/h3\npTo get started finding inefficiencies in a trace, we can\nfirst focus on boolean variables. For every operation in the trace that\nreturns a bool we can ask Z3 to prove that this variable must be always True or\nalways False. Most of the time, neither of these proofs will succeed. But if Z3\nmanages to prove one of them, we know have found an ineffiency: instead of\ncomputing the boolean result (eg by executing a comparison) the JIT's optimizer\ncould have replaced the operation with the corresponding boolean constant./p\npHere's an example of an inefficiency found that way: if codex lt; y/code and codey lt; z/code are\nboth true, PyPy's JIT could conclude that codex lt; z/code must also\nbe true. However, currently the JIT cannot make that conclusion because it\nonly reasons about the concrete ranges (lower and upper bounds) for every\ninteger variable, but it has no way to remember anything about relationships\nbetween different variables. This kind of reasoning would quite often be useful\nto remove list/string bounds checks. Here's a a href=\"https://www.youtube.com/watch?app=desktopamp;v=1hm5ZVmBEvo\"talk about how LLVM does\nthis/a (but it might be\ntoo heavyweight for a JIT setting)./p\npHere are some more examples found that way:/p\nul\nlicodex - 1 == x/code is always False/li\nlicodex - (x == -1) == -1/code is always False. The pattern codex - (x == -1)/code happens a\n  lot in PyPy's hash computations: To be compatible with the CPython hashes we\n  need to make sure that no object's hash is -1 (CPython uses -1 as an error\n  value on the C level)./li\n/ul\npHere's pseudo-code for how to implement checking boolean operations for\ninefficiencies:/p\ndiv class=\"code\"pre class=\"code literal-block\"span class=\"k\"def/span span class=\"nf\"find_inefficiencies/spanspan class=\"p\"(/spanspan class=\"n\"trace/spanspan class=\"p\"):/span\n    span class=\"o\".../span\n    span class=\"k\"for/span span class=\"n\"op/span span class=\"ow\"in/span span class=\"n\"trace/spanspan class=\"p\":/span\n        span class=\"o\".../span\n        span class=\"n\"res/spanspan class=\"p\",/span span class=\"n\"valid_if/span span class=\"o\"=/span span class=\"n\"z3_expression/spanspan class=\"p\"(/spanspan class=\"n\"op/spanspan class=\"o\"./spanspan class=\"n\"name/spanspan class=\"p\",/span span class=\"n\"z3arg0/spanspan class=\"p\",/span span class=\"n\"z3arg1/spanspan class=\"p\")/span\n        span class=\"c1\"# check for boolean constant result/span\n        span class=\"k\"if/span span class=\"n\"op/spanspan class=\"o\"./spanspan class=\"n\"has_boolean_result/spanspan class=\"p\"():/span\n            span class=\"k\"if/span span class=\"n\"prove/spanspan class=\"p\"(/spanspan class=\"n\"solver/spanspan class=\"p\",/span span class=\"n\"res/span span class=\"o\"==/span span class=\"mi\"0/spanspan class=\"p\"):/span\n                span class=\"k\"return/span span class=\"s2\"\"inefficient\"/spanspan class=\"p\",/span span class=\"n\"op/spanspan class=\"p\",/span span class=\"mi\"0/span\n            span class=\"k\"if/span span class=\"n\"prove/spanspan class=\"p\"(/spanspan class=\"n\"solver/spanspan class=\"p\",/span span class=\"n\"res/span span class=\"o\"==/span span class=\"mi\"1/spanspan class=\"p\"):/span\n                span class=\"k\"return/span span class=\"s2\"\"inefficient\"/spanspan class=\"p\",/span span class=\"n\"op/spanspan class=\"p\",/span span class=\"mi\"1/span\n        span class=\"c1\"# checking for other inefficiencies, see the next sections/span\n        span class=\"o\".../span\n\n        span class=\"c1\"# not inefficient, add op to the solver and continue with the next op/span\n        span class=\"n\"solver/spanspan class=\"o\"./spanspan class=\"n\"add/spanspan class=\"p\"(/spanspan class=\"n\"z3resultvar/span span class=\"o\"==/span span class=\"n\"res/spanspan class=\"p\")/span\n    span class=\"k\"return/span span class=\"kc\"None/span span class=\"c1\"# no inefficiency found/span\n/pre/div\n\nh3 id=\"identifying-redundant-operations\"Identifying redundant operations/h3\npA more interesting class of redundancy is to try to find two operations in a\ntrace that compute the same result. We can do that by asking Z3 to prove for\neach pair of different operations in the trace to prove that the result is\nalways the same. If a previous operation returns the same result, the JIT could\nhave re-used that result instead of re-computing it, saving time. Doing this\nsearch for equivalent operations with Z3 is quadratic in the number of\noperations, but since traces have a maximum length it is not too bad in\npractice./p\npThis is the real workhorse of my script so far, it's what finds most of the\ninefficiencies. Here's a few examples:/p\nul\nliThe very first and super useful example the script found is codeint_eq(b, 1) ==\n  b/code if codeb/code is known to be a boolean (ie and integer 0 or 1). I have already\n  implemented this optimization in the JIT./li\nliSimilarly, codeint_and(b, 1) == b/code for booleans./li\nlicode(x lt;lt; 4) amp; -0xf == x lt;lt; 4/code/li\nlicode((x gt;gt; 63) lt;lt; 1) lt;lt; 2) gt;gt; 3 == x gt;gt; 63/code. In general the JIT is quite bad at\n  optimizing repeated shifts (the infrastructure for doing better with that is\n  already in place, so this will be a relatively easy fix)./li\nlicode(x amp; 0xffffffff) | ((x gt;gt; 32) lt;lt; 32) == x/code. Having the JIT optimize this\n  would maybe require first recognizing that code(x gt;gt; 32) lt;lt; 32/code can be expressed\n  as a mask: code(x amp; 0xffffffff00000000)/code, and then using code(x amp; c1) | (x amp; c2) ==\n  x amp; (c1 | c2)/code/li\nliA commonly occurring pattern is variations of this one:\n  code((x amp; 1345) ^ 2048) - 2048 == x amp; 1345/code (with different constants, of\n  course). xor is add without carry, and codex amp; 1345/code does not have the bit\n  code2048/code set. Therefore the code^ 2048/code is equivalent to code+ 2048/code, which the code-\n  2048/code cancels. More generally, if codea amp; b == 0/code, then codea + b == a | b == a ^ b/code.\n  I don't understand at all why this appears so often in the traces, but I\n  see variations of it a lot. LLVM can optimize this, but a href=\"https://gcc.gnu.org/bugzilla/show_bug.cgi?id=115829\"GCC\n  can't/a, thanks to\n  a href=\"https://hachyderm.io/@pinskia/112752641328799157\"Andrew Pinski for filing the\n  bug/a!/li\n/ul\npAnd here's some implementation pseudo-code again:/p\ndiv class=\"code\"pre class=\"code literal-block\"span class=\"k\"def/span span class=\"nf\"find_inefficiencies/spanspan class=\"p\"(/spanspan class=\"n\"trace/spanspan class=\"p\"):/span\n    span class=\"o\".../span\n    span class=\"k\"for/span span class=\"n\"op/span span class=\"ow\"in/span span class=\"n\"trace/spanspan class=\"p\":/span\n        span class=\"o\".../span\n        span class=\"n\"res/spanspan class=\"p\",/span span class=\"n\"valid_if/span span class=\"o\"=/span span class=\"n\"z3_expression/spanspan class=\"p\"(/spanspan class=\"n\"op/spanspan class=\"o\"./spanspan class=\"n\"name/spanspan class=\"p\",/span span class=\"n\"z3arg0/spanspan class=\"p\",/span span class=\"n\"z3arg1/spanspan class=\"p\")/span\n        span class=\"c1\"# check for boolean constant result/span\n        span class=\"o\".../span\n        span class=\"c1\"# searching for redundant operations/span\n        span class=\"k\"for/span span class=\"n\"previous_op/span span class=\"ow\"in/span span class=\"n\"trace/spanspan class=\"p\":/span\n            span class=\"k\"if/span span class=\"n\"previous_op/span span class=\"ow\"is/span span class=\"n\"op/spanspan class=\"p\":/span\n                span class=\"k\"break/span span class=\"c1\"# done, reached the current op/span\n            span class=\"n\"previous_op_z3var/span span class=\"o\"=/span span class=\"n\"var_to_z3var/spanspan class=\"p\"[/spanspan class=\"n\"previous_op/spanspan class=\"p\"]/span\n            span class=\"k\"if/span span class=\"n\"prove/spanspan class=\"p\"(/spanspan class=\"n\"solver/spanspan class=\"p\",/span span class=\"n\"previous_op_z3var/span span class=\"o\"==/span span class=\"n\"res/spanspan class=\"p\"):/span\n                span class=\"k\"return/span span class=\"s2\"\"inefficient\"/spanspan class=\"p\",/span span class=\"n\"op/spanspan class=\"p\",/span span class=\"n\"previous_op/span\n        span class=\"o\".../span\n        span class=\"c1\"# more code here later/span\n        span class=\"o\".../span\n\n        span class=\"c1\"# not inefficient, add op to the solver and continue with the next op/span\n        span class=\"n\"solver/spanspan class=\"o\"./spanspan class=\"n\"add/spanspan class=\"p\"(/spanspan class=\"n\"z3resultvar/span span class=\"o\"==/span span class=\"n\"res/spanspan class=\"p\")/span\n    span class=\"k\"return/span span class=\"kc\"None/span span class=\"c1\"# no inefficiency found/span\n/pre/div\n\nh3 id=\"synthesizing-more-complicated-constants-with-exists-forall\"Synthesizing more complicated constants with exists-forall/h3\npTo find out whether some integer operations always return a constant result, we\ncan't simply use the same trick as for those operations that return boolean\nresults, because enumerating 2 possible constants and checking them all\nwould take too long. Like in the last post, we can use codez3.ForAll/code to find out\nwhether Z3 can synthesize a constant for the result of an operation for us.\nIf such a constant exists, the JIT could have removed the operation,\nand replaced it with the constant that Z3 provides./p\npHere a few examples of inefficiencies found this way:/p\nul\nlicode(x ^ 1) ^ x == 1/code (or, more generally: code(x ^ y) ^ x == y/code)/li\nliif codex | y == 0/code, it follows that codex == 0/code and codey == 0/code/li\nliif codex != MAXINT/code, then codex + 1 gt; x/code/li\n/ul\npImplementing this is actually slightly annoying. The codesolver.add/code calls for\nnon-inefficient ops add assertions to the solver, which are now confusing the\ncodez3.ForAll/code query. We could remove all assertion from the solver, then do the\ncodeForAll/code query, then add the assertions back. What I ended doing instead was\ninstantiating a second solver object that I'm using for the codeForAll/code queries,\nthat remains empty the whole time./p\ndiv class=\"code\"pre class=\"code literal-block\"span class=\"k\"def/span span class=\"nf\"find_inefficiencies/spanspan class=\"p\"(/spanspan class=\"n\"trace/spanspan class=\"p\"):/span\n    span class=\"n\"solver/span span class=\"o\"=/span span class=\"n\"z3/spanspan class=\"o\"./spanspan class=\"n\"Solver/spanspan class=\"p\"()/span\n    span class=\"n\"empty_solver/span span class=\"o\"=/span span class=\"n\"z3/spanspan class=\"o\"./spanspan class=\"n\"Solver/spanspan class=\"p\"()/span\n    span class=\"n\"var_to_z3var/span span class=\"o\"=/span span class=\"p\"{}/span\n    span class=\"o\".../span\n    span class=\"k\"for/span span class=\"n\"op/span span class=\"ow\"in/span span class=\"n\"trace/spanspan class=\"p\":/span\n        span class=\"o\".../span\n        span class=\"n\"res/spanspan class=\"p\",/span span class=\"n\"valid_if/span span class=\"o\"=/span span class=\"n\"z3_expression/spanspan class=\"p\"(/spanspan class=\"n\"op/spanspan class=\"o\"./spanspan class=\"n\"name/spanspan class=\"p\",/span span class=\"n\"z3arg0/spanspan class=\"p\",/span span class=\"n\"z3arg1/spanspan class=\"p\")/span\n        span class=\"c1\"# check for boolean constant result/span\n        span class=\"o\".../span\n        span class=\"c1\"# searching for redundant operations/span\n        span class=\"o\".../span\n        span class=\"c1\"# checking for constant results/span\n        span class=\"n\"constvar/span span class=\"o\"=/span span class=\"n\"z3/spanspan class=\"o\"./spanspan class=\"n\"BitVec/spanspan class=\"p\"(/spanspan class=\"s1\"'find_const'/spanspan class=\"p\",/span span class=\"n\"INTEGER_WIDTH/spanspan class=\"p\")/span\n        span class=\"n\"condition/span span class=\"o\"=/span span class=\"n\"z3/spanspan class=\"o\"./spanspan class=\"n\"ForAll/spanspan class=\"p\"(/span\n            span class=\"n\"var_to_z3var/spanspan class=\"o\"./spanspan class=\"n\"values/spanspan class=\"p\"(),/span\n            span class=\"n\"z3/spanspan class=\"o\"./spanspan class=\"n\"Implies/spanspan class=\"p\"(/span\n                span class=\"o\"*/spanspan class=\"n\"solver/spanspan class=\"o\"./spanspan class=\"n\"assertions/spanspan class=\"p\"(),/span\n                span class=\"n\"expr/span span class=\"o\"==/span span class=\"n\"constvar/span\n            span class=\"p\")/span\n        span class=\"p\")/span\n        span class=\"k\"if/span span class=\"n\"empty_solver/spanspan class=\"o\"./spanspan class=\"n\"check/spanspan class=\"p\"(/spanspan class=\"n\"condition/spanspan class=\"p\")/span span class=\"o\"==/span span class=\"n\"z3/spanspan class=\"o\"./spanspan class=\"n\"sat/spanspan class=\"p\":/span\n            span class=\"n\"model/span span class=\"o\"=/span span class=\"n\"empty_solver/spanspan class=\"o\"./spanspan class=\"n\"model/spanspan class=\"p\"()/span\n            span class=\"n\"const/span span class=\"o\"=/span span class=\"n\"model/spanspan class=\"p\"[/spanspan class=\"n\"constvar/spanspan class=\"p\"]/spanspan class=\"o\"./spanspan class=\"n\"as_signed_long/spanspan class=\"p\"()/span\n            span class=\"k\"return/span span class=\"s2\"\"inefficient\"/spanspan class=\"p\",/span span class=\"n\"op/spanspan class=\"p\",/span span class=\"n\"const/span\n\n        span class=\"c1\"# not inefficient, add op to the solver and continue with the next op/span\n        span class=\"n\"solver/spanspan class=\"o\"./spanspan class=\"n\"add/spanspan class=\"p\"(/spanspan class=\"n\"z3resultvar/span span class=\"o\"==/span span class=\"n\"res/spanspan class=\"p\")/span\n    span class=\"k\"return/span span class=\"kc\"None/span span class=\"c1\"# no inefficiency found/span\n/pre/div\n\nh3 id=\"minimization\"Minimization/h3\npAnalyzing an inefficiency by hand in the context of a larger trace is quite\ntedious. Therefore I've implemented a (super inefficient) script to try to make\nthe examples smaller. Here's how that works:/p\nul\nliFirst throw out all the operations that occur emafter/em the inefficient operation\n  in the trace./li\nliThen we remove all \"dead\" operations, ie operations that don't have their\n  results used (all the operations that we can analyze with Z3 are without side\n  effects)./li\nliNow we try to remove every guard in the trace one by one and check\n  afterwards, whether the resulting trace still has an inefficiency./li\nliWe also try to replace every single operation with a new argument to the\n  trace, to see whether the inefficiency is still present./li\n/ul\npThe minimization process is sort of inefficient and I should probably be using\n a href=\"https://github.com/DRMacIver/shrinkray\"shrinkray/a or\n a href=\"https://github.com/csmith-project/creduce\"C-Reduce/a instead. However, it\n seems to work well in practice and the runtime isn't too bad./p\nh3 id=\"results\"Results/h3\npSo far I am using the JIT traces of three programs: 1) Booting Linux on the\na href=\"https://docs.pydrofoil.org\"Pydrofoil/a RISC-V emulator, 2) booting Linux on the Pydrofoil ARM emulator, and 3)\nrunning the PyPy bootstrap process on top of PyPy./p\npI picked these programs because most Python programs don't contain interesting\namounts of integer operations, and the traces of the emulators\ncontain a lot of them. I also used the bootstrap process because I still wanted\nto try a big Python program and personally care about the runtime of this\nprogram a lot./p\npThe script identifies 94\ninefficiencies in the traces, a lot of them come from repeating\npatterns. My next steps will be to manually inspect them all, categorize them, and\nimplement easy optimizations identified that way. I also want a way to sort the\nexamples by execution count in the benchmarks, to get a feeling for which of\nthem are most important./p\npI didn't investigate the full set of a href=\"https://speed.pypy.org\"Python\nbenchmarks/a that PyPy uses yet, because I don't expect\nthem to contain interesting amounts of integer operations, but maybe I am wrong\nabout that? Will have to try eventually./p\nh3 id=\"conclusion\"Conclusion/h3\npThis was again much easier to do than I would have expected! Given that I had\nthe translation of trace ops to Z3 already in place, it was a matter of about a\nday's of programming to use this infrastructure to find the first problems and\nminimizing them./p\npReusing the results of existing operations or replacing operations by constants\ncan be seen as \"zero-instruction superoptimization\". I'll probably be rather\nbusy for a while to add the missing optimizations identified by my simple\nscript. But later extensions to actually synthesize one or several operations\nin the attempt to optimize the traces more and find more opportunities should\nbe possible./p\npFinding inefficiencies in traces with Z3 is significantly less\nannoying and also less error-prone than just manually inspecting traces and\ntrying to spot optimization opportunities./p\nh3 id=\"random-notes-and-sources\"Random Notes and Sources/h3\npAgain, John's blog posts:/p\nul\nlia href=\"https://blog.regehr.org/archives/1109\"Lets Work on an LLVM Superoptimizer/a/li\nlia href=\"https://blog.regehr.org/archives/1146\"Early Superoptimizer Results/a/li\nlia href=\"https://blog.regehr.org/archives/1252\"A Few Synthesizing Superoptimizer Results/a/li\nlia href=\"https://blog.regehr.org/archives/1636\"Synthesizing Constants/a/li\n/ul\npand papers:/p\nul\nlia href=\"https://arxiv.org/pdf/1711.04422\"A Synthesizing Superoptimizer/a/li\nlia href=\"https://dl.acm.org/doi/pdf/10.1145/3649837\"Hydra: Generalizing Peephole Optimizations with Program Synthesis/a/li\n/ul\npI remembered recently that I had seen the approach of optimizing the traces of\na tracing JIT with Z3 a long time ago, as part of the (now long dead, I think)\na href=\"https://web.archive.org/web/20160304055149/http://research.microsoft.com/en-us/projects/spur/\"SPUR\nproject/a.\nThere's a a href=\"https://web.archive.org/web/20161029162737/http://csl.stanford.edu/~christos/pldi2010.fit/tillmann.provers4jit.pdf\"workshop\npaper/a\nfrom 2010 about this. SPUR was trying to use Z3 built into the actual JIT (as\nopposed to using Z3 only to find places where the regular optimizers could be\nimproved). In addition to bitvectors, SPUR also used the Z3 support for arrays\nto model the C# heap and remove redundant stores. This is still another future\nextension for all the Z3 work I've been doing in the context of the PyPy JIT./p"
        }
      ],
      "description": "pIn my last post I've described a href=\"https://www.pypy.org/posts/2024/07/finding-simple-rewrite-rules-jit-z3.html\"how to use Z3 to find simple local peephole\noptimization patterns/a\nfor the integer operations in PyPy's JIT. An example is codeint_and(x, 0) -gt;\n0/code. In this post I want to scale up the problem of identifying possible\noptimizations to much bigger instruction sequences, also using Z3. For that, I\nam starting with the JIT traces of strongreal benchmarks/strong, after they have been\noptimized by the optimizer of PyPy's JIT. Then we can ask Z3 to find\ninefficient integer operations in those traces./p\npStarting from the optimized traces of real programs has some big\nadvantages over the \"classical\" superoptimization approach of generating and\nthen trying all possible sequences of instructions. It avoids the\ncombinatorial explosion that happens with the latter approach. Also, starting\nfrom the traces of benchmarks or (even better) actual programs makes sure that\nwe actually care about the missing optimizations\nthat are found in this way. And because the traces are analyzed after they have\nbeen optimized by PyPy's optimizer, we only get reports for emmissing/em\noptimizations, that the JIT isn't able to do (yet)./p\npThe techniques and experiments I describe in this post are again the result of\na bunch of discussions with John Regehr at a conference a few weeks ago, as\nwell as reading his blog posts and papers. Thanks John! Also thanks to a href=\"https://bernsteinbear.com/\"Max\nBernstein/a for super helpful feedback on the drafts\nof this blog post (and for poking me to write things in general)./p\nh3 id=\"high-level-approach\"High-Level Approach/h3\npThe approach that I took works as follows:/p\nul\nliRun benchmarks or other interesting programs and then dump the IR of the JIT\n  traces into a file. The traces have at that point been already optimized by\n  the PyPy JIT's optimizer./li\nliFor every trace, ignore all the operations on non-integer variables./li\nliTranslate every integer operation into a Z3 formula./li\nliFor every operation, use Z3 to find out whether the operation is redundant\n  (how that is done is described below)./li\nliIf the operation is redundant, the trace is less efficient than it could have\n  been, because the optimizer could also have removed the operation. Report the\n  inefficiency./li\nliMinimize the inefficient programs by removing as many operations as possible\n  to make the problem easier to understand./li\n/ul\npIn the post I will describe the details and show some pseudocode of the\napproach. I'll also make the proper code public eventually (but it needs a\nhealthy dose of cleanups first)./p\nh3 id=\"dumping-pypy-traces\"Dumping PyPy Traces/h3\npPyPy will write its JIT traces into the file codeout/code if the environment variable\na href=\"https://doc.pypy.org/en/latest/man/pypy.1.html\"codePYPYLOG/code/a is set as follows:/p\ndiv class=\"code\"pre class=\"code literal-block\"PYPYLOG=jit-log-opt:out pypy lt;program.pygt;\n/pre/div\n\npThis environment variable works for PyPy, but also for other virtual machines\nbuilt with RPython./p\np(This is really a side point for the rest of the blog post, but since the\nquestion came up I wanted to clarify it: Operations on integers in the Python\nprogram that the JIT is running don't all correspond 1-to-1 with the codeint_.../code\noperations in the traces. The codeint_.../code trace operations always operate on\nmachine words. The Python codeint/code type supports arbitrarily large integers. PyPy\nwill optimistically try to lower the operations on Python integers into machine\nword operations, but adds the necessary guards into the trace to make sure that\noverflow outside of the range of machine words is caught. In case one of these\nguards fails the interpreter switches to a big integer heap-allocated\nrepresentation.)/p\nh3 id=\"encoding-traces-as-z3-formulas\"Encoding Traces as Z3 formulas/h3\npThe last blog post already contained the code to encode the results of\nindividual trace operations into Z3 formulas, so we don't need to repeat that\nhere. To encode traces of operations we introduce a Z3 variable for every\noperation in the trace and then call the codez3_expression/code function for every\nsingle one of the operations in the trace./p\npFor example, for the following trace:/p\ndiv class=\"code\"pre class=\"code literal-block\"span class=\"k\"[i1]/span\nspan class=\"na\"i2/spanspan class=\"w\" /spanspan class=\"o\"=/spanspan class=\"w\" /spanspan class=\"s\"uint_rshift(i1, 32)/span\nspan class=\"na\"i3/spanspan class=\"w\" /spanspan class=\"o\"=/spanspan class=\"w\" /spanspan class=\"s\"int_and(i2, 65535)/span\nspan class=\"na\"i4/spanspan class=\"w\" /spanspan class=\"o\"=/spanspan class=\"w\" /spanspan class=\"s\"uint_rshift(i1, 48)/span\nspan class=\"na\"i5/spanspan class=\"w\" /spanspan class=\"o\"=/spanspan class=\"w\" /spanspan class=\"s\"int_lshift(i4, 16)/span\nspan class=\"na\"i6/spanspan class=\"w\" /spanspan class=\"o\"=/spanspan class=\"w\" /spanspan class=\"s\"int_or(i5, i3)/span\nspan class=\"na\"jump(i6, i2) # equal/span\n/pre/div\n\npWe would get the Z3 formula:/p\ndiv class=\"code\"pre class=\"code literal-block\"z3.And(i2 == LShR(i1, 32),\n       i3 == i2 amp; 65535,\n       i4 == LShR(i1, 48),\n       i5 == i4 lt;lt; 16)\n/pre/div\n\npUsually we won't ask for the formula of the whole trace at once. Instead we go\nthrough the trace operation by operation and try to find inefficiencies in the\ncurrent one we are looking at. Roughly like this (pseudo-)code:/p\ndiv class=\"code\"pre class=\"code literal-block\"span class=\"k\"def/span span class=\"nf\"newvar/spanspan class=\"p\"(/spanspan class=\"n\"name/spanspan class=\"p\"):/span\n    span class=\"k\"return/span span class=\"n\"z3/spanspan class=\"o\"./spanspan class=\"n\"BitVec/spanspan class=\"p\"(/spanspan class=\"n\"name/spanspan class=\"p\",/span span class=\"n\"INTEGER_WIDTH/spanspan class=\"p\")/span\n\nspan class=\"k\"def/span span class=\"nf\"find_inefficiencies/spanspan class=\"p\"(/spanspan class=\"n\"trace/spanspan class=\"p\"):/span\n    span class=\"n\"solver/span span class=\"o\"=/span span class=\"n\"z3/spanspan class=\"o\"./spanspan class=\"n\"Solver/spanspan class=\"p\"()/span\n    span class=\"n\"var_to_z3var/span span class=\"o\"=/span span class=\"p\"{}/span\n    span class=\"k\"for/span span class=\"n\"input_argument/span span class=\"ow\"in/span span class=\"n\"trace/spanspan class=\"o\"./spanspan class=\"n\"inputargs/spanspan class=\"p\":/span\n        span class=\"n\"var_to_z3var/spanspan class=\"p\"[/spanspan class=\"n\"input_argument/spanspan class=\"p\"]/span span class=\"o\"=/span span class=\"n\"newz3var/spanspan class=\"p\"(/spanspan class=\"n\"input_argument/spanspan class=\"p\")/span\n    span class=\"k\"for/span span class=\"n\"op/span span class=\"ow\"in/span span class=\"n\"trace/spanspan class=\"p\":/span\n        span class=\"n\"var_to_z3var/spanspan class=\"p\"[/spanspan class=\"n\"op/spanspan class=\"p\"]/span span class=\"o\"=/span span class=\"n\"z3resultvar/span span class=\"o\"=/span span class=\"n\"newz3var/spanspan class=\"p\"(/spanspan class=\"n\"op/spanspan class=\"o\"./spanspan class=\"n\"resultvarname/spanspan class=\"p\")/span\n        span class=\"n\"arg0/span span class=\"o\"=/span span class=\"n\"op/spanspan class=\"o\"./spanspan class=\"n\"args/spanspan class=\"p\"[/spanspan class=\"mi\"0/spanspan class=\"p\"]/span\n        span class=\"n\"z3arg0/span span class=\"o\"=/span span class=\"n\"var_to_z3var/spanspan class=\"p\"[/spanspan class=\"n\"arg0/spanspan class=\"p\"]/span\n        span class=\"k\"if/span span class=\"nb\"len/spanspan class=\"p\"(/spanspan class=\"n\"op/spanspan class=\"o\"./spanspan class=\"n\"args/spanspan class=\"p\")/span span class=\"o\"==/span span class=\"mi\"2/spanspan class=\"p\":/span\n            span class=\"n\"arg1/span span class=\"o\"=/span span class=\"n\"op/spanspan class=\"o\"./spanspan class=\"n\"args/spanspan class=\"p\"[/spanspan class=\"mi\"1/spanspan class=\"p\"]/span\n            span class=\"n\"z3arg1/span span class=\"o\"=/span span class=\"n\"var_to_z3var/spanspan class=\"p\"[/spanspan class=\"n\"arg1/spanspan class=\"p\"]/span\n        span class=\"k\"else/spanspan class=\"p\":/span\n            span class=\"n\"z3arg1/span span class=\"o\"=/span span class=\"kc\"None/span\n        span class=\"n\"res/spanspan class=\"p\",/span span class=\"n\"valid_if/span span class=\"o\"=/span span class=\"n\"z3_expression/spanspan class=\"p\"(/spanspan class=\"n\"op/spanspan class=\"o\"./spanspan class=\"n\"name/spanspan class=\"p\",/span span class=\"n\"z3arg0/spanspan class=\"p\",/span span class=\"n\"z3arg1/spanspan class=\"p\")/span\n        span class=\"c1\"# checking for inefficiencies, see the next sections/span\n        span class=\"o\".../span\n        span class=\"k\"if/span span class=\"o\".../spanspan class=\"p\":/span\n            span class=\"k\"return/span span class=\"s2\"\"inefficient\"/spanspan class=\"p\",/span span class=\"n\"op/span\n\n        span class=\"c1\"# not inefficient, assert op into the solver and continue with the next op/span\n        span class=\"n\"solver/spanspan class=\"o\"./spanspan class=\"n\"add/spanspan class=\"p\"(/spanspan class=\"n\"z3resultvar/span span class=\"o\"==/span span class=\"n\"res/spanspan class=\"p\")/span\n    span class=\"k\"return/span span class=\"kc\"None/span span class=\"c1\"# no inefficiency found/span\n/pre/div\n\nh3 id=\"identifying-constant-booleans-with-z3\"Identifying constant booleans with Z3/h3\npTo get started finding inefficiencies in a trace, we can\nfirst focus on boolean variables. For every operation in the trace that\nreturns a bool we can ask Z3 to prove that this variable must be always True or\nalways False. Most of the time, neither of these proofs will succeed. But if Z3\nmanages to prove one of them, we know have found an ineffiency: instead of\ncomputing the boolean result (eg by executing a comparison) the JIT's optimizer\ncould have replaced the operation with the corresponding boolean constant./p\npHere's an example of an inefficiency found that way: if codex lt; y/code and codey lt; z/code are\nboth true, PyPy's JIT could conclude that codex lt; z/code must also\nbe true. However, currently the JIT cannot make that conclusion because it\nonly reasons about the concrete ranges (lower and upper bounds) for every\ninteger variable, but it has no way to remember anything about relationships\nbetween different variables. This kind of reasoning would quite often be useful\nto remove list/string bounds checks. Here's a a href=\"https://www.youtube.com/watch?app=desktopamp;v=1hm5ZVmBEvo\"talk about how LLVM does\nthis/a (but it might be\ntoo heavyweight for a JIT setting)./p\npHere are some more examples found that way:/p\nul\nlicodex - 1 == x/code is always False/li\nlicodex - (x == -1) == -1/code is always False. The pattern codex - (x == -1)/code happens a\n  lot in PyPy's hash computations: To be compatible with the CPython hashes we\n  need to make sure that no object's hash is -1 (CPython uses -1 as an error\n  value on the C level)./li\n/ul\npHere's pseudo-code for how to implement checking boolean operations for\ninefficiencies:/p\ndiv class=\"code\"pre class=\"code literal-block\"span class=\"k\"def/span span class=\"nf\"find_inefficiencies/spanspan class=\"p\"(/spanspan class=\"n\"trace/spanspan class=\"p\"):/span\n    span class=\"o\".../span\n    span class=\"k\"for/span span class=\"n\"op/span span class=\"ow\"in/span span class=\"n\"trace/spanspan class=\"p\":/span\n        span class=\"o\".../span\n        span class=\"n\"res/spanspan class=\"p\",/span span class=\"n\"valid_if/span span class=\"o\"=/span span class=\"n\"z3_expression/spanspan class=\"p\"(/spanspan class=\"n\"op/spanspan class=\"o\"./spanspan class=\"n\"name/spanspan class=\"p\",/span span class=\"n\"z3arg0/spanspan class=\"p\",/span span class=\"n\"z3arg1/spanspan class=\"p\")/span\n        span class=\"c1\"# check for boolean constant result/span\n        span class=\"k\"if/span span class=\"n\"op/spanspan class=\"o\"./spanspan class=\"n\"has_boolean_result/spanspan class=\"p\"():/span\n            span class=\"k\"if/span span class=\"n\"prove/spanspan class=\"p\"(/spanspan class=\"n\"solver/spanspan class=\"p\",/span span class=\"n\"res/span span class=\"o\"==/span span class=\"mi\"0/spanspan class=\"p\"):/span\n                span class=\"k\"return/span span class=\"s2\"\"inefficient\"/spanspan class=\"p\",/span span class=\"n\"op/spanspan class=\"p\",/span span class=\"mi\"0/span\n            span class=\"k\"if/span span class=\"n\"prove/spanspan class=\"p\"(/spanspan class=\"n\"solver/spanspan class=\"p\",/span span class=\"n\"res/span span class=\"o\"==/span span class=\"mi\"1/spanspan class=\"p\"):/span\n                span class=\"k\"return/span span class=\"s2\"\"inefficient\"/spanspan class=\"p\",/span span class=\"n\"op/spanspan class=\"p\",/span span class=\"mi\"1/span\n        span class=\"c1\"# checking for other inefficiencies, see the next sections/span\n        span class=\"o\".../span\n\n        span class=\"c1\"# not inefficient, add op to the solver and continue with the next op/span\n        span class=\"n\"solver/spanspan class=\"o\"./spanspan class=\"n\"add/spanspan class=\"p\"(/spanspan class=\"n\"z3resultvar/span span class=\"o\"==/span span class=\"n\"res/spanspan class=\"p\")/span\n    span class=\"k\"return/span span class=\"kc\"None/span span class=\"c1\"# no inefficiency found/span\n/pre/div\n\nh3 id=\"identifying-redundant-operations\"Identifying redundant operations/h3\npA more interesting class of redundancy is to try to find two operations in a\ntrace that compute the same result. We can do that by asking Z3 to prove for\neach pair of different operations in the trace to prove that the result is\nalways the same. If a previous operation returns the same result, the JIT could\nhave re-used that result instead of re-computing it, saving time. Doing this\nsearch for equivalent operations with Z3 is quadratic in the number of\noperations, but since traces have a maximum length it is not too bad in\npractice./p\npThis is the real workhorse of my script so far, it's what finds most of the\ninefficiencies. Here's a few examples:/p\nul\nliThe very first and super useful example the script found is codeint_eq(b, 1) ==\n  b/code if codeb/code is known to be a boolean (ie and integer 0 or 1). I have already\n  implemented this optimization in the JIT./li\nliSimilarly, codeint_and(b, 1) == b/code for booleans./li\nlicode(x lt;lt; 4) amp; -0xf == x lt;lt; 4/code/li\nlicode((x gt;gt; 63) lt;lt; 1) lt;lt; 2) gt;gt; 3 == x gt;gt; 63/code. In general the JIT is quite bad at\n  optimizing repeated shifts (the infrastructure for doing better with that is\n  already in place, so this will be a relatively easy fix)./li\nlicode(x amp; 0xffffffff) | ((x gt;gt; 32) lt;lt; 32) == x/code. Having the JIT optimize this\n  would maybe require first recognizing that code(x gt;gt; 32) lt;lt; 32/code can be expressed\n  as a mask: code(x amp; 0xffffffff00000000)/code, and then using code(x amp; c1) | (x amp; c2) ==\n  x amp; (c1 | c2)/code/li\nliA commonly occurring pattern is variations of this one:\n  code((x amp; 1345) ^ 2048) - 2048 == x amp; 1345/code (with different constants, of\n  course). xor is add without carry, and codex amp; 1345/code does not have the bit\n  code2048/code set. Therefore the code^ 2048/code is equivalent to code+ 2048/code, which the code-\n  2048/code cancels. More generally, if codea amp; b == 0/code, then codea + b == a | b == a ^ b/code.\n  I don't understand at all why this appears so often in the traces, but I\n  see variations of it a lot. LLVM can optimize this, but a href=\"https://gcc.gnu.org/bugzilla/show_bug.cgi?id=115829\"GCC\n  can't/a, thanks to\n  a href=\"https://hachyderm.io/@pinskia/112752641328799157\"Andrew Pinski for filing the\n  bug/a!/li\n/ul\npAnd here's some implementation pseudo-code again:/p\ndiv class=\"code\"pre class=\"code literal-block\"span class=\"k\"def/span span class=\"nf\"find_inefficiencies/spanspan class=\"p\"(/spanspan class=\"n\"trace/spanspan class=\"p\"):/span\n    span class=\"o\".../span\n    span class=\"k\"for/span span class=\"n\"op/span span class=\"ow\"in/span span class=\"n\"trace/spanspan class=\"p\":/span\n        span class=\"o\".../span\n        span class=\"n\"res/spanspan class=\"p\",/span span class=\"n\"valid_if/span span class=\"o\"=/span span class=\"n\"z3_expression/spanspan class=\"p\"(/spanspan class=\"n\"op/spanspan class=\"o\"./spanspan class=\"n\"name/spanspan class=\"p\",/span span class=\"n\"z3arg0/spanspan class=\"p\",/span span class=\"n\"z3arg1/spanspan class=\"p\")/span\n        span class=\"c1\"# check for boolean constant result/span\n        span class=\"o\".../span\n        span class=\"c1\"# searching for redundant operations/span\n        span class=\"k\"for/span span class=\"n\"previous_op/span span class=\"ow\"in/span span class=\"n\"trace/spanspan class=\"p\":/span\n            span class=\"k\"if/span span class=\"n\"previous_op/span span class=\"ow\"is/span span class=\"n\"op/spanspan class=\"p\":/span\n                span class=\"k\"break/span span class=\"c1\"# done, reached the current op/span\n            span class=\"n\"previous_op_z3var/span span class=\"o\"=/span span class=\"n\"var_to_z3var/spanspan class=\"p\"[/spanspan class=\"n\"previous_op/spanspan class=\"p\"]/span\n            span class=\"k\"if/span span class=\"n\"prove/spanspan class=\"p\"(/spanspan class=\"n\"solver/spanspan class=\"p\",/span span class=\"n\"previous_op_z3var/span span class=\"o\"==/span span class=\"n\"res/spanspan class=\"p\"):/span\n                span class=\"k\"return/span span class=\"s2\"\"inefficient\"/spanspan class=\"p\",/span span class=\"n\"op/spanspan class=\"p\",/span span class=\"n\"previous_op/span\n        span class=\"o\".../span\n        span class=\"c1\"# more code here later/span\n        span class=\"o\".../span\n\n        span class=\"c1\"# not inefficient, add op to the solver and continue with the next op/span\n        span class=\"n\"solver/spanspan class=\"o\"./spanspan class=\"n\"add/spanspan class=\"p\"(/spanspan class=\"n\"z3resultvar/span span class=\"o\"==/span span class=\"n\"res/spanspan class=\"p\")/span\n    span class=\"k\"return/span span class=\"kc\"None/span span class=\"c1\"# no inefficiency found/span\n/pre/div\n\nh3 id=\"synthesizing-more-complicated-constants-with-exists-forall\"Synthesizing more complicated constants with exists-forall/h3\npTo find out whether some integer operations always return a constant result, we\ncan't simply use the same trick as for those operations that return boolean\nresults, because enumerating 2 possible constants and checking them all\nwould take too long. Like in the last post, we can use codez3.ForAll/code to find out\nwhether Z3 can synthesize a constant for the result of an operation for us.\nIf such a constant exists, the JIT could have removed the operation,\nand replaced it with the constant that Z3 provides./p\npHere a few examples of inefficiencies found this way:/p\nul\nlicode(x ^ 1) ^ x == 1/code (or, more generally: code(x ^ y) ^ x == y/code)/li\nliif codex | y == 0/code, it follows that codex == 0/code and codey == 0/code/li\nliif codex != MAXINT/code, then codex + 1 gt; x/code/li\n/ul\npImplementing this is actually slightly annoying. The codesolver.add/code calls for\nnon-inefficient ops add assertions to the solver, which are now confusing the\ncodez3.ForAll/code query. We could remove all assertion from the solver, then do the\ncodeForAll/code query, then add the assertions back. What I ended doing instead was\ninstantiating a second solver object that I'm using for the codeForAll/code queries,\nthat remains empty the whole time./p\ndiv class=\"code\"pre class=\"code literal-block\"span class=\"k\"def/span span class=\"nf\"find_inefficiencies/spanspan class=\"p\"(/spanspan class=\"n\"trace/spanspan class=\"p\"):/span\n    span class=\"n\"solver/span span class=\"o\"=/span span class=\"n\"z3/spanspan class=\"o\"./spanspan class=\"n\"Solver/spanspan class=\"p\"()/span\n    span class=\"n\"empty_solver/span span class=\"o\"=/span span class=\"n\"z3/spanspan class=\"o\"./spanspan class=\"n\"Solver/spanspan class=\"p\"()/span\n    span class=\"n\"var_to_z3var/span span class=\"o\"=/span span class=\"p\"{}/span\n    span class=\"o\".../span\n    span class=\"k\"for/span span class=\"n\"op/span span class=\"ow\"in/span span class=\"n\"trace/spanspan class=\"p\":/span\n        span class=\"o\".../span\n        span class=\"n\"res/spanspan class=\"p\",/span span class=\"n\"valid_if/span span class=\"o\"=/span span class=\"n\"z3_expression/spanspan class=\"p\"(/spanspan class=\"n\"op/spanspan class=\"o\"./spanspan class=\"n\"name/spanspan class=\"p\",/span span class=\"n\"z3arg0/spanspan class=\"p\",/span span class=\"n\"z3arg1/spanspan class=\"p\")/span\n        span class=\"c1\"# check for boolean constant result/span\n        span class=\"o\".../span\n        span class=\"c1\"# searching for redundant operations/span\n        span class=\"o\".../span\n        span class=\"c1\"# checking for constant results/span\n        span class=\"n\"constvar/span span class=\"o\"=/span span class=\"n\"z3/spanspan class=\"o\"./spanspan class=\"n\"BitVec/spanspan class=\"p\"(/spanspan class=\"s1\"'find_const'/spanspan class=\"p\",/span span class=\"n\"INTEGER_WIDTH/spanspan class=\"p\")/span\n        span class=\"n\"condition/span span class=\"o\"=/span span class=\"n\"z3/spanspan class=\"o\"./spanspan class=\"n\"ForAll/spanspan class=\"p\"(/span\n            span class=\"n\"var_to_z3var/spanspan class=\"o\"./spanspan class=\"n\"values/spanspan class=\"p\"(),/span\n            span class=\"n\"z3/spanspan class=\"o\"./spanspan class=\"n\"Implies/spanspan class=\"p\"(/span\n                span class=\"o\"*/spanspan class=\"n\"solver/spanspan class=\"o\"./spanspan class=\"n\"assertions/spanspan class=\"p\"(),/span\n                span class=\"n\"expr/span span class=\"o\"==/span span class=\"n\"constvar/span\n            span class=\"p\")/span\n        span class=\"p\")/span\n        span class=\"k\"if/span span class=\"n\"empty_solver/spanspan class=\"o\"./spanspan class=\"n\"check/spanspan class=\"p\"(/spanspan class=\"n\"condition/spanspan class=\"p\")/span span class=\"o\"==/span span class=\"n\"z3/spanspan class=\"o\"./spanspan class=\"n\"sat/spanspan class=\"p\":/span\n            span class=\"n\"model/span span class=\"o\"=/span span class=\"n\"empty_solver/spanspan class=\"o\"./spanspan class=\"n\"model/spanspan class=\"p\"()/span\n            span class=\"n\"const/span span class=\"o\"=/span span class=\"n\"model/spanspan class=\"p\"[/spanspan class=\"n\"constvar/spanspan class=\"p\"]/spanspan class=\"o\"./spanspan class=\"n\"as_signed_long/spanspan class=\"p\"()/span\n            span class=\"k\"return/span span class=\"s2\"\"inefficient\"/spanspan class=\"p\",/span span class=\"n\"op/spanspan class=\"p\",/span span class=\"n\"const/span\n\n        span class=\"c1\"# not inefficient, add op to the solver and continue with the next op/span\n        span class=\"n\"solver/spanspan class=\"o\"./spanspan class=\"n\"add/spanspan class=\"p\"(/spanspan class=\"n\"z3resultvar/span span class=\"o\"==/span span class=\"n\"res/spanspan class=\"p\")/span\n    span class=\"k\"return/span span class=\"kc\"None/span span class=\"c1\"# no inefficiency found/span\n/pre/div\n\nh3 id=\"minimization\"Minimization/h3\npAnalyzing an inefficiency by hand in the context of a larger trace is quite\ntedious. Therefore I've implemented a (super inefficient) script to try to make\nthe examples smaller. Here's how that works:/p\nul\nliFirst throw out all the operations that occur emafter/em the inefficient operation\n  in the trace./li\nliThen we remove all \"dead\" operations, ie operations that don't have their\n  results used (all the operations that we can analyze with Z3 are without side\n  effects)./li\nliNow we try to remove every guard in the trace one by one and check\n  afterwards, whether the resulting trace still has an inefficiency./li\nliWe also try to replace every single operation with a new argument to the\n  trace, to see whether the inefficiency is still present./li\n/ul\npThe minimization process is sort of inefficient and I should probably be using\n a href=\"https://github.com/DRMacIver/shrinkray\"shrinkray/a or\n a href=\"https://github.com/csmith-project/creduce\"C-Reduce/a instead. However, it\n seems to work well in practice and the runtime isn't too bad./p\nh3 id=\"results\"Results/h3\npSo far I am using the JIT traces of three programs: 1) Booting Linux on the\na href=\"https://docs.pydrofoil.org\"Pydrofoil/a RISC-V emulator, 2) booting Linux on the Pydrofoil ARM emulator, and 3)\nrunning the PyPy bootstrap process on top of PyPy./p\npI picked these programs because most Python programs don't contain interesting\namounts of integer operations, and the traces of the emulators\ncontain a lot of them. I also used the bootstrap process because I still wanted\nto try a big Python program and personally care about the runtime of this\nprogram a lot./p\npThe script identifies 94\ninefficiencies in the traces, a lot of them come from repeating\npatterns. My next steps will be to manually inspect them all, categorize them, and\nimplement easy optimizations identified that way. I also want a way to sort the\nexamples by execution count in the benchmarks, to get a feeling for which of\nthem are most important./p\npI didn't investigate the full set of a href=\"https://speed.pypy.org\"Python\nbenchmarks/a that PyPy uses yet, because I don't expect\nthem to contain interesting amounts of integer operations, but maybe I am wrong\nabout that? Will have to try eventually./p\nh3 id=\"conclusion\"Conclusion/h3\npThis was again much easier to do than I would have expected! Given that I had\nthe translation of trace ops to Z3 already in place, it was a matter of about a\nday's of programming to use this infrastructure to find the first problems and\nminimizing them./p\npReusing the results of existing operations or replacing operations by constants\ncan be seen as \"zero-instruction superoptimization\". I'll probably be rather\nbusy for a while to add the missing optimizations identified by my simple\nscript. But later extensions to actually synthesize one or several operations\nin the attempt to optimize the traces more and find more opportunities should\nbe possible./p\npFinding inefficiencies in traces with Z3 is significantly less\nannoying and also less error-prone than just manually inspecting traces and\ntrying to spot optimization opportunities./p\nh3 id=\"random-notes-and-sources\"Random Notes and Sources/h3\npAgain, John's blog posts:/p\nul\nlia href=\"https://blog.regehr.org/archives/1109\"Lets Work on an LLVM Superoptimizer/a/li\nlia href=\"https://blog.regehr.org/archives/1146\"Early Superoptimizer Results/a/li\nlia href=\"https://blog.regehr.org/archives/1252\"A Few Synthesizing Superoptimizer Results/a/li\nlia href=\"https://blog.regehr.org/archives/1636\"Synthesizing Constants/a/li\n/ul\npand papers:/p\nul\nlia href=\"https://arxiv.org/pdf/1711.04422\"A Synthesizing Superoptimizer/a/li\nlia href=\"https://dl.acm.org/doi/pdf/10.1145/3649837\"Hydra: Generalizing Peephole Optimizations with Program Synthesis/a/li\n/ul\npI remembered recently that I had seen the approach of optimizing the traces of\na tracing JIT with Z3 a long time ago, as part of the (now long dead, I think)\na href=\"https://web.archive.org/web/20160304055149/http://research.microsoft.com/en-us/projects/spur/\"SPUR\nproject/a.\nThere's a a href=\"https://web.archive.org/web/20161029162737/http://csl.stanford.edu/~christos/pldi2010.fit/tillmann.provers4jit.pdf\"workshop\npaper/a\nfrom 2010 about this. SPUR was trying to use Z3 built into the actual JIT (as\nopposed to using Z3 only to find places where the regular optimizers could be\nimproved). In addition to bitvectors, SPUR also used the Z3 support for arrays\nto model the C# heap and remove redundant stores. This is still another future\nextension for all the Z3 work I've been doing in the context of the PyPy JIT./p",
      "link": "https://www.pypy.org/posts/2024/07/mining-jit-traces-missing-optimizations-z3.html",
      "links": [],
      "published": "2024-07-19T17:01:09+00:00",
      "summary": "",
      "title": "Mining JIT traces for missing optimizations with Z3"
    },
    {
      "author": "CF Bolz-Tereick",
      "content": [
        {
          "type": "text/html",
          "value": "pIn June I was at the a href=\"https://pldi24.sigplan.org/\"PLDI conference/a in\nCopenhagen to present a a href=\"https://dl.acm.org/doi/10.1145/3652588.3663316\"paper/a\nI co-authored with a href=\"https://bernsteinbear.com/\"Max Bernstein/a. I also finally\nmet a href=\"https://blog.regehr.org/\"John Regehr/a, who I'd been talking on social\nmedia for ages but had never met. John has been working on compiler correctness\nand better techniques for building compilers and optimizers since a very long\ntime. The blog post a href=\"https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html\"Finding JIT Optimizer Bugs using SMT Solvers and\nFuzzing/a\nwas heavily inspired by this work. We talked a lot about his and his groups\nwork on using Z3 for\na href=\"https://en.wikipedia.org/wiki/Superoptimization\"superoptimization/a and for\nfinding missing optimizations. I have applied some of the things John told me\nabout to the traces of PyPy's JIT, and wanted to blog about that. However, my\ndraft felt quite hard to understand. Therefore I have now written this current\npost, to at least try to provide a somewhat gentler on-ramp to the topic./p\npIn emthis/em post we will use the Python-API to Z3 to find local peephole rewrite\nrules for the operations in the intermediate representation of PyPy's tracing\nJIT. The code for this is simple enough that we can go through all of it./p\npThe PyPy JIT produces traces of machine level instructions, which are optimized\nand then turned into machine code. The optimizer uses a number of approaches to\nmake the traces more efficient. For integer operations it applies a number of\narithmetic simplification rules rules, for example codeint_add(x, 0) -gt; x/code. When\nimplementing these rules in the JIT there are strongtwo problems/strong: How do we know\nthat the rules are correct? And how do we know that we haven't forgotten any\nrules? We'll try to answer both of these, but the first one in particular./p\npWe'll be using Z3, a satisfiability module theories (SMT) solver which has good\nbitvector support and most importantly an excellent Python API. We can use the\nsolver to reason about bitvectors, which are how we will model machine\nintegers./p\npTo find rewrite rules, we will consider the binary operations (i.e. those\ntaking two arguments) in PyPy traces that take and produce integers. The\ncompletely general form codeop(x, y)/code is not simplifiable on its own. But if\neither codex == y/code\nor if one of the arguments is a constant, we can potentially simplify the\noperation into a simpler form. The results are either the variable codex/code, or a\n(potentially different) constant. We'll ignore constant-folding where both\narguments of the binary operation are constants. The possible results for a\nsimplifiable binary operation are the variable codex/code or another constant. This\nleaves the following patterns as possibilities:/p\nul\nlicodeop(x, x) == x/code/li\nlicodeop(x, x) == c1/code/li\nlicodeop(x, c1) == x/code/li\nlicodeop(c1, x) == x/code/li\nlicodeop(x, c1) == c2/code/li\nlicodeop(c1, x) == c2/code/li\n/ul\npOur approach will be to take every single supported binary integer operation,\ninstantiate all of these patterns, and try to ask Z3 whether the resulting\nsimplification is valid for all values of codex/code./p\nh3 id=\"quick-intro-to-the-z3-python-api\"Quick intro to the Z3 Python-API/h3\npHere's a terminal session showing the use of the Z3 Python API:/p\ndiv class=\"code\"pre class=\"code literal-block\"span class=\"go\"gt;gt;gt;gt; import z3/span\nspan class=\"go\"gt;gt;gt;gt; # construct a Z3 bitvector variable of width 8, with name x:/span\nspan class=\"go\"gt;gt;gt;gt; x = z3.BitVec('x', 8)/span\nspan class=\"go\"gt;gt;gt;gt; # construct a more complicated formula by using operator overloading:/span\nspan class=\"go\"gt;gt;gt;gt; x + x/span\nspan class=\"go\"x + x/span\nspan class=\"go\"gt;gt;gt;gt; x + 1/span\nspan class=\"go\"x + 1/span\n/pre/div\n\npZ3 checks the \"satisfiability\" of a formula. This means that it tries to find\nan example set of concrete values for the variables that occur in a formula,\nsuch that the formula becomes true. Examples:/p\ndiv class=\"code\"pre class=\"code literal-block\"span class=\"go\"gt;gt;gt;gt; solver = z3.Solver()/span\nspan class=\"go\"gt;gt;gt;gt; solver.check(x * x == 3)/span\nspan class=\"go\"unsat/span\nspan class=\"go\"gt;gt;gt;gt; # meaning no x fulfils this property/span\nspan class=\"go\"gt;gt;gt;gt;/span\nspan class=\"go\"gt;gt;gt;gt; solver.check(x * x == 9)/span\nspan class=\"go\"sat/span\nspan class=\"go\"gt;gt;gt;gt; model = solver.model()/span\nspan class=\"go\"gt;gt;gt;gt; model/span\nspan class=\"go\"[x = 253]/span\nspan class=\"go\"gt;gt;gt;gt; model[x].as_signed_long()/span\nspan class=\"go\"-3/span\nspan class=\"go\"gt;gt;gt;gt; # 253 is the same as -3 in two's complement arithmetic with 8 bits/span\n/pre/div\n\npIn order to use Z3 to prove something, we can ask Z3 to find counterexamples\nfor the statement, meaning concrete values that would make the negation of the\nstatement true:/p\ndiv class=\"code\"pre class=\"code literal-block\"span class=\"go\"gt;gt;gt;gt; solver.check(z3.Not(x ^ -1 == ~x))/span\nspan class=\"go\"unsat/span\n/pre/div\n\npThe result codeunsat/code means that we just proved that codex ^ -1 == ~x/code is true for\nall codex/code, because there is no value for codex/code that makes codenot (x ^ -1 == ~x)/code\ntrue (this works because -1 has all the bits set)./p\npIf we try to prove something incorrect in this way, the following happens:/p\ndiv class=\"code\"pre class=\"code literal-block\"span class=\"go\"gt;gt;gt;gt; solver.check(z3.Not(x ^ -1 == x))/span\nspan class=\"go\"sat/span\n/pre/div\n\npcodesat/code shows that codex ^ -1 == x/code is (unsurprisingly) not always true, and we can\nask for a counterexample:/p\ndiv class=\"code\"pre class=\"code literal-block\"span class=\"go\"gt;gt;gt;gt; solver.model()/span\nspan class=\"go\"[x = 0]/span\n/pre/div\n\npThis way of proving this works because the codecheck/code calls try to solve an\n(implicit) \"exists\" quantifier, over all the Z3 variables used in the formula.\ncodecheck/code will either return codez3.unsat/code, which means that no concrete values make\nthe formula true; or codez3.sat/code, which means that you can get some concrete\nvalues that make the formula true by calling codesolver.model()/code./p\npIn math terms we prove things using codecheck/code by de-Morgan's rules for quantifiers:/p\np$$ \\lnot \\exists x: \\lnot f(x) \\implies \\forall x: f(x) $$/p\npNow that we've seen the basics of using the Z3 API on a few small examples,\nwe'll use it in a bigger program./p\nh3 id=\"encoding-the-integer-operations-of-rpythons-jit-into-z3-formulas\"Encoding the integer operations of RPython's JIT into Z3 formulas/h3\npNow we'll use the API to reason about the integer operations of the PyPy JIT\nintermediate representation (IR). The binary integer operations are:/p\ndiv class=\"code\"pre class=\"code literal-block\"span class=\"n\"opnames2/span span class=\"o\"=/span span class=\"p\"[/span\nspan class=\"s2\"\"int_add\"/spanspan class=\"p\",/span\nspan class=\"s2\"\"int_sub\"/spanspan class=\"p\",/span\nspan class=\"s2\"\"int_mul\"/spanspan class=\"p\",/span\nspan class=\"s2\"\"int_and\"/spanspan class=\"p\",/span\nspan class=\"s2\"\"int_or\"/spanspan class=\"p\",/span\nspan class=\"s2\"\"int_xor\"/spanspan class=\"p\",/span\nspan class=\"s2\"\"int_eq\"/spanspan class=\"p\",/span\nspan class=\"s2\"\"int_ne\"/spanspan class=\"p\",/span\nspan class=\"s2\"\"int_lt\"/spanspan class=\"p\",/span\nspan class=\"s2\"\"int_le\"/spanspan class=\"p\",/span\nspan class=\"s2\"\"int_gt\"/spanspan class=\"p\",/span\nspan class=\"s2\"\"int_ge\"/spanspan class=\"p\",/span\nspan class=\"s2\"\"uint_lt\"/spanspan class=\"p\",/span\nspan class=\"s2\"\"uint_le\"/spanspan class=\"p\",/span\nspan class=\"s2\"\"uint_gt\"/spanspan class=\"p\",/span\nspan class=\"s2\"\"uint_ge\"/spanspan class=\"p\",/span\nspan class=\"s2\"\"int_lshift\"/spanspan class=\"p\",/span\nspan class=\"s2\"\"int_rshift\"/spanspan class=\"p\",/span\nspan class=\"s2\"\"uint_rshift\"/spanspan class=\"p\",/span\nspan class=\"s2\"\"uint_mul_high\"/spanspan class=\"p\",/span\nspan class=\"s2\"\"int_pydiv\"/spanspan class=\"p\",/span\nspan class=\"s2\"\"int_pymod\"/spanspan class=\"p\",/span\nspan class=\"p\"]/span\n/pre/div\n\npThere's not much special about the integer operations. Like in LLVM, most of\nthem are signedness-independent: codeint_add/code, codeint_sub/code, codeint_mul/code, ... work\ncorrectly for unsigned integers but also for\na href=\"https://en.wikipedia.org/wiki/Two%27s_complement\"two's-complement/a signed\nintegers. Exceptions for that are order comparisons like codeint_lt/code etc. for\nwhich we have unsigned variants codeuint_lt/code etc. All operations that produce a\nboolean result return a full-width integer code0/code or code1/code (the PyPy JIT supports\nonly word-sized integers in its intermediate representation)/p\npIn order to reason about the IR operations, some ground work:/p\ndiv class=\"code\"pre class=\"code literal-block\"span class=\"kn\"import/span span class=\"nn\"z3/span\n\nspan class=\"n\"INTEGER_WIDTH/span span class=\"o\"=/span span class=\"mi\"64/span\nspan class=\"n\"solver/span span class=\"o\"=/span span class=\"n\"z3/spanspan class=\"o\"./spanspan class=\"n\"Solver/spanspan class=\"p\"()/span\nspan class=\"n\"solver/spanspan class=\"o\"./spanspan class=\"n\"set/spanspan class=\"p\"(/spanspan class=\"s2\"\"timeout\"/spanspan class=\"p\",/span span class=\"mi\"10000/spanspan class=\"p\")/span span class=\"c1\"# milliseconds, ie 10s/span\nspan class=\"n\"xvar/span span class=\"o\"=/span span class=\"n\"z3/spanspan class=\"o\"./spanspan class=\"n\"BitVec/spanspan class=\"p\"(/spanspan class=\"s1\"'x'/spanspan class=\"p\",/span span class=\"n\"INTEGER_WIDTH/spanspan class=\"p\")/span\nspan class=\"n\"constvar/span span class=\"o\"=/span span class=\"n\"z3/spanspan class=\"o\"./spanspan class=\"n\"BitVec/spanspan class=\"p\"(/spanspan class=\"s1\"'const'/spanspan class=\"p\",/span span class=\"n\"INTEGER_WIDTH/spanspan class=\"p\")/span\nspan class=\"n\"constvar2/span span class=\"o\"=/span span class=\"n\"z3/spanspan class=\"o\"./spanspan class=\"n\"BitVec/spanspan class=\"p\"(/spanspan class=\"s1\"'const2'/spanspan class=\"p\",/span span class=\"n\"INTEGER_WIDTH/spanspan class=\"p\")/span\nspan class=\"n\"TRUEBV/span span class=\"o\"=/span span class=\"n\"z3/spanspan class=\"o\"./spanspan class=\"n\"BitVecVal/spanspan class=\"p\"(/spanspan class=\"mi\"1/spanspan class=\"p\",/span span class=\"n\"INTEGER_WIDTH/spanspan class=\"p\")/span\nspan class=\"n\"FALSEBV/span span class=\"o\"=/span span class=\"n\"z3/spanspan class=\"o\"./spanspan class=\"n\"BitVecVal/spanspan class=\"p\"(/spanspan class=\"mi\"0/spanspan class=\"p\",/span span class=\"n\"INTEGER_WIDTH/spanspan class=\"p\")/span\n/pre/div\n\npAnd here's the a function to turn an integer IR operation of PyPy's JIT into Z3\nformulas:/p\ndiv class=\"code\"pre class=\"code literal-block\"span class=\"k\"def/span span class=\"nf\"z3_expression/spanspan class=\"p\"(/spanspan class=\"n\"opname/spanspan class=\"p\",/span span class=\"n\"arg0/spanspan class=\"p\",/span span class=\"n\"arg1/spanspan class=\"o\"=/spanspan class=\"kc\"None/spanspan class=\"p\"):/span\nspan class=\"w\"    /spanspan class=\"sd\"\"\"\" computes a tuple of (result, valid_if) of Z3 formulas. `result` is the/span\nspan class=\"sd\"    formula representing the result of the operation, given argument formulas/span\nspan class=\"sd\"    arg0 and arg1. `valid_if` is a pre-condition that must be true for the/span\nspan class=\"sd\"    result to be meaningful. \"\"\"/span\n    span class=\"n\"result/span span class=\"o\"=/span span class=\"kc\"None/span\n    span class=\"n\"valid_if/span span class=\"o\"=/span span class=\"kc\"True/span span class=\"c1\"# the precondition is mostly True, with few exceptions/span\n    span class=\"k\"if/span span class=\"n\"opname/span span class=\"o\"==/span span class=\"s2\"\"int_add\"/spanspan class=\"p\":/span\n        span class=\"n\"result/span span class=\"o\"=/span span class=\"n\"arg0/span span class=\"o\"+/span span class=\"n\"arg1/span\n    span class=\"k\"elif/span span class=\"n\"opname/span span class=\"o\"==/span span class=\"s2\"\"int_sub\"/spanspan class=\"p\":/span\n        span class=\"n\"result/span span class=\"o\"=/span span class=\"n\"arg0/span span class=\"o\"-/span span class=\"n\"arg1/span\n    span class=\"k\"elif/span span class=\"n\"opname/span span class=\"o\"==/span span class=\"s2\"\"int_mul\"/spanspan class=\"p\":/span\n        span class=\"n\"result/span span class=\"o\"=/span span class=\"n\"arg0/span span class=\"o\"*/span span class=\"n\"arg1/span\n    span class=\"k\"elif/span span class=\"n\"opname/span span class=\"o\"==/span span class=\"s2\"\"int_and\"/spanspan class=\"p\":/span\n        span class=\"n\"result/span span class=\"o\"=/span span class=\"n\"arg0/span span class=\"o\"amp;/span span class=\"n\"arg1/span\n    span class=\"k\"elif/span span class=\"n\"opname/span span class=\"o\"==/span span class=\"s2\"\"int_or\"/spanspan class=\"p\":/span\n        span class=\"n\"result/span span class=\"o\"=/span span class=\"n\"arg0/span span class=\"o\"|/span span class=\"n\"arg1/span\n    span class=\"k\"elif/span span class=\"n\"opname/span span class=\"o\"==/span span class=\"s2\"\"int_xor\"/spanspan class=\"p\":/span\n        span class=\"n\"result/span span class=\"o\"=/span span class=\"n\"arg0/span span class=\"o\"^/span span class=\"n\"arg1/span\n    span class=\"k\"elif/span span class=\"n\"opname/span span class=\"o\"==/span span class=\"s2\"\"int_eq\"/spanspan class=\"p\":/span\n        span class=\"n\"result/span span class=\"o\"=/span span class=\"n\"cond/spanspan class=\"p\"(/spanspan class=\"n\"arg0/span span class=\"o\"==/span span class=\"n\"arg1/spanspan class=\"p\")/span\n    span class=\"k\"elif/span span class=\"n\"opname/span span class=\"o\"==/span span class=\"s2\"\"int_ne\"/spanspan class=\"p\":/span\n        span class=\"n\"result/span span class=\"o\"=/span span class=\"n\"cond/spanspan class=\"p\"(/spanspan class=\"n\"arg0/span span class=\"o\"!=/span span class=\"n\"arg1/spanspan class=\"p\")/span\n    span class=\"k\"elif/span span class=\"n\"opname/span span class=\"o\"==/span span class=\"s2\"\"int_lt\"/spanspan class=\"p\":/span\n        span class=\"n\"result/span span class=\"o\"=/span span class=\"n\"cond/spanspan class=\"p\"(/spanspan class=\"n\"arg0/span span class=\"o\"lt;/span span class=\"n\"arg1/spanspan class=\"p\")/span\n    span class=\"k\"elif/span span class=\"n\"opname/span span class=\"o\"==/span span class=\"s2\"\"int_le\"/spanspan class=\"p\":/span\n        span class=\"n\"result/span span class=\"o\"=/span span class=\"n\"cond/spanspan class=\"p\"(/spanspan class=\"n\"arg0/span span class=\"o\"lt;=/span span class=\"n\"arg1/spanspan class=\"p\")/span\n    span class=\"k\"elif/span span class=\"n\"opname/span span class=\"o\"==/span span class=\"s2\"\"int_gt\"/spanspan class=\"p\":/span\n        span class=\"n\"result/span span class=\"o\"=/span span class=\"n\"cond/spanspan class=\"p\"(/spanspan class=\"n\"arg0/span span class=\"o\"gt;/span span class=\"n\"arg1/spanspan class=\"p\")/span\n    span class=\"k\"elif/span span class=\"n\"opname/span span class=\"o\"==/span span class=\"s2\"\"int_ge\"/spanspan class=\"p\":/span\n        span class=\"n\"result/span span class=\"o\"=/span span class=\"n\"cond/spanspan class=\"p\"(/spanspan class=\"n\"arg0/span span class=\"o\"gt;=/span span class=\"n\"arg1/spanspan class=\"p\")/span\n    span class=\"k\"elif/span span class=\"n\"opname/span span class=\"o\"==/span span class=\"s2\"\"uint_lt\"/spanspan class=\"p\":/span\n        span class=\"n\"result/span span class=\"o\"=/span span class=\"n\"cond/spanspan class=\"p\"(/spanspan class=\"n\"z3/spanspan class=\"o\"./spanspan class=\"n\"ULT/spanspan class=\"p\"(/spanspan class=\"n\"arg0/spanspan class=\"p\",/span span class=\"n\"arg1/spanspan class=\"p\"))/span\n    span class=\"k\"elif/span span class=\"n\"opname/span span class=\"o\"==/span span class=\"s2\"\"uint_le\"/spanspan class=\"p\":/span\n        span class=\"n\"result/span span class=\"o\"=/span span class=\"n\"cond/spanspan class=\"p\"(/spanspan class=\"n\"z3/spanspan class=\"o\"./spanspan class=\"n\"ULE/spanspan class=\"p\"(/spanspan class=\"n\"arg0/spanspan class=\"p\",/span span class=\"n\"arg1/spanspan class=\"p\"))/span\n    span class=\"k\"elif/span span class=\"n\"opname/span span class=\"o\"==/span span class=\"s2\"\"uint_gt\"/spanspan class=\"p\":/span\n        span class=\"n\"result/span span class=\"o\"=/span span class=\"n\"cond/spanspan class=\"p\"(/spanspan class=\"n\"z3/spanspan class=\"o\"./spanspan class=\"n\"UGT/spanspan class=\"p\"(/spanspan class=\"n\"arg0/spanspan class=\"p\",/span span class=\"n\"arg1/spanspan class=\"p\"))/span\n    span class=\"k\"elif/span span class=\"n\"opname/span span class=\"o\"==/span span class=\"s2\"\"uint_ge\"/spanspan class=\"p\":/span\n        span class=\"n\"result/span span class=\"o\"=/span span class=\"n\"cond/spanspan class=\"p\"(/spanspan class=\"n\"z3/spanspan class=\"o\"./spanspan class=\"n\"UGE/spanspan class=\"p\"(/spanspan class=\"n\"arg0/spanspan class=\"p\",/span span class=\"n\"arg1/spanspan class=\"p\"))/span\n    span class=\"k\"elif/span span class=\"n\"opname/span span class=\"o\"==/span span class=\"s2\"\"int_lshift\"/spanspan class=\"p\":/span\n        span class=\"n\"result/span span class=\"o\"=/span span class=\"n\"arg0/span span class=\"o\"lt;lt;/span span class=\"n\"arg1/span\n        span class=\"n\"valid_if/span span class=\"o\"=/span span class=\"n\"z3/spanspan class=\"o\"./spanspan class=\"n\"And/spanspan class=\"p\"(/spanspan class=\"n\"arg1/span span class=\"o\"gt;=/span span class=\"mi\"0/spanspan class=\"p\",/span span class=\"n\"arg1/span span class=\"o\"lt;/span span class=\"n\"INTEGER_WIDTH/spanspan class=\"p\")/span\n    span class=\"k\"elif/span span class=\"n\"opname/span span class=\"o\"==/span span class=\"s2\"\"int_rshift\"/spanspan class=\"p\":/span\n        span class=\"n\"result/span span class=\"o\"=/span span class=\"n\"arg0/span span class=\"o\"lt;lt;/span span class=\"n\"arg1/span\n        span class=\"n\"valid_if/span span class=\"o\"=/span span class=\"n\"z3/spanspan class=\"o\"./spanspan class=\"n\"And/spanspan class=\"p\"(/spanspan class=\"n\"arg1/span span class=\"o\"gt;=/span span class=\"mi\"0/spanspan class=\"p\",/span span class=\"n\"arg1/span span class=\"o\"lt;/span span class=\"n\"INTEGER_WIDTH/spanspan class=\"p\")/span\n    span class=\"k\"elif/span span class=\"n\"opname/span span class=\"o\"==/span span class=\"s2\"\"uint_rshift\"/spanspan class=\"p\":/span\n        span class=\"n\"result/span span class=\"o\"=/span span class=\"n\"z3/spanspan class=\"o\"./spanspan class=\"n\"LShR/spanspan class=\"p\"(/spanspan class=\"n\"arg0/spanspan class=\"p\",/span span class=\"n\"arg1/spanspan class=\"p\")/span\n        span class=\"n\"valid_if/span span class=\"o\"=/span span class=\"n\"z3/spanspan class=\"o\"./spanspan class=\"n\"And/spanspan class=\"p\"(/spanspan class=\"n\"arg1/span span class=\"o\"gt;=/span span class=\"mi\"0/spanspan class=\"p\",/span span class=\"n\"arg1/span span class=\"o\"lt;/span span class=\"n\"INTEGER_WIDTH/spanspan class=\"p\")/span\n    span class=\"k\"elif/span span class=\"n\"opname/span span class=\"o\"==/span span class=\"s2\"\"uint_mul_high\"/spanspan class=\"p\":/span\n        span class=\"c1\"# zero-extend args to 2*INTEGER_WIDTH bit, then multiply and extract/span\n        span class=\"c1\"# highest INTEGER_WIDTH bits/span\n        span class=\"n\"zarg0/span span class=\"o\"=/span span class=\"n\"z3/spanspan class=\"o\"./spanspan class=\"n\"ZeroExt/spanspan class=\"p\"(/spanspan class=\"n\"INTEGER_WIDTH/spanspan class=\"p\",/span span class=\"n\"arg0/spanspan class=\"p\")/span\n        span class=\"n\"zarg1/span span class=\"o\"=/span span class=\"n\"z3/spanspan class=\"o\"./spanspan class=\"n\"ZeroExt/spanspan class=\"p\"(/spanspan class=\"n\"INTEGER_WIDTH/spanspan class=\"p\",/span span class=\"n\"arg1/spanspan class=\"p\")/span\n        span class=\"n\"result/span span class=\"o\"=/span span class=\"n\"z3/spanspan class=\"o\"./spanspan class=\"n\"Extract/spanspan class=\"p\"(/spanspan class=\"n\"INTEGER_WIDTH/span span class=\"o\"*/span span class=\"mi\"2/span span class=\"o\"-/span span class=\"mi\"1/spanspan class=\"p\",/span span class=\"n\"INTEGER_WIDTH/spanspan class=\"p\",/span span class=\"n\"zarg0/span span class=\"o\"*/span span class=\"n\"zarg1/spanspan class=\"p\")/span\n    span class=\"k\"elif/span span class=\"n\"opname/span span class=\"o\"==/span span class=\"s2\"\"int_pydiv\"/spanspan class=\"p\":/span\n        span class=\"n\"valid_if/span span class=\"o\"=/span span class=\"n\"arg1/span span class=\"o\"!=/span span class=\"mi\"0/span\n        span class=\"n\"r/span span class=\"o\"=/span span class=\"n\"arg0/span span class=\"o\"//span span class=\"n\"arg1/span\n        span class=\"n\"psubx/span span class=\"o\"=/span span class=\"n\"r/span span class=\"o\"*/span span class=\"n\"arg1/span span class=\"o\"-/span span class=\"n\"arg0/span\n        span class=\"n\"result/span span class=\"o\"=/span span class=\"n\"r/span span class=\"o\"+/span span class=\"p\"(/spanspan class=\"n\"z3/spanspan class=\"o\"./spanspan class=\"n\"If/spanspan class=\"p\"(/spanspan class=\"n\"arg1/span span class=\"o\"lt;/span span class=\"mi\"0/spanspan class=\"p\",/span span class=\"n\"psubx/spanspan class=\"p\",/span span class=\"o\"-/spanspan class=\"n\"psubx/spanspan class=\"p\")/span span class=\"o\"gt;gt;/span span class=\"p\"(/spanspan class=\"n\"INTEGER_WIDTH/span span class=\"o\"-/span span class=\"mi\"1/spanspan class=\"p\"))/span\n    span class=\"k\"elif/span span class=\"n\"opname/span span class=\"o\"==/span span class=\"s2\"\"int_pymod\"/spanspan class=\"p\":/span\n        span class=\"n\"valid_if/span span class=\"o\"=/span span class=\"n\"arg1/span span class=\"o\"!=/span span class=\"mi\"0/span\n        span class=\"n\"r/span span class=\"o\"=/span span class=\"n\"arg0/span span class=\"o\"%/span span class=\"n\"arg1/span\n        span class=\"n\"result/span span class=\"o\"=/span span class=\"n\"r/span span class=\"o\"+/span span class=\"p\"(/spanspan class=\"n\"arg1/span span class=\"o\"amp;/span span class=\"n\"z3/spanspan class=\"o\"./spanspan class=\"n\"If/spanspan class=\"p\"(/spanspan class=\"n\"arg1/span span class=\"o\"lt;/span span class=\"mi\"0/spanspan class=\"p\",/span span class=\"o\"-/spanspan class=\"n\"r/spanspan class=\"p\",/span span class=\"n\"r/spanspan class=\"p\")/span span class=\"o\"gt;gt;/span span class=\"p\"(/spanspan class=\"n\"INTEGER_WIDTH/span span class=\"o\"-/span span class=\"mi\"1/spanspan class=\"p\"))/span\n    span class=\"k\"elif/span span class=\"n\"opname/span span class=\"o\"==/span span class=\"s2\"\"int_is_true\"/spanspan class=\"p\":/span\n        span class=\"n\"result/span span class=\"o\"=/span span class=\"n\"cond/spanspan class=\"p\"(/spanspan class=\"n\"arg0/span span class=\"o\"!=/span span class=\"n\"FALSEBV/spanspan class=\"p\")/span\n    span class=\"k\"elif/span span class=\"n\"opname/span span class=\"o\"==/span span class=\"s2\"\"int_is_zero\"/spanspan class=\"p\":/span\n        span class=\"n\"result/span span class=\"o\"=/span span class=\"n\"cond/spanspan class=\"p\"(/spanspan class=\"n\"arg0/span span class=\"o\"==/span span class=\"n\"FALSEBV/spanspan class=\"p\")/span\n    span class=\"k\"elif/span span class=\"n\"opname/span span class=\"o\"==/span span class=\"s2\"\"int_neg\"/spanspan class=\"p\":/span\n        span class=\"n\"result/span span class=\"o\"=/span span class=\"o\"-/spanspan class=\"n\"arg0/span\n    span class=\"k\"elif/span span class=\"n\"opname/span span class=\"o\"==/span span class=\"s2\"\"int_invert\"/spanspan class=\"p\":/span\n        span class=\"n\"result/span span class=\"o\"=/span span class=\"o\"~/spanspan class=\"n\"arg0/span\n    span class=\"k\"else/spanspan class=\"p\":/span\n        span class=\"k\"assert/span span class=\"mi\"0/spanspan class=\"p\",/span span class=\"s2\"\"unknown operation \"/span span class=\"o\"+/span span class=\"n\"opname/span\n    span class=\"k\"return/span span class=\"n\"result/spanspan class=\"p\",/span span class=\"n\"valid_if/span\n\nspan class=\"k\"def/span span class=\"nf\"cond/spanspan class=\"p\"(/spanspan class=\"n\"z3expr/spanspan class=\"p\"):/span\nspan class=\"w\"    /spanspan class=\"sd\"\"\"\" helper function to turn a Z3 boolean result z3expr into a 1 or 0/span\nspan class=\"sd\"    bitvector, using z3.If \"\"\"/span\n    span class=\"k\"return/span span class=\"n\"z3/spanspan class=\"o\"./spanspan class=\"n\"If/spanspan class=\"p\"(/spanspan class=\"n\"z3expr/spanspan class=\"p\",/span span class=\"n\"TRUEBV/spanspan class=\"p\",/span span class=\"n\"FALSEBV/spanspan class=\"p\")/span\n/pre/div\n\npWe map the semantics of a PyPy JIT operation to Z3 with the codez3_expression/code\nfunction. It takes the name of a JIT operation and its two (or one) arguments\ninto a pair of Z3 formulas, coderesult/code and codevalid_if/code. The resulting formulas are\nconstructed with the operator overloading of Z3 variables/formulas./p\npThe first element coderesult/code of the result of codez3_expression/code represents the result\nof performing the operation. codevalid_if/code is a bool that represents a condition that\nneeds to be codeTrue/code in order for the result of the operation to be defined. E.g.\ncodeint_pydiv(a, b)/code is only valid if codeb != 0/code. Most operations are always valid,\nso they return codeTrue/code as that condition (we'll ignore codevalid_if/code for a bit, but it\nwill become more relevant further down in the post)./p\npWe can define a helper function to prove things by finding counterexamples:/p\ndiv class=\"code\"pre class=\"code literal-block\"span class=\"k\"def/span span class=\"nf\"prove/spanspan class=\"p\"(/spanspan class=\"n\"cond/spanspan class=\"p\"):/span\nspan class=\"w\"    /spanspan class=\"sd\"\"\"\" Try to prove a condition cond by searching for counterexamples of its negation. \"\"\"/span\n    span class=\"n\"z3res/span span class=\"o\"=/span span class=\"n\"solver/spanspan class=\"o\"./spanspan class=\"n\"check/spanspan class=\"p\"(/spanspan class=\"n\"z3/spanspan class=\"o\"./spanspan class=\"n\"Not/spanspan class=\"p\"(/spanspan class=\"n\"cond/spanspan class=\"p\"))/span\n    span class=\"k\"if/span span class=\"n\"z3res/span span class=\"o\"==/span span class=\"n\"z3/spanspan class=\"o\"./spanspan class=\"n\"unsat/spanspan class=\"p\":/span\n        span class=\"k\"return/span span class=\"kc\"True/span\n    span class=\"k\"elif/span span class=\"n\"z3res/span span class=\"o\"==/span span class=\"n\"z3/spanspan class=\"o\"./spanspan class=\"n\"unknown/spanspan class=\"p\":/span span class=\"c1\"# eg on timeout/span\n        span class=\"k\"return/span span class=\"kc\"False/span\n    span class=\"k\"elif/span span class=\"n\"z3res/span span class=\"o\"==/span span class=\"n\"z3/spanspan class=\"o\"./spanspan class=\"n\"sat/spanspan class=\"p\":/span\n        span class=\"k\"return/span span class=\"kc\"False/span\n    span class=\"k\"assert/span span class=\"mi\"0/spanspan class=\"p\",/span span class=\"s2\"\"should be unreachable\"/span\n/pre/div\n\nh3 id=\"finding-rewrite-rules\"Finding rewrite rules/h3\npNow we can start finding our first rewrite rules, following the first pattern\ncodeop(x, x) -gt; x/code. We do this by iterating over all the supported binary\noperation names, getting the z3 expression for codeop(x, x)/code and then asking Z3 to\nprove codeop(x, x) == x/code./p\ndiv class=\"code\"pre class=\"code literal-block\"span class=\"k\"for/span span class=\"n\"opname/span span class=\"ow\"in/span span class=\"n\"opnames2/spanspan class=\"p\":/span\n    span class=\"n\"result/spanspan class=\"p\",/span span class=\"n\"valid_if/span span class=\"o\"=/span span class=\"n\"z3_expression/spanspan class=\"p\"(/spanspan class=\"n\"opname/spanspan class=\"p\",/span span class=\"n\"xvar/spanspan class=\"p\",/span span class=\"n\"xvar/spanspan class=\"p\")/span\n    span class=\"k\"if/span span class=\"n\"prove/spanspan class=\"p\"(/spanspan class=\"n\"result/span span class=\"o\"==/span span class=\"n\"xvar/spanspan class=\"p\"):/span\n        span class=\"nb\"print/spanspan class=\"p\"(/spanspan class=\"sa\"f/spanspan class=\"s2\"\"/spanspan class=\"si\"{/spanspan class=\"n\"opname/spanspan class=\"si\"}/spanspan class=\"s2\"(x, x) -gt; x, /spanspan class=\"si\"{/spanspan class=\"n\"result/spanspan class=\"si\"}/spanspan class=\"s2\"\"/spanspan class=\"p\")/span\n/pre/div\n\npThis yields the simplifications:/p\ndiv class=\"code\"pre class=\"code literal-block\"span class=\"n\"int_and/spanspan class=\"p\"(/spanspan class=\"n\"x/spanspan class=\"p\",/spanspan class=\"w\" /spanspan class=\"n\"x/spanspan class=\"p\")/spanspan class=\"w\" /spanspan class=\"o\"-gt;/spanspan class=\"w\" /spanspan class=\"n\"x/span\nspan class=\"n\"int_or/spanspan class=\"p\"(/spanspan class=\"n\"x/spanspan class=\"p\",/spanspan class=\"w\" /spanspan class=\"n\"x/spanspan class=\"p\")/spanspan class=\"w\" /spanspan class=\"o\"-gt;/spanspan class=\"w\" /spanspan class=\"n\"x/span\n/pre/div\n\nh3 id=\"synthesizing-constants\"Synthesizing constants/h3\npSupporting the next patterns is harder: codeop(x, x) == c1/code, codeop(x, c1) == x/code, and\ncodeop(c1, x) == x/code. We don't know which constants to pick to try to get Z3 to\nprove the equality. We could iterate over common constants like code0/code, code1/code,\ncodeMAXINT/code, etc, or even over all the 256 values for a bitvector of length 8.\nHowever, we will instead ask Z3 to find the constants for us too./p\npThis can be done by using quantifiers, in this case codez3.ForAll/code. The query we\npose to Z3 is \"does there exist a constant codec1/code such that for all codex/code the\nfollowing is true: codeop(x, c1) == x/code? Note that the constant codec1/code is not\nnecessarily unique, there could be many of them. We generate several matching\nconstant, and add that they must be different to the condition of the second\nand further queries./p\npWe can express this in a helper function:/p\ndiv class=\"code\"pre class=\"code literal-block\"span class=\"k\"def/span span class=\"nf\"find_constant/spanspan class=\"p\"(/spanspan class=\"n\"z3expr/spanspan class=\"p\",/span span class=\"n\"number_of_results/spanspan class=\"o\"=/spanspan class=\"mi\"5/spanspan class=\"p\"):/span\n    span class=\"n\"condition/span span class=\"o\"=/span span class=\"n\"z3/spanspan class=\"o\"./spanspan class=\"n\"ForAll/spanspan class=\"p\"(/span\n        span class=\"p\"[/spanspan class=\"n\"xvar/spanspan class=\"p\"],/span\n        span class=\"n\"z3expr/span\n    span class=\"p\")/span\n    span class=\"k\"for/span span class=\"n\"i/span span class=\"ow\"in/span span class=\"nb\"range/spanspan class=\"p\"(/spanspan class=\"n\"number_of_results/spanspan class=\"p\"):/span\n        span class=\"n\"checkres/span span class=\"o\"=/span span class=\"n\"solver/spanspan class=\"o\"./spanspan class=\"n\"check/spanspan class=\"p\"(/spanspan class=\"n\"condition/spanspan class=\"p\")/span\n        span class=\"k\"if/span span class=\"n\"checkres/span span class=\"o\"==/span span class=\"n\"z3/spanspan class=\"o\"./spanspan class=\"n\"sat/spanspan class=\"p\":/span\n            span class=\"c1\"# if a solver check succeeds, we can ask for a model, which is/span\n            span class=\"c1\"# concrete values for the variables constvar/span\n            span class=\"n\"model/span span class=\"o\"=/span span class=\"n\"solver/spanspan class=\"o\"./spanspan class=\"n\"model/spanspan class=\"p\"()/span\n            span class=\"n\"const/span span class=\"o\"=/span span class=\"n\"model/spanspan class=\"p\"[/spanspan class=\"n\"constvar/spanspan class=\"p\"]/spanspan class=\"o\"./spanspan class=\"n\"as_signed_long/spanspan class=\"p\"()/span\n            span class=\"k\"yield/span span class=\"n\"const/span\n            span class=\"c1\"# make sure we don't generate the same constant again on the/span\n            span class=\"c1\"# next call/span\n            span class=\"n\"condition/span span class=\"o\"=/span span class=\"n\"z3/spanspan class=\"o\"./spanspan class=\"n\"And/spanspan class=\"p\"(/spanspan class=\"n\"constvar/span span class=\"o\"!=/span span class=\"n\"const/spanspan class=\"p\",/span span class=\"n\"condition/spanspan class=\"p\")/span\n        span class=\"k\"else/spanspan class=\"p\":/span\n            span class=\"c1\"# no (more) constants found/span\n            span class=\"k\"break/span\n/pre/div\n\npWe can use this new function for the three mentioned patterns:/p\ndiv class=\"code\"pre class=\"code literal-block\"span class=\"c1\"# try to find constants for op(x, x) == c/span\nspan class=\"k\"for/span span class=\"n\"opname/span span class=\"ow\"in/span span class=\"n\"opnames2/spanspan class=\"p\":/span\n    span class=\"n\"result/spanspan class=\"p\",/span span class=\"n\"valid_if/span span class=\"o\"=/span span class=\"n\"z3_expression/spanspan class=\"p\"(/spanspan class=\"n\"opname/spanspan class=\"p\",/span span class=\"n\"xvar/spanspan class=\"p\",/span span class=\"n\"xvar/spanspan class=\"p\")/span\n    span class=\"k\"for/span span class=\"n\"const/span span class=\"ow\"in/span span class=\"n\"find_constant/spanspan class=\"p\"(/spanspan class=\"n\"result/span span class=\"o\"==/span span class=\"n\"constvar/spanspan class=\"p\"):/span\n        span class=\"nb\"print/spanspan class=\"p\"(/spanspan class=\"sa\"f/spanspan class=\"s2\"\"/spanspan class=\"si\"{/spanspan class=\"n\"opname/spanspan class=\"si\"}/spanspan class=\"s2\"(x, x) -gt; /spanspan class=\"si\"{/spanspan class=\"n\"const/spanspan class=\"si\"}/spanspan class=\"s2\"\"/spanspan class=\"p\")/span\nspan class=\"c1\"# try to find constants for op(x, c) == x and op(c, x) == x/span\nspan class=\"k\"for/span span class=\"n\"opname/span span class=\"ow\"in/span span class=\"n\"opnames2/spanspan class=\"p\":/span\n    span class=\"n\"result/spanspan class=\"p\",/span span class=\"n\"valid_if/span span class=\"o\"=/span span class=\"n\"z3_expression/spanspan class=\"p\"(/spanspan class=\"n\"opname/spanspan class=\"p\",/span span class=\"n\"xvar/spanspan class=\"p\",/span span class=\"n\"constvar/spanspan class=\"p\")/span\n    span class=\"k\"for/span span class=\"n\"const/span span class=\"ow\"in/span span class=\"n\"find_constant/spanspan class=\"p\"(/spanspan class=\"n\"result/span span class=\"o\"==/span span class=\"n\"xvar/spanspan class=\"p\"):/span\n        span class=\"nb\"print/spanspan class=\"p\"(/spanspan class=\"sa\"f/spanspan class=\"s2\"\"/spanspan class=\"si\"{/spanspan class=\"n\"opname/spanspan class=\"si\"}/spanspan class=\"s2\"(x, /spanspan class=\"si\"{/spanspan class=\"n\"const/spanspan class=\"si\"}/spanspan class=\"s2\") -gt; x\"/spanspan class=\"p\")/span\n    span class=\"n\"result/spanspan class=\"p\",/span span class=\"n\"valid_if/span span class=\"o\"=/span span class=\"n\"z3_expression/spanspan class=\"p\"(/spanspan class=\"n\"opname/spanspan class=\"p\",/span span class=\"n\"constvar/spanspan class=\"p\",/span span class=\"n\"xvar/spanspan class=\"p\")/span\n    span class=\"k\"for/span span class=\"n\"const/span span class=\"ow\"in/span span class=\"n\"find_constant/spanspan class=\"p\"(/spanspan class=\"n\"result/span span class=\"o\"==/span span class=\"n\"xvar/spanspan class=\"p\"):/span\n        span class=\"nb\"print/spanspan class=\"p\"(/spanspan class=\"sa\"f/spanspan class=\"s2\"\"/spanspan class=\"si\"{/spanspan class=\"n\"opname/spanspan class=\"si\"}/spanspan class=\"s2\"(/spanspan class=\"si\"{/spanspan class=\"n\"const/spanspan class=\"si\"}/spanspan class=\"s2\", x) -gt; x\"/spanspan class=\"p\")/span\nspan class=\"c1\"# this code is not quite correct, we'll correct it later/span\n/pre/div\n\npTogether this yields the following new simplifications:/p\ndiv class=\"code\"pre class=\"code literal-block\"span class=\"cp\"# careful, these are not all correct!/span\nspan class=\"n\"int_sub/spanspan class=\"p\"(/spanspan class=\"n\"x/spanspan class=\"p\",/spanspan class=\"w\" /spanspan class=\"n\"x/spanspan class=\"p\")/spanspan class=\"w\" /spanspan class=\"o\"-gt;/spanspan class=\"w\" /spanspan class=\"mi\"0/span\nspan class=\"n\"int_xor/spanspan class=\"p\"(/spanspan class=\"n\"x/spanspan class=\"p\",/spanspan class=\"w\" /spanspan class=\"n\"x/spanspan class=\"p\")/spanspan class=\"w\" /spanspan class=\"o\"-gt;/spanspan class=\"w\" /spanspan class=\"mi\"0/span\nspan class=\"n\"int_eq/spanspan class=\"p\"(/spanspan class=\"n\"x/spanspan class=\"p\",/spanspan class=\"w\" /spanspan class=\"n\"x/spanspan class=\"p\")/spanspan class=\"w\" /spanspan class=\"o\"-gt;/spanspan class=\"w\" /spanspan class=\"mi\"1/span\nspan class=\"n\"int_ne/spanspan class=\"p\"(/spanspan class=\"n\"x/spanspan class=\"p\",/spanspan class=\"w\" /spanspan class=\"n\"x/spanspan class=\"p\")/spanspan class=\"w\" /spanspan class=\"o\"-gt;/spanspan class=\"w\" /spanspan class=\"mi\"0/span\nspan class=\"n\"int_lt/spanspan class=\"p\"(/spanspan class=\"n\"x/spanspan class=\"p\",/spanspan class=\"w\" /spanspan class=\"n\"x/spanspan class=\"p\")/spanspan class=\"w\" /spanspan class=\"o\"-gt;/spanspan class=\"w\" /spanspan class=\"mi\"0/span\nspan class=\"n\"int_le/spanspan class=\"p\"(/spanspan class=\"n\"x/spanspan class=\"p\",/spanspan class=\"w\" /spanspan class=\"n\"x/spanspan class=\"p\")/spanspan class=\"w\" /spanspan class=\"o\"-gt;/spanspan class=\"w\" /spanspan class=\"mi\"1/span\nspan class=\"n\"int_gt/spanspan class=\"p\"(/spanspan class=\"n\"x/spanspan class=\"p\",/spanspan class=\"w\" /spanspan class=\"n\"x/spanspan class=\"p\")/spanspan class=\"w\" /spanspan class=\"o\"-gt;/spanspan class=\"w\" /spanspan class=\"mi\"0/span\nspan class=\"n\"int_ge/spanspan class=\"p\"(/spanspan class=\"n\"x/spanspan class=\"p\",/spanspan class=\"w\" /spanspan class=\"n\"x/spanspan class=\"p\")/spanspan class=\"w\" /spanspan class=\"o\"-gt;/spanspan class=\"w\" /spanspan class=\"mi\"1/span\nspan class=\"n\"uint_lt/spanspan class=\"p\"(/spanspan class=\"n\"x/spanspan class=\"p\",/spanspan class=\"w\" /spanspan class=\"n\"x/spanspan class=\"p\")/spanspan class=\"w\" /spanspan class=\"o\"-gt;/spanspan class=\"w\" /spanspan class=\"mi\"0/span\nspan class=\"n\"uint_le/spanspan class=\"p\"(/spanspan class=\"n\"x/spanspan class=\"p\",/spanspan class=\"w\" /spanspan class=\"n\"x/spanspan class=\"p\")/spanspan class=\"w\" /spanspan class=\"o\"-gt;/spanspan class=\"w\" /spanspan class=\"mi\"1/span\nspan class=\"n\"uint_gt/spanspan class=\"p\"(/spanspan class=\"n\"x/spanspan class=\"p\",/spanspan class=\"w\" /spanspan class=\"n\"x/spanspan class=\"p\")/spanspan class=\"w\" /spanspan class=\"o\"-gt;/spanspan class=\"w\" /spanspan class=\"mi\"0/span\nspan class=\"n\"uint_ge/spanspan class=\"p\"(/spanspan class=\"n\"x/spanspan class=\"p\",/spanspan class=\"w\" /spanspan class=\"n\"x/spanspan class=\"p\")/spanspan class=\"w\" /spanspan class=\"o\"-gt;/spanspan class=\"w\" /spanspan class=\"mi\"1/span\nspan class=\"n\"uint_rshift/spanspan class=\"p\"(/spanspan class=\"n\"x/spanspan class=\"p\",/spanspan class=\"w\" /spanspan class=\"n\"x/spanspan class=\"p\")/spanspan class=\"w\" /spanspan class=\"o\"-gt;/spanspan class=\"w\" /spanspan class=\"mi\"0/span\nspan class=\"n\"int_pymod/spanspan class=\"p\"(/spanspan class=\"n\"x/spanspan class=\"p\",/spanspan class=\"w\" /spanspan class=\"n\"x/spanspan class=\"p\")/spanspan class=\"w\" /spanspan class=\"o\"-gt;/spanspan class=\"w\" /spanspan class=\"mi\"0/span\nspan class=\"n\"int_add/spanspan class=\"p\"(/spanspan class=\"n\"x/spanspan class=\"p\",/spanspan class=\"w\" /spanspan class=\"mi\"0/spanspan class=\"p\")/spanspan class=\"w\" /spanspan class=\"o\"-gt;/spanspan class=\"w\" /spanspan class=\"n\"x/span\nspan class=\"n\"int_add/spanspan class=\"p\"(/spanspan class=\"mi\"0/spanspan class=\"p\",/spanspan class=\"w\" /spanspan class=\"n\"x/spanspan class=\"p\")/spanspan class=\"w\" /spanspan class=\"o\"-gt;/spanspan class=\"w\" /spanspan class=\"n\"x/span\nspan class=\"n\"int_sub/spanspan class=\"p\"(/spanspan class=\"n\"x/spanspan class=\"p\",/spanspan class=\"w\" /spanspan class=\"mi\"0/spanspan class=\"p\")/spanspan class=\"w\" /spanspan class=\"o\"-gt;/spanspan class=\"w\" /spanspan class=\"n\"x/span\nspan class=\"n\"int_mul/spanspan class=\"p\"(/spanspan class=\"n\"x/spanspan class=\"p\",/spanspan class=\"w\" /spanspan class=\"mi\"1/spanspan class=\"p\")/spanspan class=\"w\" /spanspan class=\"o\"-gt;/spanspan class=\"w\" /spanspan class=\"n\"x/span\nspan class=\"n\"int_mul/spanspan class=\"p\"(/spanspan class=\"mi\"1/spanspan class=\"p\",/spanspan class=\"w\" /spanspan class=\"n\"x/spanspan class=\"p\")/spanspan class=\"w\" /spanspan class=\"o\"-gt;/spanspan class=\"w\" /spanspan class=\"n\"x/span\nspan class=\"n\"int_and/spanspan class=\"p\"(/spanspan class=\"n\"x/spanspan class=\"p\",/spanspan class=\"w\" /spanspan class=\"o\"-/spanspan class=\"mi\"1/spanspan class=\"p\")/spanspan class=\"w\" /spanspan class=\"o\"-gt;/spanspan class=\"w\" /spanspan class=\"n\"x/span\nspan class=\"n\"int_and/spanspan class=\"p\"(/spanspan class=\"o\"-/spanspan class=\"mi\"1/spanspan class=\"p\",/spanspan class=\"w\" /spanspan class=\"n\"x/spanspan class=\"p\")/spanspan class=\"w\" /spanspan class=\"o\"-gt;/spanspan class=\"w\" /spanspan class=\"n\"x/span\nspan class=\"n\"int_or/spanspan class=\"p\"(/spanspan class=\"n\"x/spanspan class=\"p\",/spanspan class=\"w\" /spanspan class=\"mi\"0/spanspan class=\"p\")/spanspan class=\"w\" /spanspan class=\"o\"-gt;/spanspan class=\"w\" /spanspan class=\"n\"x/span\nspan class=\"n\"int_or/spanspan class=\"p\"(/spanspan class=\"mi\"0/spanspan class=\"p\",/spanspan class=\"w\" /spanspan class=\"n\"x/spanspan class=\"p\")/spanspan class=\"w\" /spanspan class=\"o\"-gt;/spanspan class=\"w\" /spanspan class=\"n\"x/span\nspan class=\"n\"int_xor/spanspan class=\"p\"(/spanspan class=\"n\"x/spanspan class=\"p\",/spanspan class=\"w\" /spanspan class=\"mi\"0/spanspan class=\"p\")/spanspan class=\"w\" /spanspan class=\"o\"-gt;/spanspan class=\"w\" /spanspan class=\"n\"x/span\nspan class=\"n\"int_xor/spanspan class=\"p\"(/spanspan class=\"mi\"0/spanspan class=\"p\",/spanspan class=\"w\" /spanspan class=\"n\"x/spanspan class=\"p\")/spanspan class=\"w\" /spanspan class=\"o\"-gt;/spanspan class=\"w\" /spanspan class=\"n\"x/span\nspan class=\"n\"int_lshift/spanspan class=\"p\"(/spanspan class=\"n\"x/spanspan class=\"p\",/spanspan class=\"w\" /spanspan class=\"mi\"0/spanspan class=\"p\")/spanspan class=\"w\" /spanspan class=\"o\"-gt;/spanspan class=\"w\" /spanspan class=\"n\"x/span\nspan class=\"n\"int_rshift/spanspan class=\"p\"(/spanspan class=\"n\"x/spanspan class=\"p\",/spanspan class=\"w\" /spanspan class=\"mi\"0/spanspan class=\"p\")/spanspan class=\"w\" /spanspan class=\"o\"-gt;/spanspan class=\"w\" /spanspan class=\"n\"x/span\nspan class=\"n\"uint_rshift/spanspan class=\"p\"(/spanspan class=\"n\"x/spanspan class=\"p\",/spanspan class=\"w\" /spanspan class=\"mi\"0/spanspan class=\"p\")/spanspan class=\"w\" /spanspan class=\"o\"-gt;/spanspan class=\"w\" /spanspan class=\"n\"x/span\nspan class=\"n\"int_pydiv/spanspan class=\"p\"(/spanspan class=\"n\"x/spanspan class=\"p\",/spanspan class=\"w\" /spanspan class=\"mi\"1/spanspan class=\"p\")/spanspan class=\"w\" /spanspan class=\"o\"-gt;/spanspan class=\"w\" /spanspan class=\"n\"x/span\nspan class=\"n\"int_pymod/spanspan class=\"p\"(/spanspan class=\"n\"x/spanspan class=\"p\",/spanspan class=\"w\" /spanspan class=\"mi\"0/spanspan class=\"p\")/spanspan class=\"w\" /spanspan class=\"o\"-gt;/spanspan class=\"w\" /spanspan class=\"n\"x/span\n/pre/div\n\npMost of these look good at first glance, but the last one reveals a problem:\nwe've been ignoring the codevalid_if/code expression up to now. We can stop doing that by\nchanging the code like this, which adds codez3.And(valid_if, ...)/code to the argument of\nthe calls to codefind_constant/code:/p\ndiv class=\"code\"pre class=\"code literal-block\"span class=\"c1\"# try to find constants for op(x, x) == c, op(x, c) == x and op(c, x) == x/span\nspan class=\"k\"for/span span class=\"n\"opname/span span class=\"ow\"in/span span class=\"n\"opnames2/spanspan class=\"p\":/span\n    span class=\"n\"result/spanspan class=\"p\",/span span class=\"n\"valid_if/span span class=\"o\"=/span span class=\"n\"z3_expression/spanspan class=\"p\"(/spanspan class=\"n\"opname/spanspan class=\"p\",/span span class=\"n\"xvar/spanspan class=\"p\",/span span class=\"n\"xvar/spanspan class=\"p\")/span\n    span class=\"k\"for/span span class=\"n\"const/span span class=\"ow\"in/span span class=\"n\"find_constant/spanspan class=\"p\"(/spanspan class=\"n\"z3/spanspan class=\"o\"./spanspan class=\"n\"And/spanspan class=\"p\"(/spanspan class=\"n\"valid_if/spanspan class=\"p\",/span span class=\"n\"result/span span class=\"o\"==/span span class=\"n\"constvar/spanspan class=\"p\")):/span\n        span class=\"nb\"print/spanspan class=\"p\"(/spanspan class=\"sa\"f/spanspan class=\"s2\"\"/spanspan class=\"si\"{/spanspan class=\"n\"opname/spanspan class=\"si\"}/spanspan class=\"s2\"(x, x) -gt; /spanspan class=\"si\"{/spanspan class=\"n\"const/spanspan class=\"si\"}/spanspan class=\"s2\"\"/spanspan class=\"p\")/span\nspan class=\"c1\"# try to find constants for op(x, c) == x and op(c, x) == x/span\nspan class=\"k\"for/span span class=\"n\"opname/span span class=\"ow\"in/span span class=\"n\"opnames2/spanspan class=\"p\":/span\n    span class=\"n\"result/spanspan class=\"p\",/span span class=\"n\"valid_if/span span class=\"o\"=/span span class=\"n\"z3_expression/spanspan class=\"p\"(/spanspan class=\"n\"opname/spanspan class=\"p\",/span span class=\"n\"xvar/spanspan class=\"p\",/span span class=\"n\"constvar/spanspan class=\"p\")/span\n    span class=\"k\"for/span span class=\"n\"const/span span class=\"ow\"in/span span class=\"n\"find_constant/spanspan class=\"p\"(/spanspan class=\"n\"z3/spanspan class=\"o\"./spanspan class=\"n\"And/spanspan class=\"p\"(/spanspan class=\"n\"result/span span class=\"o\"==/span span class=\"n\"xvar/spanspan class=\"p\",/span span class=\"n\"valid_if/spanspan class=\"p\")):/span\n        span class=\"nb\"print/spanspan class=\"p\"(/spanspan class=\"sa\"f/spanspan class=\"s2\"\"/spanspan class=\"si\"{/spanspan class=\"n\"opname/spanspan class=\"si\"}/spanspan class=\"s2\"(x, /spanspan class=\"si\"{/spanspan class=\"n\"const/spanspan class=\"si\"}/spanspan class=\"s2\") -gt; x\"/spanspan class=\"p\")/span\n    span class=\"n\"result/spanspan class=\"p\",/span span class=\"n\"valid_if/span span class=\"o\"=/span span class=\"n\"z3_expression/spanspan class=\"p\"(/spanspan class=\"n\"opname/spanspan class=\"p\",/span span class=\"n\"constvar/spanspan class=\"p\",/span span class=\"n\"xvar/spanspan class=\"p\")/span\n    span class=\"k\"for/span span class=\"n\"const/span span class=\"ow\"in/span span class=\"n\"find_constant/spanspan class=\"p\"(/spanspan class=\"n\"z3/spanspan class=\"o\"./spanspan class=\"n\"And/spanspan class=\"p\"(/spanspan class=\"n\"result/span span class=\"o\"==/span span class=\"n\"xvar/spanspan class=\"p\",/span span class=\"n\"valid_if/spanspan class=\"p\")):/span\n        span class=\"nb\"print/spanspan class=\"p\"(/spanspan class=\"sa\"f/spanspan class=\"s2\"\"/spanspan class=\"si\"{/spanspan class=\"n\"opname/spanspan class=\"si\"}/spanspan class=\"s2\"(/spanspan class=\"si\"{/spanspan class=\"n\"const/spanspan class=\"si\"}/spanspan class=\"s2\", x) -gt; x\"/spanspan class=\"p\")/span\n/pre/div\n\npAnd we get this list instead:/p\ndiv class=\"code\"pre class=\"code literal-block\"span class=\"n\"int_sub/spanspan class=\"p\"(/spanspan class=\"n\"x/spanspan class=\"p\",/spanspan class=\"w\" /spanspan class=\"n\"x/spanspan class=\"p\")/spanspan class=\"w\" /spanspan class=\"o\"-gt;/spanspan class=\"w\" /spanspan class=\"mi\"0/span\nspan class=\"n\"int_xor/spanspan class=\"p\"(/spanspan class=\"n\"x/spanspan class=\"p\",/spanspan class=\"w\" /spanspan class=\"n\"x/spanspan class=\"p\")/spanspan class=\"w\" /spanspan class=\"o\"-gt;/spanspan class=\"w\" /spanspan class=\"mi\"0/span\nspan class=\"n\"int_eq/spanspan class=\"p\"(/spanspan class=\"n\"x/spanspan class=\"p\",/spanspan class=\"w\" /spanspan class=\"n\"x/spanspan class=\"p\")/spanspan class=\"w\" /spanspan class=\"o\"-gt;/spanspan class=\"w\" /spanspan class=\"mi\"1/span\nspan class=\"n\"int_ne/spanspan class=\"p\"(/spanspan class=\"n\"x/spanspan class=\"p\",/spanspan class=\"w\" /spanspan class=\"n\"x/spanspan class=\"p\")/spanspan class=\"w\" /spanspan class=\"o\"-gt;/spanspan class=\"w\" /spanspan class=\"mi\"0/span\nspan class=\"n\"int_lt/spanspan class=\"p\"(/spanspan class=\"n\"x/spanspan class=\"p\",/spanspan class=\"w\" /spanspan class=\"n\"x/spanspan class=\"p\")/spanspan class=\"w\" /spanspan class=\"o\"-gt;/spanspan class=\"w\" /spanspan class=\"mi\"0/span\nspan class=\"n\"int_le/spanspan class=\"p\"(/spanspan class=\"n\"x/spanspan class=\"p\",/spanspan class=\"w\" /spanspan class=\"n\"x/spanspan class=\"p\")/spanspan class=\"w\" /spanspan class=\"o\"-gt;/spanspan class=\"w\" /spanspan class=\"mi\"1/span\nspan class=\"n\"int_gt/spanspan class=\"p\"(/spanspan class=\"n\"x/spanspan class=\"p\",/spanspan class=\"w\" /spanspan class=\"n\"x/spanspan class=\"p\")/spanspan class=\"w\" /spanspan class=\"o\"-gt;/spanspan class=\"w\" /spanspan class=\"mi\"0/span\nspan class=\"n\"int_ge/spanspan class=\"p\"(/spanspan class=\"n\"x/spanspan class=\"p\",/spanspan class=\"w\" /spanspan class=\"n\"x/spanspan class=\"p\")/spanspan class=\"w\" /spanspan class=\"o\"-gt;/spanspan class=\"w\" /spanspan class=\"mi\"1/span\nspan class=\"n\"uint_lt/spanspan class=\"p\"(/spanspan class=\"n\"x/spanspan class=\"p\",/spanspan class=\"w\" /spanspan class=\"n\"x/spanspan class=\"p\")/spanspan class=\"w\" /spanspan class=\"o\"-gt;/spanspan class=\"w\" /spanspan class=\"mi\"0/span\nspan class=\"n\"uint_le/spanspan class=\"p\"(/spanspan class=\"n\"x/spanspan class=\"p\",/spanspan class=\"w\" /spanspan class=\"n\"x/spanspan class=\"p\")/spanspan class=\"w\" /spanspan class=\"o\"-gt;/spanspan class=\"w\" /spanspan class=\"mi\"1/span\nspan class=\"n\"uint_gt/spanspan class=\"p\"(/spanspan class=\"n\"x/spanspan class=\"p\",/spanspan class=\"w\" /spanspan class=\"n\"x/spanspan class=\"p\")/spanspan class=\"w\" /spanspan class=\"o\"-gt;/spanspan class=\"w\" /spanspan class=\"mi\"0/span\nspan class=\"n\"uint_ge/spanspan class=\"p\"(/spanspan class=\"n\"x/spanspan class=\"p\",/spanspan class=\"w\" /spanspan class=\"n\"x/spanspan class=\"p\")/spanspan class=\"w\" /spanspan class=\"o\"-gt;/spanspan class=\"w\" /spanspan class=\"mi\"1/span\nspan class=\"n\"int_add/spanspan class=\"p\"(/spanspan class=\"n\"x/spanspan class=\"p\",/spanspan class=\"w\" /spanspan class=\"mi\"0/spanspan class=\"p\")/spanspan class=\"w\" /spanspan class=\"o\"-gt;/spanspan class=\"w\" /spanspan class=\"n\"x/span\nspan class=\"n\"int_add/spanspan class=\"p\"(/spanspan class=\"mi\"0/spanspan class=\"p\",/spanspan class=\"w\" /spanspan class=\"n\"x/spanspan class=\"p\")/spanspan class=\"w\" /spanspan class=\"o\"-gt;/spanspan class=\"w\" /spanspan class=\"n\"x/span\nspan class=\"n\"int_sub/spanspan class=\"p\"(/spanspan class=\"n\"x/spanspan class=\"p\",/spanspan class=\"w\" /spanspan class=\"mi\"0/spanspan class=\"p\")/spanspan class=\"w\" /spanspan class=\"o\"-gt;/spanspan class=\"w\" /spanspan class=\"n\"x/span\nspan class=\"n\"int_mul/spanspan class=\"p\"(/spanspan class=\"n\"x/spanspan class=\"p\",/spanspan class=\"w\" /spanspan class=\"mi\"1/spanspan class=\"p\")/spanspan class=\"w\" /spanspan class=\"o\"-gt;/spanspan class=\"w\" /spanspan class=\"n\"x/span\nspan class=\"n\"int_mul/spanspan class=\"p\"(/spanspan class=\"mi\"1/spanspan class=\"p\",/spanspan class=\"w\" /spanspan class=\"n\"x/spanspan class=\"p\")/spanspan class=\"w\" /spanspan class=\"o\"-gt;/spanspan class=\"w\" /spanspan class=\"n\"x/span\nspan class=\"n\"int_and/spanspan class=\"p\"(/spanspan class=\"n\"x/spanspan class=\"p\",/spanspan class=\"w\" /spanspan class=\"o\"-/spanspan class=\"mi\"1/spanspan class=\"p\")/spanspan class=\"w\" /spanspan class=\"o\"-gt;/spanspan class=\"w\" /spanspan class=\"n\"x/span\nspan class=\"n\"int_and/spanspan class=\"p\"(/spanspan class=\"o\"-/spanspan class=\"mi\"1/spanspan class=\"p\",/spanspan class=\"w\" /spanspan class=\"n\"x/spanspan class=\"p\")/spanspan class=\"w\" /spanspan class=\"o\"-gt;/spanspan class=\"w\" /spanspan class=\"n\"x/span\nspan class=\"n\"int_or/spanspan class=\"p\"(/spanspan class=\"n\"x/spanspan class=\"p\",/spanspan class=\"w\" /spanspan class=\"mi\"0/spanspan class=\"p\")/spanspan class=\"w\" /spanspan class=\"o\"-gt;/spanspan class=\"w\" /spanspan class=\"n\"x/span\nspan class=\"n\"int_or/spanspan class=\"p\"(/spanspan class=\"mi\"0/spanspan class=\"p\",/spanspan class=\"w\" /spanspan class=\"n\"x/spanspan class=\"p\")/spanspan class=\"w\" /spanspan class=\"o\"-gt;/spanspan class=\"w\" /spanspan class=\"n\"x/span\nspan class=\"n\"int_xor/spanspan class=\"p\"(/spanspan class=\"n\"x/spanspan class=\"p\",/spanspan class=\"w\" /spanspan class=\"mi\"0/spanspan class=\"p\")/spanspan class=\"w\" /spanspan class=\"o\"-gt;/spanspan class=\"w\" /spanspan class=\"n\"x/span\nspan class=\"n\"int_xor/spanspan class=\"p\"(/spanspan class=\"mi\"0/spanspan class=\"p\",/spanspan class=\"w\" /spanspan class=\"n\"x/spanspan class=\"p\")/spanspan class=\"w\" /spanspan class=\"o\"-gt;/spanspan class=\"w\" /spanspan class=\"n\"x/span\nspan class=\"n\"int_lshift/spanspan class=\"p\"(/spanspan class=\"n\"x/spanspan class=\"p\",/spanspan class=\"w\" /spanspan class=\"mi\"0/spanspan class=\"p\")/spanspan class=\"w\" /spanspan class=\"o\"-gt;/spanspan class=\"w\" /spanspan class=\"n\"x/span\nspan class=\"n\"int_rshift/spanspan class=\"p\"(/spanspan class=\"n\"x/spanspan class=\"p\",/spanspan class=\"w\" /spanspan class=\"mi\"0/spanspan class=\"p\")/spanspan class=\"w\" /spanspan class=\"o\"-gt;/spanspan class=\"w\" /spanspan class=\"n\"x/span\nspan class=\"n\"uint_rshift/spanspan class=\"p\"(/spanspan class=\"n\"x/spanspan class=\"p\",/spanspan class=\"w\" /spanspan class=\"mi\"0/spanspan class=\"p\")/spanspan class=\"w\" /spanspan class=\"o\"-gt;/spanspan class=\"w\" /spanspan class=\"n\"x/span\nspan class=\"n\"int_pydiv/spanspan class=\"p\"(/spanspan class=\"n\"x/spanspan class=\"p\",/spanspan class=\"w\" /spanspan class=\"mi\"1/spanspan class=\"p\")/spanspan class=\"w\" /spanspan class=\"o\"-gt;/spanspan class=\"w\" /spanspan class=\"n\"x/span\n/pre/div\n\nh3 id=\"synthesizing-two-constants\"Synthesizing two constants/h3\npFor the patterns codeop(x, c1) == c2/code and codeop(c1, x) == c2/code we need to synthesize\ntwo constants. We can again write a helper method for that:/p\ndiv class=\"code\"pre class=\"code literal-block\"span class=\"k\"def/span span class=\"nf\"find_2consts/spanspan class=\"p\"(/spanspan class=\"n\"z3expr/spanspan class=\"p\",/span span class=\"n\"number_of_results/spanspan class=\"o\"=/spanspan class=\"mi\"5/spanspan class=\"p\"):/span\n    span class=\"n\"condition/span span class=\"o\"=/span span class=\"n\"z3/spanspan class=\"o\"./spanspan class=\"n\"ForAll/spanspan class=\"p\"(/span\n        span class=\"p\"[/spanspan class=\"n\"xvar/spanspan class=\"p\"],/span\n        span class=\"n\"z3expr/span\n    span class=\"p\")/span\n    span class=\"k\"for/span span class=\"n\"i/span span class=\"ow\"in/span span class=\"nb\"range/spanspan class=\"p\"(/spanspan class=\"n\"number_of_results/spanspan class=\"p\"):/span\n        span class=\"n\"checkres/span span class=\"o\"=/span span class=\"n\"solver/spanspan class=\"o\"./spanspan class=\"n\"check/spanspan class=\"p\"(/spanspan class=\"n\"condition/spanspan class=\"p\")/span\n        span class=\"k\"if/span span class=\"n\"checkres/span span class=\"o\"==/span span class=\"n\"z3/spanspan class=\"o\"./spanspan class=\"n\"sat/spanspan class=\"p\":/span\n            span class=\"n\"model/span span class=\"o\"=/span span class=\"n\"solver/spanspan class=\"o\"./spanspan class=\"n\"model/spanspan class=\"p\"()/span\n            span class=\"n\"const/span span class=\"o\"=/span span class=\"n\"model/spanspan class=\"p\"[/spanspan class=\"n\"constvar/spanspan class=\"p\"]/spanspan class=\"o\"./spanspan class=\"n\"as_signed_long/spanspan class=\"p\"()/span\n            span class=\"n\"const2/span span class=\"o\"=/span span class=\"n\"model/spanspan class=\"p\"[/spanspan class=\"n\"constvar2/spanspan class=\"p\"]/spanspan class=\"o\"./spanspan class=\"n\"as_signed_long/spanspan class=\"p\"()/span\n            span class=\"k\"yield/span span class=\"n\"const/spanspan class=\"p\",/span span class=\"n\"const2/span\n            span class=\"n\"condition/span span class=\"o\"=/span span class=\"n\"z3/spanspan class=\"o\"./spanspan class=\"n\"And/spanspan class=\"p\"(/spanspan class=\"n\"z3/spanspan class=\"o\"./spanspan class=\"n\"Or/spanspan class=\"p\"(/spanspan class=\"n\"constvar/span span class=\"o\"!=/span span class=\"n\"const/spanspan class=\"p\",/span span class=\"n\"constvar2/span span class=\"o\"!=/span span class=\"n\"const2/spanspan class=\"p\"),/span span class=\"n\"condition/spanspan class=\"p\")/span\n        span class=\"k\"else/spanspan class=\"p\":/span\n            span class=\"k\"return/span\n/pre/div\n\npAnd then use it like this:/p\ndiv class=\"code\"pre class=\"code literal-block\"span class=\"k\"for/span span class=\"n\"opname/span span class=\"ow\"in/span span class=\"n\"opnames2/spanspan class=\"p\":/span\n    span class=\"c1\"# try to find constants c1, c2 such that op(c1, x) -gt; c2/span\n    span class=\"n\"result/spanspan class=\"p\",/span span class=\"n\"valid_if/span span class=\"o\"=/span span class=\"n\"z3_expression/spanspan class=\"p\"(/spanspan class=\"n\"opname/spanspan class=\"p\",/span span class=\"n\"constvar/spanspan class=\"p\",/span span class=\"n\"xvar/spanspan class=\"p\")/span\n    span class=\"n\"consts/span span class=\"o\"=/span span class=\"n\"find_2consts/spanspan class=\"p\"(/spanspan class=\"n\"z3/spanspan class=\"o\"./spanspan class=\"n\"And/spanspan class=\"p\"(/spanspan class=\"n\"valid_if/spanspan class=\"p\",/span span class=\"n\"result/span span class=\"o\"==/span span class=\"n\"constvar2/spanspan class=\"p\"))/span\n    span class=\"k\"for/span span class=\"n\"const/spanspan class=\"p\",/span span class=\"n\"const2/span span class=\"ow\"in/span span class=\"n\"consts/spanspan class=\"p\":/span\n        span class=\"nb\"print/spanspan class=\"p\"(/spanspan class=\"sa\"f/spanspan class=\"s2\"\"/spanspan class=\"si\"{/spanspan class=\"n\"opname/spanspan class=\"si\"}/spanspan class=\"s2\"(/spanspan class=\"si\"{/spanspan class=\"n\"const/spanspan class=\"si\"}/spanspan class=\"s2\", x) -gt; /spanspan class=\"si\"{/spanspan class=\"n\"const2/spanspan class=\"si\"}/spanspan class=\"s2\"\"/spanspan class=\"p\")/span\n    span class=\"c1\"# try to find constants c1, c2 such that op(x, c1) -gt; c2/span\n    span class=\"n\"result/spanspan class=\"p\",/span span class=\"n\"valid_if/span span class=\"o\"=/span span class=\"n\"z3_expression/spanspan class=\"p\"(/spanspan class=\"n\"opname/spanspan class=\"p\",/span span class=\"n\"xvar/spanspan class=\"p\",/span span class=\"n\"constvar/spanspan class=\"p\")/span\n    span class=\"n\"consts/span span class=\"o\"=/span span class=\"n\"find_2consts/spanspan class=\"p\"(/spanspan class=\"n\"z3/spanspan class=\"o\"./spanspan class=\"n\"And/spanspan class=\"p\"(/spanspan class=\"n\"valid_if/spanspan class=\"p\",/span span class=\"n\"result/span span class=\"o\"==/span span class=\"n\"constvar2/spanspan class=\"p\"))/span\n    span class=\"k\"for/span span class=\"n\"const/spanspan class=\"p\",/span span class=\"n\"const2/span span class=\"ow\"in/span span class=\"n\"consts/spanspan class=\"p\":/span\n        span class=\"nb\"print/spanspan class=\"p\"(/spanspan class=\"s2\"\"/spanspan class=\"si\"%s/spanspan class=\"s2\"(x, /spanspan class=\"si\"%s/spanspan class=\"s2\") -gt; /spanspan class=\"si\"%s/spanspan class=\"s2\"\"/span span class=\"o\"%/span span class=\"p\"(/spanspan class=\"n\"opname/spanspan class=\"p\",/span span class=\"n\"const/spanspan class=\"p\",/span span class=\"n\"const2/spanspan class=\"p\"))/span\n/pre/div\n\npWhich yields some straightforward simplifications:/p\ndiv class=\"code\"pre class=\"code literal-block\"span class=\"n\"int_mul/spanspan class=\"p\"(/spanspan class=\"mi\"0/spanspan class=\"p\",/spanspan class=\"w\" /spanspan class=\"n\"x/spanspan class=\"p\")/spanspan class=\"w\" /spanspan class=\"o\"-gt;/spanspan class=\"w\" /spanspan class=\"mi\"0/span\nspan class=\"n\"int_mul/spanspan class=\"p\"(/spanspan class=\"n\"x/spanspan class=\"p\",/spanspan class=\"w\" /spanspan class=\"mi\"0/spanspan class=\"p\")/spanspan class=\"w\" /spanspan class=\"o\"-gt;/spanspan class=\"w\" /spanspan class=\"mi\"0/span\nspan class=\"n\"int_and/spanspan class=\"p\"(/spanspan class=\"mi\"0/spanspan class=\"p\",/spanspan class=\"w\" /spanspan class=\"n\"x/spanspan class=\"p\")/spanspan class=\"w\" /spanspan class=\"o\"-gt;/spanspan class=\"w\" /spanspan class=\"mi\"0/span\nspan class=\"n\"int_and/spanspan class=\"p\"(/spanspan class=\"n\"x/spanspan class=\"p\",/spanspan class=\"w\" /spanspan class=\"mi\"0/spanspan class=\"p\")/spanspan class=\"w\" /spanspan class=\"o\"-gt;/spanspan class=\"w\" /spanspan class=\"mi\"0/span\nspan class=\"n\"uint_lt/spanspan class=\"p\"(/spanspan class=\"n\"x/spanspan class=\"p\",/spanspan class=\"w\" /spanspan class=\"mi\"0/spanspan class=\"p\")/spanspan class=\"w\" /spanspan class=\"o\"-gt;/spanspan class=\"w\" /spanspan class=\"mi\"0/span\nspan class=\"n\"uint_le/spanspan class=\"p\"(/spanspan class=\"mi\"0/spanspan class=\"p\",/spanspan class=\"w\" /spanspan class=\"n\"x/spanspan class=\"p\")/spanspan class=\"w\" /spanspan class=\"o\"-gt;/spanspan class=\"w\" /spanspan class=\"mi\"1/span\nspan class=\"n\"uint_gt/spanspan class=\"p\"(/spanspan class=\"mi\"0/spanspan class=\"p\",/spanspan class=\"w\" /spanspan class=\"n\"x/spanspan class=\"p\")/spanspan class=\"w\" /spanspan class=\"o\"-gt;/spanspan class=\"w\" /spanspan class=\"mi\"0/span\nspan class=\"n\"uint_ge/spanspan class=\"p\"(/spanspan class=\"n\"x/spanspan class=\"p\",/spanspan class=\"w\" /spanspan class=\"mi\"0/spanspan class=\"p\")/spanspan class=\"w\" /spanspan class=\"o\"-gt;/spanspan class=\"w\" /spanspan class=\"mi\"1/span\nspan class=\"n\"int_lshift/spanspan class=\"p\"(/spanspan class=\"mi\"0/spanspan class=\"p\",/spanspan class=\"w\" /spanspan class=\"n\"x/spanspan class=\"p\")/spanspan class=\"w\" /spanspan class=\"o\"-gt;/spanspan class=\"w\" /spanspan class=\"mi\"0/span\nspan class=\"n\"int_rshift/spanspan class=\"p\"(/spanspan class=\"mi\"0/spanspan class=\"p\",/spanspan class=\"w\" /spanspan class=\"n\"x/spanspan class=\"p\")/spanspan class=\"w\" /spanspan class=\"o\"-gt;/spanspan class=\"w\" /spanspan class=\"mi\"0/span\nspan class=\"n\"uint_rshift/spanspan class=\"p\"(/spanspan class=\"mi\"0/spanspan class=\"p\",/spanspan class=\"w\" /spanspan class=\"n\"x/spanspan class=\"p\")/spanspan class=\"w\" /spanspan class=\"o\"-gt;/spanspan class=\"w\" /spanspan class=\"mi\"0/span\nspan class=\"n\"uint_mul_high/spanspan class=\"p\"(/spanspan class=\"mi\"0/spanspan class=\"p\",/spanspan class=\"w\" /spanspan class=\"n\"x/spanspan class=\"p\")/spanspan class=\"w\" /spanspan class=\"o\"-gt;/spanspan class=\"w\" /spanspan class=\"mi\"0/span\nspan class=\"n\"uint_mul_high/spanspan class=\"p\"(/spanspan class=\"mi\"1/spanspan class=\"p\",/spanspan class=\"w\" /spanspan class=\"n\"x/spanspan class=\"p\")/spanspan class=\"w\" /spanspan class=\"o\"-gt;/spanspan class=\"w\" /spanspan class=\"mi\"0/span\nspan class=\"n\"uint_mul_high/spanspan class=\"p\"(/spanspan class=\"n\"x/spanspan class=\"p\",/spanspan class=\"w\" /spanspan class=\"mi\"0/spanspan class=\"p\")/spanspan class=\"w\" /spanspan class=\"o\"-gt;/spanspan class=\"w\" /spanspan class=\"mi\"0/span\nspan class=\"n\"uint_mul_high/spanspan class=\"p\"(/spanspan class=\"n\"x/spanspan class=\"p\",/spanspan class=\"w\" /spanspan class=\"mi\"1/spanspan class=\"p\")/spanspan class=\"w\" /spanspan class=\"o\"-gt;/spanspan class=\"w\" /spanspan class=\"mi\"0/span\nspan class=\"n\"int_pymod/spanspan class=\"p\"(/spanspan class=\"n\"x/spanspan class=\"p\",/spanspan class=\"w\" /spanspan class=\"mi\"1/spanspan class=\"p\")/spanspan class=\"w\" /spanspan class=\"o\"-gt;/spanspan class=\"w\" /spanspan class=\"mi\"0/span\nspan class=\"n\"int_pymod/spanspan class=\"p\"(/spanspan class=\"n\"x/spanspan class=\"p\",/spanspan class=\"w\" /spanspan class=\"o\"-/spanspan class=\"mi\"1/spanspan class=\"p\")/spanspan class=\"w\" /spanspan class=\"o\"-gt;/spanspan class=\"w\" /spanspan class=\"mi\"0/span\n/pre/div\n\npA few require a bit more thinking:/p\ndiv class=\"code\"pre class=\"code literal-block\"span class=\"n\"int_or/spanspan class=\"p\"(/spanspan class=\"o\"-/spanspan class=\"mi\"1/spanspan class=\"p\",/spanspan class=\"w\" /spanspan class=\"n\"x/spanspan class=\"p\")/spanspan class=\"w\" /spanspan class=\"o\"-gt;/spanspan class=\"w\" /spanspan class=\"o\"-/spanspan class=\"mi\"1/span\nspan class=\"n\"int_or/spanspan class=\"p\"(/spanspan class=\"n\"x/spanspan class=\"p\",/spanspan class=\"w\" /spanspan class=\"o\"-/spanspan class=\"mi\"1/spanspan class=\"p\")/spanspan class=\"w\" /spanspan class=\"o\"-gt;/spanspan class=\"w\" /spanspan class=\"o\"-/spanspan class=\"mi\"1/span\n/pre/div\n\npThe are true because in two's complement, code-1/code has all bits set./p\npThe following ones require recognizing that code-9223372036854775808 == -2**63/code is\nthe most negative signed 64-bit integer, and code9223372036854775807 == 2 ** 63 -\n1/code is the most positive one:/p\ndiv class=\"code\"pre class=\"code literal-block\"span class=\"n\"int_lt/spanspan class=\"p\"(/spanspan class=\"mi\"9223372036854775807/spanspan class=\"p\",/spanspan class=\"w\" /spanspan class=\"n\"x/spanspan class=\"p\")/spanspan class=\"w\" /spanspan class=\"o\"-gt;/spanspan class=\"w\" /spanspan class=\"mi\"0/span\nspan class=\"n\"int_lt/spanspan class=\"p\"(/spanspan class=\"n\"x/spanspan class=\"p\",/spanspan class=\"w\" /spanspan class=\"o\"-/spanspan class=\"mi\"9223372036854775808/spanspan class=\"p\")/spanspan class=\"w\" /spanspan class=\"o\"-gt;/spanspan class=\"w\" /spanspan class=\"mi\"0/span\nspan class=\"n\"int_le/spanspan class=\"p\"(/spanspan class=\"o\"-/spanspan class=\"mi\"9223372036854775808/spanspan class=\"p\",/spanspan class=\"w\" /spanspan class=\"n\"x/spanspan class=\"p\")/spanspan class=\"w\" /spanspan class=\"o\"-gt;/spanspan class=\"w\" /spanspan class=\"mi\"1/span\nspan class=\"n\"int_le/spanspan class=\"p\"(/spanspan class=\"n\"x/spanspan class=\"p\",/spanspan class=\"w\" /spanspan class=\"mi\"9223372036854775807/spanspan class=\"p\")/spanspan class=\"w\" /spanspan class=\"o\"-gt;/spanspan class=\"w\" /spanspan class=\"mi\"1/span\nspan class=\"n\"int_gt/spanspan class=\"p\"(/spanspan class=\"o\"-/spanspan class=\"mi\"9223372036854775808/spanspan class=\"p\",/spanspan class=\"w\" /spanspan class=\"n\"x/spanspan class=\"p\")/spanspan class=\"w\" /spanspan class=\"o\"-gt;/spanspan class=\"w\" /spanspan class=\"mi\"0/span\nspan class=\"n\"int_gt/spanspan class=\"p\"(/spanspan class=\"n\"x/spanspan class=\"p\",/spanspan class=\"w\" /spanspan class=\"mi\"9223372036854775807/spanspan class=\"p\")/spanspan class=\"w\" /spanspan class=\"o\"-gt;/spanspan class=\"w\" /spanspan class=\"mi\"0/span\nspan class=\"n\"int_ge/spanspan class=\"p\"(/spanspan class=\"mi\"9223372036854775807/spanspan class=\"p\",/spanspan class=\"w\" /spanspan class=\"n\"x/spanspan class=\"p\")/spanspan class=\"w\" /spanspan class=\"o\"-gt;/spanspan class=\"w\" /spanspan class=\"mi\"1/span\nspan class=\"n\"int_ge/spanspan class=\"p\"(/spanspan class=\"n\"x/spanspan class=\"p\",/spanspan class=\"w\" /spanspan class=\"o\"-/spanspan class=\"mi\"9223372036854775808/spanspan class=\"p\")/spanspan class=\"w\" /spanspan class=\"o\"-gt;/spanspan class=\"w\" /spanspan class=\"mi\"1/span\n/pre/div\n\npThe following ones are true because the bitpattern for code-1/code is the largest\nunsigned number:/p\ndiv class=\"code\"pre class=\"code literal-block\"span class=\"n\"uint_lt/spanspan class=\"p\"(/spanspan class=\"o\"-/spanspan class=\"mi\"1/spanspan class=\"p\",/spanspan class=\"w\" /spanspan class=\"n\"x/spanspan class=\"p\")/spanspan class=\"w\" /spanspan class=\"o\"-gt;/spanspan class=\"w\" /spanspan class=\"mi\"0/span\nspan class=\"n\"uint_le/spanspan class=\"p\"(/spanspan class=\"n\"x/spanspan class=\"p\",/spanspan class=\"w\" /spanspan class=\"o\"-/spanspan class=\"mi\"1/spanspan class=\"p\")/spanspan class=\"w\" /spanspan class=\"o\"-gt;/spanspan class=\"w\" /spanspan class=\"mi\"1/span\nspan class=\"n\"uint_gt/spanspan class=\"p\"(/spanspan class=\"n\"x/spanspan class=\"p\",/spanspan class=\"w\" /spanspan class=\"o\"-/spanspan class=\"mi\"1/spanspan class=\"p\")/spanspan class=\"w\" /spanspan class=\"o\"-gt;/spanspan class=\"w\" /spanspan class=\"mi\"0/span\nspan class=\"n\"uint_ge/spanspan class=\"p\"(/spanspan class=\"o\"-/spanspan class=\"mi\"1/spanspan class=\"p\",/spanspan class=\"w\" /spanspan class=\"n\"x/spanspan class=\"p\")/spanspan class=\"w\" /spanspan class=\"o\"-gt;/spanspan class=\"w\" /spanspan class=\"mi\"1/span\n/pre/div\n\nh3 id=\"strength-reductions\"Strength Reductions/h3\npAll the patterns so far only had a variable or a constant on the target of the\nrewrite. We can also use the machinery to do strengh-reductions where we\ngenerate a single-argument operation codeop1(x)/code for input operations codeop(x, c1)/code\nor codeop(c1, x)/code. To achieve this, we try all combinations of binary and unary\noperations. (We won't consider strength reductions where a binary operation\ngets turned into a \"cheaper\" other binary operation here.)/p\ndiv class=\"code\"pre class=\"code literal-block\"span class=\"n\"opnames1/span span class=\"o\"=/span span class=\"p\"[/span\nspan class=\"s2\"\"int_is_true\"/spanspan class=\"p\",/span\nspan class=\"s2\"\"int_is_zero\"/spanspan class=\"p\",/span\nspan class=\"s2\"\"int_neg\"/spanspan class=\"p\",/span\nspan class=\"s2\"\"int_invert\"/spanspan class=\"p\",/span\nspan class=\"p\"]/span\n\nspan class=\"k\"for/span span class=\"n\"opname/span span class=\"ow\"in/span span class=\"n\"opnames2/spanspan class=\"p\":/span\n    span class=\"k\"for/span span class=\"n\"opname1/span span class=\"ow\"in/span span class=\"n\"opnames1/spanspan class=\"p\":/span\n        span class=\"n\"result/spanspan class=\"p\",/span span class=\"n\"valid_if/span span class=\"o\"=/span span class=\"n\"z3_expression/spanspan class=\"p\"(/spanspan class=\"n\"opname/spanspan class=\"p\",/span span class=\"n\"xvar/spanspan class=\"p\",/span span class=\"n\"constvar/spanspan class=\"p\")/span\n        span class=\"c1\"# try to find a constant op(x, c) == g(x)/span\n        span class=\"n\"result1/spanspan class=\"p\",/span span class=\"n\"valid_if1/span span class=\"o\"=/span span class=\"n\"z3_expression/spanspan class=\"p\"(/spanspan class=\"n\"opname1/spanspan class=\"p\",/span span class=\"n\"xvar/spanspan class=\"p\")/span\n        span class=\"n\"consts/span span class=\"o\"=/span span class=\"n\"find_constant/spanspan class=\"p\"(/spanspan class=\"n\"z3/spanspan class=\"o\"./spanspan class=\"n\"And/spanspan class=\"p\"(/spanspan class=\"n\"valid_if/spanspan class=\"p\",/span span class=\"n\"valid_if1/spanspan class=\"p\",/span span class=\"n\"result/span span class=\"o\"==/span span class=\"n\"result1/spanspan class=\"p\"))/span\n        span class=\"k\"for/span span class=\"n\"const/span span class=\"ow\"in/span span class=\"n\"consts/spanspan class=\"p\":/span\n            span class=\"nb\"print/spanspan class=\"p\"(/spanspan class=\"sa\"f/spanspan class=\"s2\"\"/spanspan class=\"si\"{/spanspan class=\"n\"opname/spanspan class=\"si\"}/spanspan class=\"s2\"(x, /spanspan class=\"si\"{/spanspan class=\"n\"const/spanspan class=\"si\"}/spanspan class=\"s2\") -gt; /spanspan class=\"si\"{/spanspan class=\"n\"opname1/spanspan class=\"si\"}/spanspan class=\"s2\"(x)\"/spanspan class=\"p\")/span\n\n        span class=\"c1\"# try to find a constant op(c, x) == g(x)/span\n        span class=\"n\"result/spanspan class=\"p\",/span span class=\"n\"valid_if/span span class=\"o\"=/span span class=\"n\"z3_expression/spanspan class=\"p\"(/spanspan class=\"n\"opname/spanspan class=\"p\",/span span class=\"n\"constvar/spanspan class=\"p\",/span span class=\"n\"xvar/spanspan class=\"p\")/span\n        span class=\"n\"result1/spanspan class=\"p\",/span span class=\"n\"valid_if1/span span class=\"o\"=/span span class=\"n\"z3_expression/spanspan class=\"p\"(/spanspan class=\"n\"opname1/spanspan class=\"p\",/span span class=\"n\"xvar/spanspan class=\"p\")/span\n        span class=\"n\"consts/span span class=\"o\"=/span span class=\"n\"find_constant/spanspan class=\"p\"(/spanspan class=\"n\"z3/spanspan class=\"o\"./spanspan class=\"n\"And/spanspan class=\"p\"(/spanspan class=\"n\"valid_if/spanspan class=\"p\",/span span class=\"n\"valid_if1/spanspan class=\"p\",/span span class=\"n\"result/span span class=\"o\"==/span span class=\"n\"result1/spanspan class=\"p\"))/span\n        span class=\"k\"for/span span class=\"n\"const/span span class=\"ow\"in/span span class=\"n\"consts/spanspan class=\"p\":/span\n            span class=\"nb\"print/spanspan class=\"p\"(/spanspan class=\"sa\"f/spanspan class=\"s2\"\"/spanspan class=\"si\"{/spanspan class=\"n\"opname/spanspan class=\"si\"}/spanspan class=\"s2\"(/spanspan class=\"si\"{/spanspan class=\"n\"const/spanspan class=\"si\"}/spanspan class=\"s2\", x) -gt; /spanspan class=\"si\"{/spanspan class=\"n\"opname1/spanspan class=\"si\"}/spanspan class=\"s2\"(x)\"/spanspan class=\"p\")/span\n/pre/div\n\npWhich yields the following new simplifications:/p\ndiv class=\"code\"pre class=\"code literal-block\"span class=\"n\"int_sub/spanspan class=\"p\"(/spanspan class=\"mi\"0/spanspan class=\"p\",/spanspan class=\"w\" /spanspan class=\"n\"x/spanspan class=\"p\")/spanspan class=\"w\" /spanspan class=\"o\"-gt;/spanspan class=\"w\" /spanspan class=\"n\"int_neg/spanspan class=\"p\"(/spanspan class=\"n\"x/spanspan class=\"p\")/span\nspan class=\"n\"int_sub/spanspan class=\"p\"(/spanspan class=\"o\"-/spanspan class=\"mi\"1/spanspan class=\"p\",/spanspan class=\"w\" /spanspan class=\"n\"x/spanspan class=\"p\")/spanspan class=\"w\" /spanspan class=\"o\"-gt;/spanspan class=\"w\" /spanspan class=\"n\"int_invert/spanspan class=\"p\"(/spanspan class=\"n\"x/spanspan class=\"p\")/span\nspan class=\"n\"int_mul/spanspan class=\"p\"(/spanspan class=\"n\"x/spanspan class=\"p\",/spanspan class=\"w\" /spanspan class=\"o\"-/spanspan class=\"mi\"1/spanspan class=\"p\")/spanspan class=\"w\" /spanspan class=\"o\"-gt;/spanspan class=\"w\" /spanspan class=\"n\"int_neg/spanspan class=\"p\"(/spanspan class=\"n\"x/spanspan class=\"p\")/span\nspan class=\"n\"int_mul/spanspan class=\"p\"(/spanspan class=\"o\"-/spanspan class=\"mi\"1/spanspan class=\"p\",/spanspan class=\"w\" /spanspan class=\"n\"x/spanspan class=\"p\")/spanspan class=\"w\" /spanspan class=\"o\"-gt;/spanspan class=\"w\" /spanspan class=\"n\"int_neg/spanspan class=\"p\"(/spanspan class=\"n\"x/spanspan class=\"p\")/span\nspan class=\"n\"int_xor/spanspan class=\"p\"(/spanspan class=\"n\"x/spanspan class=\"p\",/spanspan class=\"w\" /spanspan class=\"o\"-/spanspan class=\"mi\"1/spanspan class=\"p\")/spanspan class=\"w\" /spanspan class=\"o\"-gt;/spanspan class=\"w\" /spanspan class=\"n\"int_invert/spanspan class=\"p\"(/spanspan class=\"n\"x/spanspan class=\"p\")/span\nspan class=\"n\"int_xor/spanspan class=\"p\"(/spanspan class=\"o\"-/spanspan class=\"mi\"1/spanspan class=\"p\",/spanspan class=\"w\" /spanspan class=\"n\"x/spanspan class=\"p\")/spanspan class=\"w\" /spanspan class=\"o\"-gt;/spanspan class=\"w\" /spanspan class=\"n\"int_invert/spanspan class=\"p\"(/spanspan class=\"n\"x/spanspan class=\"p\")/span\nspan class=\"n\"int_eq/spanspan class=\"p\"(/spanspan class=\"n\"x/spanspan class=\"p\",/spanspan class=\"w\" /spanspan class=\"mi\"0/spanspan class=\"p\")/spanspan class=\"w\" /spanspan class=\"o\"-gt;/spanspan class=\"w\" /spanspan class=\"n\"int_is_zero/spanspan class=\"p\"(/spanspan class=\"n\"x/spanspan class=\"p\")/span\nspan class=\"n\"int_eq/spanspan class=\"p\"(/spanspan class=\"mi\"0/spanspan class=\"p\",/spanspan class=\"w\" /spanspan class=\"n\"x/spanspan class=\"p\")/spanspan class=\"w\" /spanspan class=\"o\"-gt;/spanspan class=\"w\" /spanspan class=\"n\"int_is_zero/spanspan class=\"p\"(/spanspan class=\"n\"x/spanspan class=\"p\")/span\nspan class=\"n\"int_ne/spanspan class=\"p\"(/spanspan class=\"n\"x/spanspan class=\"p\",/spanspan class=\"w\" /spanspan class=\"mi\"0/spanspan class=\"p\")/spanspan class=\"w\" /spanspan class=\"o\"-gt;/spanspan class=\"w\" /spanspan class=\"n\"int_is_true/spanspan class=\"p\"(/spanspan class=\"n\"x/spanspan class=\"p\")/span\nspan class=\"n\"int_ne/spanspan class=\"p\"(/spanspan class=\"mi\"0/spanspan class=\"p\",/spanspan class=\"w\" /spanspan class=\"n\"x/spanspan class=\"p\")/spanspan class=\"w\" /spanspan class=\"o\"-gt;/spanspan class=\"w\" /spanspan class=\"n\"int_is_true/spanspan class=\"p\"(/spanspan class=\"n\"x/spanspan class=\"p\")/span\nspan class=\"n\"uint_lt/spanspan class=\"p\"(/spanspan class=\"mi\"0/spanspan class=\"p\",/spanspan class=\"w\" /spanspan class=\"n\"x/spanspan class=\"p\")/spanspan class=\"w\" /spanspan class=\"o\"-gt;/spanspan class=\"w\" /spanspan class=\"n\"int_is_true/spanspan class=\"p\"(/spanspan class=\"n\"x/spanspan class=\"p\")/span\nspan class=\"n\"uint_lt/spanspan class=\"p\"(/spanspan class=\"n\"x/spanspan class=\"p\",/spanspan class=\"w\" /spanspan class=\"mi\"1/spanspan class=\"p\")/spanspan class=\"w\" /spanspan class=\"o\"-gt;/spanspan class=\"w\" /spanspan class=\"n\"int_is_zero/spanspan class=\"p\"(/spanspan class=\"n\"x/spanspan class=\"p\")/span\nspan class=\"n\"uint_le/spanspan class=\"p\"(/spanspan class=\"mi\"1/spanspan class=\"p\",/spanspan class=\"w\" /spanspan class=\"n\"x/spanspan class=\"p\")/spanspan class=\"w\" /spanspan class=\"o\"-gt;/spanspan class=\"w\" /spanspan class=\"n\"int_is_true/spanspan class=\"p\"(/spanspan class=\"n\"x/spanspan class=\"p\")/span\nspan class=\"n\"uint_le/spanspan class=\"p\"(/spanspan class=\"n\"x/spanspan class=\"p\",/spanspan class=\"w\" /spanspan class=\"mi\"0/spanspan class=\"p\")/spanspan class=\"w\" /spanspan class=\"o\"-gt;/spanspan class=\"w\" /spanspan class=\"n\"int_is_zero/spanspan class=\"p\"(/spanspan class=\"n\"x/spanspan class=\"p\")/span\nspan class=\"n\"uint_gt/spanspan class=\"p\"(/spanspan class=\"n\"x/spanspan class=\"p\",/spanspan class=\"w\" /spanspan class=\"mi\"0/spanspan class=\"p\")/spanspan class=\"w\" /spanspan class=\"o\"-gt;/spanspan class=\"w\" /spanspan class=\"n\"int_is_true/spanspan class=\"p\"(/spanspan class=\"n\"x/spanspan class=\"p\")/span\nspan class=\"n\"uint_gt/spanspan class=\"p\"(/spanspan class=\"mi\"1/spanspan class=\"p\",/spanspan class=\"w\" /spanspan class=\"n\"x/spanspan class=\"p\")/spanspan class=\"w\" /spanspan class=\"o\"-gt;/spanspan class=\"w\" /spanspan class=\"n\"int_is_zero/spanspan class=\"p\"(/spanspan class=\"n\"x/spanspan class=\"p\")/span\nspan class=\"n\"uint_ge/spanspan class=\"p\"(/spanspan class=\"n\"x/spanspan class=\"p\",/spanspan class=\"w\" /spanspan class=\"mi\"1/spanspan class=\"p\")/spanspan class=\"w\" /spanspan class=\"o\"-gt;/spanspan class=\"w\" /spanspan class=\"n\"int_is_true/spanspan class=\"p\"(/spanspan class=\"n\"x/spanspan class=\"p\")/span\nspan class=\"n\"uint_ge/spanspan class=\"p\"(/spanspan class=\"mi\"0/spanspan class=\"p\",/spanspan class=\"w\" /spanspan class=\"n\"x/spanspan class=\"p\")/spanspan class=\"w\" /spanspan class=\"o\"-gt;/spanspan class=\"w\" /spanspan class=\"n\"int_is_zero/spanspan class=\"p\"(/spanspan class=\"n\"x/spanspan class=\"p\")/span\nspan class=\"n\"int_pydiv/spanspan class=\"p\"(/spanspan class=\"n\"x/spanspan class=\"p\",/spanspan class=\"w\" /spanspan class=\"o\"-/spanspan class=\"mi\"1/spanspan class=\"p\")/spanspan class=\"w\" /spanspan class=\"o\"-gt;/spanspan class=\"w\" /spanspan class=\"n\"int_neg/spanspan class=\"p\"(/spanspan class=\"n\"x/spanspan class=\"p\")/span\n/pre/div\n\nh3 id=\"conclusions\"Conclusions/h3\npWith not very little code we managed to generate a whole lot of local\nsimplifications for integer operations in the IR of PyPy's JIT. The rules\ndiscovered that way are \"simple\", in the sense that they only require looking\nat a single instruction, and not where the arguments of that instruction came\nfrom. They also don't require any knowledge about the properties of the\narguments of the instructions (e.g. that they are positive)./p\npThe rewrites in this post have mostly been in PyPy's JIT already. But now we\nmechanically confirmed that they are correct. I've also added the remaining\nuseful looking ones, in particular codeint_eq(x, 0) -gt; int_is_zero(x)/code etc./p\npIf we wanted to scale this approach up, we would have to work much harder!\nThere are a bunch of problems that come with generalizing the approach to\nlooking at sequences of instructions:/p\nul\nli\npCombinatorial explosion: if we look at sequences of instructions, we very\n  quickly get a combinatorial explosion and it becomes untractable to try all\n  combinations./p\n/li\nli\npFinding non-minimal patterns: Some complicated simplifications can be\n  instances of simpler ones. For example, because codeint_add(x, 0) -gt; x/code, it's\n  also true that codeint_add(int_sub(x, y), 0) -gt; int_sub(x, y)/code. If we simply\n  generate all possible sequences, we will find the latter simplification rule,\n  which we would usually not care about./p\n/li\nli\npUnclear usefulness: if we simply generate all rewrites up to a certain number\n  of instructions, we will get a lot of patterns that are useless in the sense\n  that they typically aren't found in realistic programs. It would be much\n  better to somehow focus on the patterns that real benchmarks are using./p\n/li\n/ul\npIn the a href=\"https://www.pypy.org/posts/2024/07/mining-jit-traces-missing-optimizations-z3.html\"next blog post/a I'll discuss an alternative approach to simply generating\nall possible sequences of instructions, that tries to address these problems.\nThis works by analyzing the real traces of benchmarks and mining those for\ninefficiencies, which only shows problems that occur in actual programs./p\nh3 id=\"sources\"Sources/h3\npI've been re-reading a lot of blog posts from John's blog:/p\nul\nlia href=\"https://blog.regehr.org/archives/1109\"Lets Work on an LLVM Superoptimizer/a/li\nlia href=\"https://blog.regehr.org/archives/1146\"Early Superoptimizer Results/a/li\nlia href=\"https://blog.regehr.org/archives/1252\"A Few Synthesizing Superoptimizer Results/a/li\nlia href=\"https://blog.regehr.org/archives/1636\"Synthesizing Constants/a/li\n/ul\npbut also papers:/p\nul\nlia href=\"https://arxiv.org/pdf/1711.04422\"A Synthesizing Superoptimizer/a/li\nlia href=\"https://dl.acm.org/doi/pdf/10.1145/3649837\"Hydra: Generalizing Peephole Optimizations with Program Synthesis/a/li\n/ul\npAnother of my favorite blogs has been a href=\"https://www.philipzucker.com/\"Philipp Zucker's\nblog/a in the last year or two, lots of excellent\nposts about/using Z3 on there./p"
        }
      ],
      "description": "pIn June I was at the a href=\"https://pldi24.sigplan.org/\"PLDI conference/a in\nCopenhagen to present a a href=\"https://dl.acm.org/doi/10.1145/3652588.3663316\"paper/a\nI co-authored with a href=\"https://bernsteinbear.com/\"Max Bernstein/a. I also finally\nmet a href=\"https://blog.regehr.org/\"John Regehr/a, who I'd been talking on social\nmedia for ages but had never met. John has been working on compiler correctness\nand better techniques for building compilers and optimizers since a very long\ntime. The blog post a href=\"https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html\"Finding JIT Optimizer Bugs using SMT Solvers and\nFuzzing/a\nwas heavily inspired by this work. We talked a lot about his and his groups\nwork on using Z3 for\na href=\"https://en.wikipedia.org/wiki/Superoptimization\"superoptimization/a and for\nfinding missing optimizations. I have applied some of the things John told me\nabout to the traces of PyPy's JIT, and wanted to blog about that. However, my\ndraft felt quite hard to understand. Therefore I have now written this current\npost, to at least try to provide a somewhat gentler on-ramp to the topic./p\npIn emthis/em post we will use the Python-API to Z3 to find local peephole rewrite\nrules for the operations in the intermediate representation of PyPy's tracing\nJIT. The code for this is simple enough that we can go through all of it./p\npThe PyPy JIT produces traces of machine level instructions, which are optimized\nand then turned into machine code. The optimizer uses a number of approaches to\nmake the traces more efficient. For integer operations it applies a number of\narithmetic simplification rules rules, for example codeint_add(x, 0) -gt; x/code. When\nimplementing these rules in the JIT there are strongtwo problems/strong: How do we know\nthat the rules are correct? And how do we know that we haven't forgotten any\nrules? We'll try to answer both of these, but the first one in particular./p\npWe'll be using Z3, a satisfiability module theories (SMT) solver which has good\nbitvector support and most importantly an excellent Python API. We can use the\nsolver to reason about bitvectors, which are how we will model machine\nintegers./p\npTo find rewrite rules, we will consider the binary operations (i.e. those\ntaking two arguments) in PyPy traces that take and produce integers. The\ncompletely general form codeop(x, y)/code is not simplifiable on its own. But if\neither codex == y/code\nor if one of the arguments is a constant, we can potentially simplify the\noperation into a simpler form. The results are either the variable codex/code, or a\n(potentially different) constant. We'll ignore constant-folding where both\narguments of the binary operation are constants. The possible results for a\nsimplifiable binary operation are the variable codex/code or another constant. This\nleaves the following patterns as possibilities:/p\nul\nlicodeop(x, x) == x/code/li\nlicodeop(x, x) == c1/code/li\nlicodeop(x, c1) == x/code/li\nlicodeop(c1, x) == x/code/li\nlicodeop(x, c1) == c2/code/li\nlicodeop(c1, x) == c2/code/li\n/ul\npOur approach will be to take every single supported binary integer operation,\ninstantiate all of these patterns, and try to ask Z3 whether the resulting\nsimplification is valid for all values of codex/code./p\nh3 id=\"quick-intro-to-the-z3-python-api\"Quick intro to the Z3 Python-API/h3\npHere's a terminal session showing the use of the Z3 Python API:/p\ndiv class=\"code\"pre class=\"code literal-block\"span class=\"go\"gt;gt;gt;gt; import z3/span\nspan class=\"go\"gt;gt;gt;gt; # construct a Z3 bitvector variable of width 8, with name x:/span\nspan class=\"go\"gt;gt;gt;gt; x = z3.BitVec('x', 8)/span\nspan class=\"go\"gt;gt;gt;gt; # construct a more complicated formula by using operator overloading:/span\nspan class=\"go\"gt;gt;gt;gt; x + x/span\nspan class=\"go\"x + x/span\nspan class=\"go\"gt;gt;gt;gt; x + 1/span\nspan class=\"go\"x + 1/span\n/pre/div\n\npZ3 checks the \"satisfiability\" of a formula. This means that it tries to find\nan example set of concrete values for the variables that occur in a formula,\nsuch that the formula becomes true. Examples:/p\ndiv class=\"code\"pre class=\"code literal-block\"span class=\"go\"gt;gt;gt;gt; solver = z3.Solver()/span\nspan class=\"go\"gt;gt;gt;gt; solver.check(x * x == 3)/span\nspan class=\"go\"unsat/span\nspan class=\"go\"gt;gt;gt;gt; # meaning no x fulfils this property/span\nspan class=\"go\"gt;gt;gt;gt;/span\nspan class=\"go\"gt;gt;gt;gt; solver.check(x * x == 9)/span\nspan class=\"go\"sat/span\nspan class=\"go\"gt;gt;gt;gt; model = solver.model()/span\nspan class=\"go\"gt;gt;gt;gt; model/span\nspan class=\"go\"[x = 253]/span\nspan class=\"go\"gt;gt;gt;gt; model[x].as_signed_long()/span\nspan class=\"go\"-3/span\nspan class=\"go\"gt;gt;gt;gt; # 253 is the same as -3 in two's complement arithmetic with 8 bits/span\n/pre/div\n\npIn order to use Z3 to prove something, we can ask Z3 to find counterexamples\nfor the statement, meaning concrete values that would make the negation of the\nstatement true:/p\ndiv class=\"code\"pre class=\"code literal-block\"span class=\"go\"gt;gt;gt;gt; solver.check(z3.Not(x ^ -1 == ~x))/span\nspan class=\"go\"unsat/span\n/pre/div\n\npThe result codeunsat/code means that we just proved that codex ^ -1 == ~x/code is true for\nall codex/code, because there is no value for codex/code that makes codenot (x ^ -1 == ~x)/code\ntrue (this works because -1 has all the bits set)./p\npIf we try to prove something incorrect in this way, the following happens:/p\ndiv class=\"code\"pre class=\"code literal-block\"span class=\"go\"gt;gt;gt;gt; solver.check(z3.Not(x ^ -1 == x))/span\nspan class=\"go\"sat/span\n/pre/div\n\npcodesat/code shows that codex ^ -1 == x/code is (unsurprisingly) not always true, and we can\nask for a counterexample:/p\ndiv class=\"code\"pre class=\"code literal-block\"span class=\"go\"gt;gt;gt;gt; solver.model()/span\nspan class=\"go\"[x = 0]/span\n/pre/div\n\npThis way of proving this works because the codecheck/code calls try to solve an\n(implicit) \"exists\" quantifier, over all the Z3 variables used in the formula.\ncodecheck/code will either return codez3.unsat/code, which means that no concrete values make\nthe formula true; or codez3.sat/code, which means that you can get some concrete\nvalues that make the formula true by calling codesolver.model()/code./p\npIn math terms we prove things using codecheck/code by de-Morgan's rules for quantifiers:/p\np$$ \\lnot \\exists x: \\lnot f(x) \\implies \\forall x: f(x) $$/p\npNow that we've seen the basics of using the Z3 API on a few small examples,\nwe'll use it in a bigger program./p\nh3 id=\"encoding-the-integer-operations-of-rpythons-jit-into-z3-formulas\"Encoding the integer operations of RPython's JIT into Z3 formulas/h3\npNow we'll use the API to reason about the integer operations of the PyPy JIT\nintermediate representation (IR). The binary integer operations are:/p\ndiv class=\"code\"pre class=\"code literal-block\"span class=\"n\"opnames2/span span class=\"o\"=/span span class=\"p\"[/span\nspan class=\"s2\"\"int_add\"/spanspan class=\"p\",/span\nspan class=\"s2\"\"int_sub\"/spanspan class=\"p\",/span\nspan class=\"s2\"\"int_mul\"/spanspan class=\"p\",/span\nspan class=\"s2\"\"int_and\"/spanspan class=\"p\",/span\nspan class=\"s2\"\"int_or\"/spanspan class=\"p\",/span\nspan class=\"s2\"\"int_xor\"/spanspan class=\"p\",/span\nspan class=\"s2\"\"int_eq\"/spanspan class=\"p\",/span\nspan class=\"s2\"\"int_ne\"/spanspan class=\"p\",/span\nspan class=\"s2\"\"int_lt\"/spanspan class=\"p\",/span\nspan class=\"s2\"\"int_le\"/spanspan class=\"p\",/span\nspan class=\"s2\"\"int_gt\"/spanspan class=\"p\",/span\nspan class=\"s2\"\"int_ge\"/spanspan class=\"p\",/span\nspan class=\"s2\"\"uint_lt\"/spanspan class=\"p\",/span\nspan class=\"s2\"\"uint_le\"/spanspan class=\"p\",/span\nspan class=\"s2\"\"uint_gt\"/spanspan class=\"p\",/span\nspan class=\"s2\"\"uint_ge\"/spanspan class=\"p\",/span\nspan class=\"s2\"\"int_lshift\"/spanspan class=\"p\",/span\nspan class=\"s2\"\"int_rshift\"/spanspan class=\"p\",/span\nspan class=\"s2\"\"uint_rshift\"/spanspan class=\"p\",/span\nspan class=\"s2\"\"uint_mul_high\"/spanspan class=\"p\",/span\nspan class=\"s2\"\"int_pydiv\"/spanspan class=\"p\",/span\nspan class=\"s2\"\"int_pymod\"/spanspan class=\"p\",/span\nspan class=\"p\"]/span\n/pre/div\n\npThere's not much special about the integer operations. Like in LLVM, most of\nthem are signedness-independent: codeint_add/code, codeint_sub/code, codeint_mul/code, ... work\ncorrectly for unsigned integers but also for\na href=\"https://en.wikipedia.org/wiki/Two%27s_complement\"two's-complement/a signed\nintegers. Exceptions for that are order comparisons like codeint_lt/code etc. for\nwhich we have unsigned variants codeuint_lt/code etc. All operations that produce a\nboolean result return a full-width integer code0/code or code1/code (the PyPy JIT supports\nonly word-sized integers in its intermediate representation)/p\npIn order to reason about the IR operations, some ground work:/p\ndiv class=\"code\"pre class=\"code literal-block\"span class=\"kn\"import/span span class=\"nn\"z3/span\n\nspan class=\"n\"INTEGER_WIDTH/span span class=\"o\"=/span span class=\"mi\"64/span\nspan class=\"n\"solver/span span class=\"o\"=/span span class=\"n\"z3/spanspan class=\"o\"./spanspan class=\"n\"Solver/spanspan class=\"p\"()/span\nspan class=\"n\"solver/spanspan class=\"o\"./spanspan class=\"n\"set/spanspan class=\"p\"(/spanspan class=\"s2\"\"timeout\"/spanspan class=\"p\",/span span class=\"mi\"10000/spanspan class=\"p\")/span span class=\"c1\"# milliseconds, ie 10s/span\nspan class=\"n\"xvar/span span class=\"o\"=/span span class=\"n\"z3/spanspan class=\"o\"./spanspan class=\"n\"BitVec/spanspan class=\"p\"(/spanspan class=\"s1\"'x'/spanspan class=\"p\",/span span class=\"n\"INTEGER_WIDTH/spanspan class=\"p\")/span\nspan class=\"n\"constvar/span span class=\"o\"=/span span class=\"n\"z3/spanspan class=\"o\"./spanspan class=\"n\"BitVec/spanspan class=\"p\"(/spanspan class=\"s1\"'const'/spanspan class=\"p\",/span span class=\"n\"INTEGER_WIDTH/spanspan class=\"p\")/span\nspan class=\"n\"constvar2/span span class=\"o\"=/span span class=\"n\"z3/spanspan class=\"o\"./spanspan class=\"n\"BitVec/spanspan class=\"p\"(/spanspan class=\"s1\"'const2'/spanspan class=\"p\",/span span class=\"n\"INTEGER_WIDTH/spanspan class=\"p\")/span\nspan class=\"n\"TRUEBV/span span class=\"o\"=/span span class=\"n\"z3/spanspan class=\"o\"./spanspan class=\"n\"BitVecVal/spanspan class=\"p\"(/spanspan class=\"mi\"1/spanspan class=\"p\",/span span class=\"n\"INTEGER_WIDTH/spanspan class=\"p\")/span\nspan class=\"n\"FALSEBV/span span class=\"o\"=/span span class=\"n\"z3/spanspan class=\"o\"./spanspan class=\"n\"BitVecVal/spanspan class=\"p\"(/spanspan class=\"mi\"0/spanspan class=\"p\",/span span class=\"n\"INTEGER_WIDTH/spanspan class=\"p\")/span\n/pre/div\n\npAnd here's the a function to turn an integer IR operation of PyPy's JIT into Z3\nformulas:/p\ndiv class=\"code\"pre class=\"code literal-block\"span class=\"k\"def/span span class=\"nf\"z3_expression/spanspan class=\"p\"(/spanspan class=\"n\"opname/spanspan class=\"p\",/span span class=\"n\"arg0/spanspan class=\"p\",/span span class=\"n\"arg1/spanspan class=\"o\"=/spanspan class=\"kc\"None/spanspan class=\"p\"):/span\nspan class=\"w\"    /spanspan class=\"sd\"\"\"\" computes a tuple of (result, valid_if) of Z3 formulas. `result` is the/span\nspan class=\"sd\"    formula representing the result of the operation, given argument formulas/span\nspan class=\"sd\"    arg0 and arg1. `valid_if` is a pre-condition that must be true for the/span\nspan class=\"sd\"    result to be meaningful. \"\"\"/span\n    span class=\"n\"result/span span class=\"o\"=/span span class=\"kc\"None/span\n    span class=\"n\"valid_if/span span class=\"o\"=/span span class=\"kc\"True/span span class=\"c1\"# the precondition is mostly True, with few exceptions/span\n    span class=\"k\"if/span span class=\"n\"opname/span span class=\"o\"==/span span class=\"s2\"\"int_add\"/spanspan class=\"p\":/span\n        span class=\"n\"result/span span class=\"o\"=/span span class=\"n\"arg0/span span class=\"o\"+/span span class=\"n\"arg1/span\n    span class=\"k\"elif/span span class=\"n\"opname/span span class=\"o\"==/span span class=\"s2\"\"int_sub\"/spanspan class=\"p\":/span\n        span class=\"n\"result/span span class=\"o\"=/span span class=\"n\"arg0/span span class=\"o\"-/span span class=\"n\"arg1/span\n    span class=\"k\"elif/span span class=\"n\"opname/span span class=\"o\"==/span span class=\"s2\"\"int_mul\"/spanspan class=\"p\":/span\n        span class=\"n\"result/span span class=\"o\"=/span span class=\"n\"arg0/span span class=\"o\"*/span span class=\"n\"arg1/span\n    span class=\"k\"elif/span span class=\"n\"opname/span span class=\"o\"==/span span class=\"s2\"\"int_and\"/spanspan class=\"p\":/span\n        span class=\"n\"result/span span class=\"o\"=/span span class=\"n\"arg0/span span class=\"o\"amp;/span span class=\"n\"arg1/span\n    span class=\"k\"elif/span span class=\"n\"opname/span span class=\"o\"==/span span class=\"s2\"\"int_or\"/spanspan class=\"p\":/span\n        span class=\"n\"result/span span class=\"o\"=/span span class=\"n\"arg0/span span class=\"o\"|/span span class=\"n\"arg1/span\n    span class=\"k\"elif/span span class=\"n\"opname/span span class=\"o\"==/span span class=\"s2\"\"int_xor\"/spanspan class=\"p\":/span\n        span class=\"n\"result/span span class=\"o\"=/span span class=\"n\"arg0/span span class=\"o\"^/span span class=\"n\"arg1/span\n    span class=\"k\"elif/span span class=\"n\"opname/span span class=\"o\"==/span span class=\"s2\"\"int_eq\"/spanspan class=\"p\":/span\n        span class=\"n\"result/span span class=\"o\"=/span span class=\"n\"cond/spanspan class=\"p\"(/spanspan class=\"n\"arg0/span span class=\"o\"==/span span class=\"n\"arg1/spanspan class=\"p\")/span\n    span class=\"k\"elif/span span class=\"n\"opname/span span class=\"o\"==/span span class=\"s2\"\"int_ne\"/spanspan class=\"p\":/span\n        span class=\"n\"result/span span class=\"o\"=/span span class=\"n\"cond/spanspan class=\"p\"(/spanspan class=\"n\"arg0/span span class=\"o\"!=/span span class=\"n\"arg1/spanspan class=\"p\")/span\n    span class=\"k\"elif/span span class=\"n\"opname/span span class=\"o\"==/span span class=\"s2\"\"int_lt\"/spanspan class=\"p\":/span\n        span class=\"n\"result/span span class=\"o\"=/span span class=\"n\"cond/spanspan class=\"p\"(/spanspan class=\"n\"arg0/span span class=\"o\"lt;/span span class=\"n\"arg1/spanspan class=\"p\")/span\n    span class=\"k\"elif/span span class=\"n\"opname/span span class=\"o\"==/span span class=\"s2\"\"int_le\"/spanspan class=\"p\":/span\n        span class=\"n\"result/span span class=\"o\"=/span span class=\"n\"cond/spanspan class=\"p\"(/spanspan class=\"n\"arg0/span span class=\"o\"lt;=/span span class=\"n\"arg1/spanspan class=\"p\")/span\n    span class=\"k\"elif/span span class=\"n\"opname/span span class=\"o\"==/span span class=\"s2\"\"int_gt\"/spanspan class=\"p\":/span\n        span class=\"n\"result/span span class=\"o\"=/span span class=\"n\"cond/spanspan class=\"p\"(/spanspan class=\"n\"arg0/span span class=\"o\"gt;/span span class=\"n\"arg1/spanspan class=\"p\")/span\n    span class=\"k\"elif/span span class=\"n\"opname/span span class=\"o\"==/span span class=\"s2\"\"int_ge\"/spanspan class=\"p\":/span\n        span class=\"n\"result/span span class=\"o\"=/span span class=\"n\"cond/spanspan class=\"p\"(/spanspan class=\"n\"arg0/span span class=\"o\"gt;=/span span class=\"n\"arg1/spanspan class=\"p\")/span\n    span class=\"k\"elif/span span class=\"n\"opname/span span class=\"o\"==/span span class=\"s2\"\"uint_lt\"/spanspan class=\"p\":/span\n        span class=\"n\"result/span span class=\"o\"=/span span class=\"n\"cond/spanspan class=\"p\"(/spanspan class=\"n\"z3/spanspan class=\"o\"./spanspan class=\"n\"ULT/spanspan class=\"p\"(/spanspan class=\"n\"arg0/spanspan class=\"p\",/span span class=\"n\"arg1/spanspan class=\"p\"))/span\n    span class=\"k\"elif/span span class=\"n\"opname/span span class=\"o\"==/span span class=\"s2\"\"uint_le\"/spanspan class=\"p\":/span\n        span class=\"n\"result/span span class=\"o\"=/span span class=\"n\"cond/spanspan class=\"p\"(/spanspan class=\"n\"z3/spanspan class=\"o\"./spanspan class=\"n\"ULE/spanspan class=\"p\"(/spanspan class=\"n\"arg0/spanspan class=\"p\",/span span class=\"n\"arg1/spanspan class=\"p\"))/span\n    span class=\"k\"elif/span span class=\"n\"opname/span span class=\"o\"==/span span class=\"s2\"\"uint_gt\"/spanspan class=\"p\":/span\n        span class=\"n\"result/span span class=\"o\"=/span span class=\"n\"cond/spanspan class=\"p\"(/spanspan class=\"n\"z3/spanspan class=\"o\"./spanspan class=\"n\"UGT/spanspan class=\"p\"(/spanspan class=\"n\"arg0/spanspan class=\"p\",/span span class=\"n\"arg1/spanspan class=\"p\"))/span\n    span class=\"k\"elif/span span class=\"n\"opname/span span class=\"o\"==/span span class=\"s2\"\"uint_ge\"/spanspan class=\"p\":/span\n        span class=\"n\"result/span span class=\"o\"=/span span class=\"n\"cond/spanspan class=\"p\"(/spanspan class=\"n\"z3/spanspan class=\"o\"./spanspan class=\"n\"UGE/spanspan class=\"p\"(/spanspan class=\"n\"arg0/spanspan class=\"p\",/span span class=\"n\"arg1/spanspan class=\"p\"))/span\n    span class=\"k\"elif/span span class=\"n\"opname/span span class=\"o\"==/span span class=\"s2\"\"int_lshift\"/spanspan class=\"p\":/span\n        span class=\"n\"result/span span class=\"o\"=/span span class=\"n\"arg0/span span class=\"o\"lt;lt;/span span class=\"n\"arg1/span\n        span class=\"n\"valid_if/span span class=\"o\"=/span span class=\"n\"z3/spanspan class=\"o\"./spanspan class=\"n\"And/spanspan class=\"p\"(/spanspan class=\"n\"arg1/span span class=\"o\"gt;=/span span class=\"mi\"0/spanspan class=\"p\",/span span class=\"n\"arg1/span span class=\"o\"lt;/span span class=\"n\"INTEGER_WIDTH/spanspan class=\"p\")/span\n    span class=\"k\"elif/span span class=\"n\"opname/span span class=\"o\"==/span span class=\"s2\"\"int_rshift\"/spanspan class=\"p\":/span\n        span class=\"n\"result/span span class=\"o\"=/span span class=\"n\"arg0/span span class=\"o\"lt;lt;/span span class=\"n\"arg1/span\n        span class=\"n\"valid_if/span span class=\"o\"=/span span class=\"n\"z3/spanspan class=\"o\"./spanspan class=\"n\"And/spanspan class=\"p\"(/spanspan class=\"n\"arg1/span span class=\"o\"gt;=/span span class=\"mi\"0/spanspan class=\"p\",/span span class=\"n\"arg1/span span class=\"o\"lt;/span span class=\"n\"INTEGER_WIDTH/spanspan class=\"p\")/span\n    span class=\"k\"elif/span span class=\"n\"opname/span span class=\"o\"==/span span class=\"s2\"\"uint_rshift\"/spanspan class=\"p\":/span\n        span class=\"n\"result/span span class=\"o\"=/span span class=\"n\"z3/spanspan class=\"o\"./spanspan class=\"n\"LShR/spanspan class=\"p\"(/spanspan class=\"n\"arg0/spanspan class=\"p\",/span span class=\"n\"arg1/spanspan class=\"p\")/span\n        span class=\"n\"valid_if/span span class=\"o\"=/span span class=\"n\"z3/spanspan class=\"o\"./spanspan class=\"n\"And/spanspan class=\"p\"(/spanspan class=\"n\"arg1/span span class=\"o\"gt;=/span span class=\"mi\"0/spanspan class=\"p\",/span span class=\"n\"arg1/span span class=\"o\"lt;/span span class=\"n\"INTEGER_WIDTH/spanspan class=\"p\")/span\n    span class=\"k\"elif/span span class=\"n\"opname/span span class=\"o\"==/span span class=\"s2\"\"uint_mul_high\"/spanspan class=\"p\":/span\n        span class=\"c1\"# zero-extend args to 2*INTEGER_WIDTH bit, then multiply and extract/span\n        span class=\"c1\"# highest INTEGER_WIDTH bits/span\n        span class=\"n\"zarg0/span span class=\"o\"=/span span class=\"n\"z3/spanspan class=\"o\"./spanspan class=\"n\"ZeroExt/spanspan class=\"p\"(/spanspan class=\"n\"INTEGER_WIDTH/spanspan class=\"p\",/span span class=\"n\"arg0/spanspan class=\"p\")/span\n        span class=\"n\"zarg1/span span class=\"o\"=/span span class=\"n\"z3/spanspan class=\"o\"./spanspan class=\"n\"ZeroExt/spanspan class=\"p\"(/spanspan class=\"n\"INTEGER_WIDTH/spanspan class=\"p\",/span span class=\"n\"arg1/spanspan class=\"p\")/span\n        span class=\"n\"result/span span class=\"o\"=/span span class=\"n\"z3/spanspan class=\"o\"./spanspan class=\"n\"Extract/spanspan class=\"p\"(/spanspan class=\"n\"INTEGER_WIDTH/span span class=\"o\"*/span span class=\"mi\"2/span span class=\"o\"-/span span class=\"mi\"1/spanspan class=\"p\",/span span class=\"n\"INTEGER_WIDTH/spanspan class=\"p\",/span span class=\"n\"zarg0/span span class=\"o\"*/span span class=\"n\"zarg1/spanspan class=\"p\")/span\n    span class=\"k\"elif/span span class=\"n\"opname/span span class=\"o\"==/span span class=\"s2\"\"int_pydiv\"/spanspan class=\"p\":/span\n        span class=\"n\"valid_if/span span class=\"o\"=/span span class=\"n\"arg1/span span class=\"o\"!=/span span class=\"mi\"0/span\n        span class=\"n\"r/span span class=\"o\"=/span span class=\"n\"arg0/span span class=\"o\"//span span class=\"n\"arg1/span\n        span class=\"n\"psubx/span span class=\"o\"=/span span class=\"n\"r/span span class=\"o\"*/span span class=\"n\"arg1/span span class=\"o\"-/span span class=\"n\"arg0/span\n        span class=\"n\"result/span span class=\"o\"=/span span class=\"n\"r/span span class=\"o\"+/span span class=\"p\"(/spanspan class=\"n\"z3/spanspan class=\"o\"./spanspan class=\"n\"If/spanspan class=\"p\"(/spanspan class=\"n\"arg1/span span class=\"o\"lt;/span span class=\"mi\"0/spanspan class=\"p\",/span span class=\"n\"psubx/spanspan class=\"p\",/span span class=\"o\"-/spanspan class=\"n\"psubx/spanspan class=\"p\")/span span class=\"o\"gt;gt;/span span class=\"p\"(/spanspan class=\"n\"INTEGER_WIDTH/span span class=\"o\"-/span span class=\"mi\"1/spanspan class=\"p\"))/span\n    span class=\"k\"elif/span span class=\"n\"opname/span span class=\"o\"==/span span class=\"s2\"\"int_pymod\"/spanspan class=\"p\":/span\n        span class=\"n\"valid_if/span span class=\"o\"=/span span class=\"n\"arg1/span span class=\"o\"!=/span span class=\"mi\"0/span\n        span class=\"n\"r/span span class=\"o\"=/span span class=\"n\"arg0/span span class=\"o\"%/span span class=\"n\"arg1/span\n        span class=\"n\"result/span span class=\"o\"=/span span class=\"n\"r/span span class=\"o\"+/span span class=\"p\"(/spanspan class=\"n\"arg1/span span class=\"o\"amp;/span span class=\"n\"z3/spanspan class=\"o\"./spanspan class=\"n\"If/spanspan class=\"p\"(/spanspan class=\"n\"arg1/span span class=\"o\"lt;/span span class=\"mi\"0/spanspan class=\"p\",/span span class=\"o\"-/spanspan class=\"n\"r/spanspan class=\"p\",/span span class=\"n\"r/spanspan class=\"p\")/span span class=\"o\"gt;gt;/span span class=\"p\"(/spanspan class=\"n\"INTEGER_WIDTH/span span class=\"o\"-/span span class=\"mi\"1/spanspan class=\"p\"))/span\n    span class=\"k\"elif/span span class=\"n\"opname/span span class=\"o\"==/span span class=\"s2\"\"int_is_true\"/spanspan class=\"p\":/span\n        span class=\"n\"result/span span class=\"o\"=/span span class=\"n\"cond/spanspan class=\"p\"(/spanspan class=\"n\"arg0/span span class=\"o\"!=/span span class=\"n\"FALSEBV/spanspan class=\"p\")/span\n    span class=\"k\"elif/span span class=\"n\"opname/span span class=\"o\"==/span span class=\"s2\"\"int_is_zero\"/spanspan class=\"p\":/span\n        span class=\"n\"result/span span class=\"o\"=/span span class=\"n\"cond/spanspan class=\"p\"(/spanspan class=\"n\"arg0/span span class=\"o\"==/span span class=\"n\"FALSEBV/spanspan class=\"p\")/span\n    span class=\"k\"elif/span span class=\"n\"opname/span span class=\"o\"==/span span class=\"s2\"\"int_neg\"/spanspan class=\"p\":/span\n        span class=\"n\"result/span span class=\"o\"=/span span class=\"o\"-/spanspan class=\"n\"arg0/span\n    span class=\"k\"elif/span span class=\"n\"opname/span span class=\"o\"==/span span class=\"s2\"\"int_invert\"/spanspan class=\"p\":/span\n        span class=\"n\"result/span span class=\"o\"=/span span class=\"o\"~/spanspan class=\"n\"arg0/span\n    span class=\"k\"else/spanspan class=\"p\":/span\n        span class=\"k\"assert/span span class=\"mi\"0/spanspan class=\"p\",/span span class=\"s2\"\"unknown operation \"/span span class=\"o\"+/span span class=\"n\"opname/span\n    span class=\"k\"return/span span class=\"n\"result/spanspan class=\"p\",/span span class=\"n\"valid_if/span\n\nspan class=\"k\"def/span span class=\"nf\"cond/spanspan class=\"p\"(/spanspan class=\"n\"z3expr/spanspan class=\"p\"):/span\nspan class=\"w\"    /spanspan class=\"sd\"\"\"\" helper function to turn a Z3 boolean result z3expr into a 1 or 0/span\nspan class=\"sd\"    bitvector, using z3.If \"\"\"/span\n    span class=\"k\"return/span span class=\"n\"z3/spanspan class=\"o\"./spanspan class=\"n\"If/spanspan class=\"p\"(/spanspan class=\"n\"z3expr/spanspan class=\"p\",/span span class=\"n\"TRUEBV/spanspan class=\"p\",/span span class=\"n\"FALSEBV/spanspan class=\"p\")/span\n/pre/div\n\npWe map the semantics of a PyPy JIT operation to Z3 with the codez3_expression/code\nfunction. It takes the name of a JIT operation and its two (or one) arguments\ninto a pair of Z3 formulas, coderesult/code and codevalid_if/code. The resulting formulas are\nconstructed with the operator overloading of Z3 variables/formulas./p\npThe first element coderesult/code of the result of codez3_expression/code represents the result\nof performing the operation. codevalid_if/code is a bool that represents a condition that\nneeds to be codeTrue/code in order for the result of the operation to be defined. E.g.\ncodeint_pydiv(a, b)/code is only valid if codeb != 0/code. Most operations are always valid,\nso they return codeTrue/code as that condition (we'll ignore codevalid_if/code for a bit, but it\nwill become more relevant further down in the post)./p\npWe can define a helper function to prove things by finding counterexamples:/p\ndiv class=\"code\"pre class=\"code literal-block\"span class=\"k\"def/span span class=\"nf\"prove/spanspan class=\"p\"(/spanspan class=\"n\"cond/spanspan class=\"p\"):/span\nspan class=\"w\"    /spanspan class=\"sd\"\"\"\" Try to prove a condition cond by searching for counterexamples of its negation. \"\"\"/span\n    span class=\"n\"z3res/span span class=\"o\"=/span span class=\"n\"solver/spanspan class=\"o\"./spanspan class=\"n\"check/spanspan class=\"p\"(/spanspan class=\"n\"z3/spanspan class=\"o\"./spanspan class=\"n\"Not/spanspan class=\"p\"(/spanspan class=\"n\"cond/spanspan class=\"p\"))/span\n    span class=\"k\"if/span span class=\"n\"z3res/span span class=\"o\"==/span span class=\"n\"z3/spanspan class=\"o\"./spanspan class=\"n\"unsat/spanspan class=\"p\":/span\n        span class=\"k\"return/span span class=\"kc\"True/span\n    span class=\"k\"elif/span span class=\"n\"z3res/span span class=\"o\"==/span span class=\"n\"z3/spanspan class=\"o\"./spanspan class=\"n\"unknown/spanspan class=\"p\":/span span class=\"c1\"# eg on timeout/span\n        span class=\"k\"return/span span class=\"kc\"False/span\n    span class=\"k\"elif/span span class=\"n\"z3res/span span class=\"o\"==/span span class=\"n\"z3/spanspan class=\"o\"./spanspan class=\"n\"sat/spanspan class=\"p\":/span\n        span class=\"k\"return/span span class=\"kc\"False/span\n    span class=\"k\"assert/span span class=\"mi\"0/spanspan class=\"p\",/span span class=\"s2\"\"should be unreachable\"/span\n/pre/div\n\nh3 id=\"finding-rewrite-rules\"Finding rewrite rules/h3\npNow we can start finding our first rewrite rules, following the first pattern\ncodeop(x, x) -gt; x/code. We do this by iterating over all the supported binary\noperation names, getting the z3 expression for codeop(x, x)/code and then asking Z3 to\nprove codeop(x, x) == x/code./p\ndiv class=\"code\"pre class=\"code literal-block\"span class=\"k\"for/span span class=\"n\"opname/span span class=\"ow\"in/span span class=\"n\"opnames2/spanspan class=\"p\":/span\n    span class=\"n\"result/spanspan class=\"p\",/span span class=\"n\"valid_if/span span class=\"o\"=/span span class=\"n\"z3_expression/spanspan class=\"p\"(/spanspan class=\"n\"opname/spanspan class=\"p\",/span span class=\"n\"xvar/spanspan class=\"p\",/span span class=\"n\"xvar/spanspan class=\"p\")/span\n    span class=\"k\"if/span span class=\"n\"prove/spanspan class=\"p\"(/spanspan class=\"n\"result/span span class=\"o\"==/span span class=\"n\"xvar/spanspan class=\"p\"):/span\n        span class=\"nb\"print/spanspan class=\"p\"(/spanspan class=\"sa\"f/spanspan class=\"s2\"\"/spanspan class=\"si\"{/spanspan class=\"n\"opname/spanspan class=\"si\"}/spanspan class=\"s2\"(x, x) -gt; x, /spanspan class=\"si\"{/spanspan class=\"n\"result/spanspan class=\"si\"}/spanspan class=\"s2\"\"/spanspan class=\"p\")/span\n/pre/div\n\npThis yields the simplifications:/p\ndiv class=\"code\"pre class=\"code literal-block\"span class=\"n\"int_and/spanspan class=\"p\"(/spanspan class=\"n\"x/spanspan class=\"p\",/spanspan class=\"w\" /spanspan class=\"n\"x/spanspan class=\"p\")/spanspan class=\"w\" /spanspan class=\"o\"-gt;/spanspan class=\"w\" /spanspan class=\"n\"x/span\nspan class=\"n\"int_or/spanspan class=\"p\"(/spanspan class=\"n\"x/spanspan class=\"p\",/spanspan class=\"w\" /spanspan class=\"n\"x/spanspan class=\"p\")/spanspan class=\"w\" /spanspan class=\"o\"-gt;/spanspan class=\"w\" /spanspan class=\"n\"x/span\n/pre/div\n\nh3 id=\"synthesizing-constants\"Synthesizing constants/h3\npSupporting the next patterns is harder: codeop(x, x) == c1/code, codeop(x, c1) == x/code, and\ncodeop(c1, x) == x/code. We don't know which constants to pick to try to get Z3 to\nprove the equality. We could iterate over common constants like code0/code, code1/code,\ncodeMAXINT/code, etc, or even over all the 256 values for a bitvector of length 8.\nHowever, we will instead ask Z3 to find the constants for us too./p\npThis can be done by using quantifiers, in this case codez3.ForAll/code. The query we\npose to Z3 is \"does there exist a constant codec1/code such that for all codex/code the\nfollowing is true: codeop(x, c1) == x/code? Note that the constant codec1/code is not\nnecessarily unique, there could be many of them. We generate several matching\nconstant, and add that they must be different to the condition of the second\nand further queries./p\npWe can express this in a helper function:/p\ndiv class=\"code\"pre class=\"code literal-block\"span class=\"k\"def/span span class=\"nf\"find_constant/spanspan class=\"p\"(/spanspan class=\"n\"z3expr/spanspan class=\"p\",/span span class=\"n\"number_of_results/spanspan class=\"o\"=/spanspan class=\"mi\"5/spanspan class=\"p\"):/span\n    span class=\"n\"condition/span span class=\"o\"=/span span class=\"n\"z3/spanspan class=\"o\"./spanspan class=\"n\"ForAll/spanspan class=\"p\"(/span\n        span class=\"p\"[/spanspan class=\"n\"xvar/spanspan class=\"p\"],/span\n        span class=\"n\"z3expr/span\n    span class=\"p\")/span\n    span class=\"k\"for/span span class=\"n\"i/span span class=\"ow\"in/span span class=\"nb\"range/spanspan class=\"p\"(/spanspan class=\"n\"number_of_results/spanspan class=\"p\"):/span\n        span class=\"n\"checkres/span span class=\"o\"=/span span class=\"n\"solver/spanspan class=\"o\"./spanspan class=\"n\"check/spanspan class=\"p\"(/spanspan class=\"n\"condition/spanspan class=\"p\")/span\n        span class=\"k\"if/span span class=\"n\"checkres/span span class=\"o\"==/span span class=\"n\"z3/spanspan class=\"o\"./spanspan class=\"n\"sat/spanspan class=\"p\":/span\n            span class=\"c1\"# if a solver check succeeds, we can ask for a model, which is/span\n            span class=\"c1\"# concrete values for the variables constvar/span\n            span class=\"n\"model/span span class=\"o\"=/span span class=\"n\"solver/spanspan class=\"o\"./spanspan class=\"n\"model/spanspan class=\"p\"()/span\n            span class=\"n\"const/span span class=\"o\"=/span span class=\"n\"model/spanspan class=\"p\"[/spanspan class=\"n\"constvar/spanspan class=\"p\"]/spanspan class=\"o\"./spanspan class=\"n\"as_signed_long/spanspan class=\"p\"()/span\n            span class=\"k\"yield/span span class=\"n\"const/span\n            span class=\"c1\"# make sure we don't generate the same constant again on the/span\n            span class=\"c1\"# next call/span\n            span class=\"n\"condition/span span class=\"o\"=/span span class=\"n\"z3/spanspan class=\"o\"./spanspan class=\"n\"And/spanspan class=\"p\"(/spanspan class=\"n\"constvar/span span class=\"o\"!=/span span class=\"n\"const/spanspan class=\"p\",/span span class=\"n\"condition/spanspan class=\"p\")/span\n        span class=\"k\"else/spanspan class=\"p\":/span\n            span class=\"c1\"# no (more) constants found/span\n            span class=\"k\"break/span\n/pre/div\n\npWe can use this new function for the three mentioned patterns:/p\ndiv class=\"code\"pre class=\"code literal-block\"span class=\"c1\"# try to find constants for op(x, x) == c/span\nspan class=\"k\"for/span span class=\"n\"opname/span span class=\"ow\"in/span span class=\"n\"opnames2/spanspan class=\"p\":/span\n    span class=\"n\"result/spanspan class=\"p\",/span span class=\"n\"valid_if/span span class=\"o\"=/span span class=\"n\"z3_expression/spanspan class=\"p\"(/spanspan class=\"n\"opname/spanspan class=\"p\",/span span class=\"n\"xvar/spanspan class=\"p\",/span span class=\"n\"xvar/spanspan class=\"p\")/span\n    span class=\"k\"for/span span class=\"n\"const/span span class=\"ow\"in/span span class=\"n\"find_constant/spanspan class=\"p\"(/spanspan class=\"n\"result/span span class=\"o\"==/span span class=\"n\"constvar/spanspan class=\"p\"):/span\n        span class=\"nb\"print/spanspan class=\"p\"(/spanspan class=\"sa\"f/spanspan class=\"s2\"\"/spanspan class=\"si\"{/spanspan class=\"n\"opname/spanspan class=\"si\"}/spanspan class=\"s2\"(x, x) -gt; /spanspan class=\"si\"{/spanspan class=\"n\"const/spanspan class=\"si\"}/spanspan class=\"s2\"\"/spanspan class=\"p\")/span\nspan class=\"c1\"# try to find constants for op(x, c) == x and op(c, x) == x/span\nspan class=\"k\"for/span span class=\"n\"opname/span span class=\"ow\"in/span span class=\"n\"opnames2/spanspan class=\"p\":/span\n    span class=\"n\"result/spanspan class=\"p\",/span span class=\"n\"valid_if/span span class=\"o\"=/span span class=\"n\"z3_expression/spanspan class=\"p\"(/spanspan class=\"n\"opname/spanspan class=\"p\",/span span class=\"n\"xvar/spanspan class=\"p\",/span span class=\"n\"constvar/spanspan class=\"p\")/span\n    span class=\"k\"for/span span class=\"n\"const/span span class=\"ow\"in/span span class=\"n\"find_constant/spanspan class=\"p\"(/spanspan class=\"n\"result/span span class=\"o\"==/span span class=\"n\"xvar/spanspan class=\"p\"):/span\n        span class=\"nb\"print/spanspan class=\"p\"(/spanspan class=\"sa\"f/spanspan class=\"s2\"\"/spanspan class=\"si\"{/spanspan class=\"n\"opname/spanspan class=\"si\"}/spanspan class=\"s2\"(x, /spanspan class=\"si\"{/spanspan class=\"n\"const/spanspan class=\"si\"}/spanspan class=\"s2\") -gt; x\"/spanspan class=\"p\")/span\n    span class=\"n\"result/spanspan class=\"p\",/span span class=\"n\"valid_if/span span class=\"o\"=/span span class=\"n\"z3_expression/spanspan class=\"p\"(/spanspan class=\"n\"opname/spanspan class=\"p\",/span span class=\"n\"constvar/spanspan class=\"p\",/span span class=\"n\"xvar/spanspan class=\"p\")/span\n    span class=\"k\"for/span span class=\"n\"const/span span class=\"ow\"in/span span class=\"n\"find_constant/spanspan class=\"p\"(/spanspan class=\"n\"result/span span class=\"o\"==/span span class=\"n\"xvar/spanspan class=\"p\"):/span\n        span class=\"nb\"print/spanspan class=\"p\"(/spanspan class=\"sa\"f/spanspan class=\"s2\"\"/spanspan class=\"si\"{/spanspan class=\"n\"opname/spanspan class=\"si\"}/spanspan class=\"s2\"(/spanspan class=\"si\"{/spanspan class=\"n\"const/spanspan class=\"si\"}/spanspan class=\"s2\", x) -gt; x\"/spanspan class=\"p\")/span\nspan class=\"c1\"# this code is not quite correct, we'll correct it later/span\n/pre/div\n\npTogether this yields the following new simplifications:/p\ndiv class=\"code\"pre class=\"code literal-block\"span class=\"cp\"# careful, these are not all correct!/span\nspan class=\"n\"int_sub/spanspan class=\"p\"(/spanspan class=\"n\"x/spanspan class=\"p\",/spanspan class=\"w\" /spanspan class=\"n\"x/spanspan class=\"p\")/spanspan class=\"w\" /spanspan class=\"o\"-gt;/spanspan class=\"w\" /spanspan class=\"mi\"0/span\nspan class=\"n\"int_xor/spanspan class=\"p\"(/spanspan class=\"n\"x/spanspan class=\"p\",/spanspan class=\"w\" /spanspan class=\"n\"x/spanspan class=\"p\")/spanspan class=\"w\" /spanspan class=\"o\"-gt;/spanspan class=\"w\" /spanspan class=\"mi\"0/span\nspan class=\"n\"int_eq/spanspan class=\"p\"(/spanspan class=\"n\"x/spanspan class=\"p\",/spanspan class=\"w\" /spanspan class=\"n\"x/spanspan class=\"p\")/spanspan class=\"w\" /spanspan class=\"o\"-gt;/spanspan class=\"w\" /spanspan class=\"mi\"1/span\nspan class=\"n\"int_ne/spanspan class=\"p\"(/spanspan class=\"n\"x/spanspan class=\"p\",/spanspan class=\"w\" /spanspan class=\"n\"x/spanspan class=\"p\")/spanspan class=\"w\" /spanspan class=\"o\"-gt;/spanspan class=\"w\" /spanspan class=\"mi\"0/span\nspan class=\"n\"int_lt/spanspan class=\"p\"(/spanspan class=\"n\"x/spanspan class=\"p\",/spanspan class=\"w\" /spanspan class=\"n\"x/spanspan class=\"p\")/spanspan class=\"w\" /spanspan class=\"o\"-gt;/spanspan class=\"w\" /spanspan class=\"mi\"0/span\nspan class=\"n\"int_le/spanspan class=\"p\"(/spanspan class=\"n\"x/spanspan class=\"p\",/spanspan class=\"w\" /spanspan class=\"n\"x/spanspan class=\"p\")/spanspan class=\"w\" /spanspan class=\"o\"-gt;/spanspan class=\"w\" /spanspan class=\"mi\"1/span\nspan class=\"n\"int_gt/spanspan class=\"p\"(/spanspan class=\"n\"x/spanspan class=\"p\",/spanspan class=\"w\" /spanspan class=\"n\"x/spanspan class=\"p\")/spanspan class=\"w\" /spanspan class=\"o\"-gt;/spanspan class=\"w\" /spanspan class=\"mi\"0/span\nspan class=\"n\"int_ge/spanspan class=\"p\"(/spanspan class=\"n\"x/spanspan class=\"p\",/spanspan class=\"w\" /spanspan class=\"n\"x/spanspan class=\"p\")/spanspan class=\"w\" /spanspan class=\"o\"-gt;/spanspan class=\"w\" /spanspan class=\"mi\"1/span\nspan class=\"n\"uint_lt/spanspan class=\"p\"(/spanspan class=\"n\"x/spanspan class=\"p\",/spanspan class=\"w\" /spanspan class=\"n\"x/spanspan class=\"p\")/spanspan class=\"w\" /spanspan class=\"o\"-gt;/spanspan class=\"w\" /spanspan class=\"mi\"0/span\nspan class=\"n\"uint_le/spanspan class=\"p\"(/spanspan class=\"n\"x/spanspan class=\"p\",/spanspan class=\"w\" /spanspan class=\"n\"x/spanspan class=\"p\")/spanspan class=\"w\" /spanspan class=\"o\"-gt;/spanspan class=\"w\" /spanspan class=\"mi\"1/span\nspan class=\"n\"uint_gt/spanspan class=\"p\"(/spanspan class=\"n\"x/spanspan class=\"p\",/spanspan class=\"w\" /spanspan class=\"n\"x/spanspan class=\"p\")/spanspan class=\"w\" /spanspan class=\"o\"-gt;/spanspan class=\"w\" /spanspan class=\"mi\"0/span\nspan class=\"n\"uint_ge/spanspan class=\"p\"(/spanspan class=\"n\"x/spanspan class=\"p\",/spanspan class=\"w\" /spanspan class=\"n\"x/spanspan class=\"p\")/spanspan class=\"w\" /spanspan class=\"o\"-gt;/spanspan class=\"w\" /spanspan class=\"mi\"1/span\nspan class=\"n\"uint_rshift/spanspan class=\"p\"(/spanspan class=\"n\"x/spanspan class=\"p\",/spanspan class=\"w\" /spanspan class=\"n\"x/spanspan class=\"p\")/spanspan class=\"w\" /spanspan class=\"o\"-gt;/spanspan class=\"w\" /spanspan class=\"mi\"0/span\nspan class=\"n\"int_pymod/spanspan class=\"p\"(/spanspan class=\"n\"x/spanspan class=\"p\",/spanspan class=\"w\" /spanspan class=\"n\"x/spanspan class=\"p\")/spanspan class=\"w\" /spanspan class=\"o\"-gt;/spanspan class=\"w\" /spanspan class=\"mi\"0/span\nspan class=\"n\"int_add/spanspan class=\"p\"(/spanspan class=\"n\"x/spanspan class=\"p\",/spanspan class=\"w\" /spanspan class=\"mi\"0/spanspan class=\"p\")/spanspan class=\"w\" /spanspan class=\"o\"-gt;/spanspan class=\"w\" /spanspan class=\"n\"x/span\nspan class=\"n\"int_add/spanspan class=\"p\"(/spanspan class=\"mi\"0/spanspan class=\"p\",/spanspan class=\"w\" /spanspan class=\"n\"x/spanspan class=\"p\")/spanspan class=\"w\" /spanspan class=\"o\"-gt;/spanspan class=\"w\" /spanspan class=\"n\"x/span\nspan class=\"n\"int_sub/spanspan class=\"p\"(/spanspan class=\"n\"x/spanspan class=\"p\",/spanspan class=\"w\" /spanspan class=\"mi\"0/spanspan class=\"p\")/spanspan class=\"w\" /spanspan class=\"o\"-gt;/spanspan class=\"w\" /spanspan class=\"n\"x/span\nspan class=\"n\"int_mul/spanspan class=\"p\"(/spanspan class=\"n\"x/spanspan class=\"p\",/spanspan class=\"w\" /spanspan class=\"mi\"1/spanspan class=\"p\")/spanspan class=\"w\" /spanspan class=\"o\"-gt;/spanspan class=\"w\" /spanspan class=\"n\"x/span\nspan class=\"n\"int_mul/spanspan class=\"p\"(/spanspan class=\"mi\"1/spanspan class=\"p\",/spanspan class=\"w\" /spanspan class=\"n\"x/spanspan class=\"p\")/spanspan class=\"w\" /spanspan class=\"o\"-gt;/spanspan class=\"w\" /spanspan class=\"n\"x/span\nspan class=\"n\"int_and/spanspan class=\"p\"(/spanspan class=\"n\"x/spanspan class=\"p\",/spanspan class=\"w\" /spanspan class=\"o\"-/spanspan class=\"mi\"1/spanspan class=\"p\")/spanspan class=\"w\" /spanspan class=\"o\"-gt;/spanspan class=\"w\" /spanspan class=\"n\"x/span\nspan class=\"n\"int_and/spanspan class=\"p\"(/spanspan class=\"o\"-/spanspan class=\"mi\"1/spanspan class=\"p\",/spanspan class=\"w\" /spanspan class=\"n\"x/spanspan class=\"p\")/spanspan class=\"w\" /spanspan class=\"o\"-gt;/spanspan class=\"w\" /spanspan class=\"n\"x/span\nspan class=\"n\"int_or/spanspan class=\"p\"(/spanspan class=\"n\"x/spanspan class=\"p\",/spanspan class=\"w\" /spanspan class=\"mi\"0/spanspan class=\"p\")/spanspan class=\"w\" /spanspan class=\"o\"-gt;/spanspan class=\"w\" /spanspan class=\"n\"x/span\nspan class=\"n\"int_or/spanspan class=\"p\"(/spanspan class=\"mi\"0/spanspan class=\"p\",/spanspan class=\"w\" /spanspan class=\"n\"x/spanspan class=\"p\")/spanspan class=\"w\" /spanspan class=\"o\"-gt;/spanspan class=\"w\" /spanspan class=\"n\"x/span\nspan class=\"n\"int_xor/spanspan class=\"p\"(/spanspan class=\"n\"x/spanspan class=\"p\",/spanspan class=\"w\" /spanspan class=\"mi\"0/spanspan class=\"p\")/spanspan class=\"w\" /spanspan class=\"o\"-gt;/spanspan class=\"w\" /spanspan class=\"n\"x/span\nspan class=\"n\"int_xor/spanspan class=\"p\"(/spanspan class=\"mi\"0/spanspan class=\"p\",/spanspan class=\"w\" /spanspan class=\"n\"x/spanspan class=\"p\")/spanspan class=\"w\" /spanspan class=\"o\"-gt;/spanspan class=\"w\" /spanspan class=\"n\"x/span\nspan class=\"n\"int_lshift/spanspan class=\"p\"(/spanspan class=\"n\"x/spanspan class=\"p\",/spanspan class=\"w\" /spanspan class=\"mi\"0/spanspan class=\"p\")/spanspan class=\"w\" /spanspan class=\"o\"-gt;/spanspan class=\"w\" /spanspan class=\"n\"x/span\nspan class=\"n\"int_rshift/spanspan class=\"p\"(/spanspan class=\"n\"x/spanspan class=\"p\",/spanspan class=\"w\" /spanspan class=\"mi\"0/spanspan class=\"p\")/spanspan class=\"w\" /spanspan class=\"o\"-gt;/spanspan class=\"w\" /spanspan class=\"n\"x/span\nspan class=\"n\"uint_rshift/spanspan class=\"p\"(/spanspan class=\"n\"x/spanspan class=\"p\",/spanspan class=\"w\" /spanspan class=\"mi\"0/spanspan class=\"p\")/spanspan class=\"w\" /spanspan class=\"o\"-gt;/spanspan class=\"w\" /spanspan class=\"n\"x/span\nspan class=\"n\"int_pydiv/spanspan class=\"p\"(/spanspan class=\"n\"x/spanspan class=\"p\",/spanspan class=\"w\" /spanspan class=\"mi\"1/spanspan class=\"p\")/spanspan class=\"w\" /spanspan class=\"o\"-gt;/spanspan class=\"w\" /spanspan class=\"n\"x/span\nspan class=\"n\"int_pymod/spanspan class=\"p\"(/spanspan class=\"n\"x/spanspan class=\"p\",/spanspan class=\"w\" /spanspan class=\"mi\"0/spanspan class=\"p\")/spanspan class=\"w\" /spanspan class=\"o\"-gt;/spanspan class=\"w\" /spanspan class=\"n\"x/span\n/pre/div\n\npMost of these look good at first glance, but the last one reveals a problem:\nwe've been ignoring the codevalid_if/code expression up to now. We can stop doing that by\nchanging the code like this, which adds codez3.And(valid_if, ...)/code to the argument of\nthe calls to codefind_constant/code:/p\ndiv class=\"code\"pre class=\"code literal-block\"span class=\"c1\"# try to find constants for op(x, x) == c, op(x, c) == x and op(c, x) == x/span\nspan class=\"k\"for/span span class=\"n\"opname/span span class=\"ow\"in/span span class=\"n\"opnames2/spanspan class=\"p\":/span\n    span class=\"n\"result/spanspan class=\"p\",/span span class=\"n\"valid_if/span span class=\"o\"=/span span class=\"n\"z3_expression/spanspan class=\"p\"(/spanspan class=\"n\"opname/spanspan class=\"p\",/span span class=\"n\"xvar/spanspan class=\"p\",/span span class=\"n\"xvar/spanspan class=\"p\")/span\n    span class=\"k\"for/span span class=\"n\"const/span span class=\"ow\"in/span span class=\"n\"find_constant/spanspan class=\"p\"(/spanspan class=\"n\"z3/spanspan class=\"o\"./spanspan class=\"n\"And/spanspan class=\"p\"(/spanspan class=\"n\"valid_if/spanspan class=\"p\",/span span class=\"n\"result/span span class=\"o\"==/span span class=\"n\"constvar/spanspan class=\"p\")):/span\n        span class=\"nb\"print/spanspan class=\"p\"(/spanspan class=\"sa\"f/spanspan class=\"s2\"\"/spanspan class=\"si\"{/spanspan class=\"n\"opname/spanspan class=\"si\"}/spanspan class=\"s2\"(x, x) -gt; /spanspan class=\"si\"{/spanspan class=\"n\"const/spanspan class=\"si\"}/spanspan class=\"s2\"\"/spanspan class=\"p\")/span\nspan class=\"c1\"# try to find constants for op(x, c) == x and op(c, x) == x/span\nspan class=\"k\"for/span span class=\"n\"opname/span span class=\"ow\"in/span span class=\"n\"opnames2/spanspan class=\"p\":/span\n    span class=\"n\"result/spanspan class=\"p\",/span span class=\"n\"valid_if/span span class=\"o\"=/span span class=\"n\"z3_expression/spanspan class=\"p\"(/spanspan class=\"n\"opname/spanspan class=\"p\",/span span class=\"n\"xvar/spanspan class=\"p\",/span span class=\"n\"constvar/spanspan class=\"p\")/span\n    span class=\"k\"for/span span class=\"n\"const/span span class=\"ow\"in/span span class=\"n\"find_constant/spanspan class=\"p\"(/spanspan class=\"n\"z3/spanspan class=\"o\"./spanspan class=\"n\"And/spanspan class=\"p\"(/spanspan class=\"n\"result/span span class=\"o\"==/span span class=\"n\"xvar/spanspan class=\"p\",/span span class=\"n\"valid_if/spanspan class=\"p\")):/span\n        span class=\"nb\"print/spanspan class=\"p\"(/spanspan class=\"sa\"f/spanspan class=\"s2\"\"/spanspan class=\"si\"{/spanspan class=\"n\"opname/spanspan class=\"si\"}/spanspan class=\"s2\"(x, /spanspan class=\"si\"{/spanspan class=\"n\"const/spanspan class=\"si\"}/spanspan class=\"s2\") -gt; x\"/spanspan class=\"p\")/span\n    span class=\"n\"result/spanspan class=\"p\",/span span class=\"n\"valid_if/span span class=\"o\"=/span span class=\"n\"z3_expression/spanspan class=\"p\"(/spanspan class=\"n\"opname/spanspan class=\"p\",/span span class=\"n\"constvar/spanspan class=\"p\",/span span class=\"n\"xvar/spanspan class=\"p\")/span\n    span class=\"k\"for/span span class=\"n\"const/span span class=\"ow\"in/span span class=\"n\"find_constant/spanspan class=\"p\"(/spanspan class=\"n\"z3/spanspan class=\"o\"./spanspan class=\"n\"And/spanspan class=\"p\"(/spanspan class=\"n\"result/span span class=\"o\"==/span span class=\"n\"xvar/spanspan class=\"p\",/span span class=\"n\"valid_if/spanspan class=\"p\")):/span\n        span class=\"nb\"print/spanspan class=\"p\"(/spanspan class=\"sa\"f/spanspan class=\"s2\"\"/spanspan class=\"si\"{/spanspan class=\"n\"opname/spanspan class=\"si\"}/spanspan class=\"s2\"(/spanspan class=\"si\"{/spanspan class=\"n\"const/spanspan class=\"si\"}/spanspan class=\"s2\", x) -gt; x\"/spanspan class=\"p\")/span\n/pre/div\n\npAnd we get this list instead:/p\ndiv class=\"code\"pre class=\"code literal-block\"span class=\"n\"int_sub/spanspan class=\"p\"(/spanspan class=\"n\"x/spanspan class=\"p\",/spanspan class=\"w\" /spanspan class=\"n\"x/spanspan class=\"p\")/spanspan class=\"w\" /spanspan class=\"o\"-gt;/spanspan class=\"w\" /spanspan class=\"mi\"0/span\nspan class=\"n\"int_xor/spanspan class=\"p\"(/spanspan class=\"n\"x/spanspan class=\"p\",/spanspan class=\"w\" /spanspan class=\"n\"x/spanspan class=\"p\")/spanspan class=\"w\" /spanspan class=\"o\"-gt;/spanspan class=\"w\" /spanspan class=\"mi\"0/span\nspan class=\"n\"int_eq/spanspan class=\"p\"(/spanspan class=\"n\"x/spanspan class=\"p\",/spanspan class=\"w\" /spanspan class=\"n\"x/spanspan class=\"p\")/spanspan class=\"w\" /spanspan class=\"o\"-gt;/spanspan class=\"w\" /spanspan class=\"mi\"1/span\nspan class=\"n\"int_ne/spanspan class=\"p\"(/spanspan class=\"n\"x/spanspan class=\"p\",/spanspan class=\"w\" /spanspan class=\"n\"x/spanspan class=\"p\")/spanspan class=\"w\" /spanspan class=\"o\"-gt;/spanspan class=\"w\" /spanspan class=\"mi\"0/span\nspan class=\"n\"int_lt/spanspan class=\"p\"(/spanspan class=\"n\"x/spanspan class=\"p\",/spanspan class=\"w\" /spanspan class=\"n\"x/spanspan class=\"p\")/spanspan class=\"w\" /spanspan class=\"o\"-gt;/spanspan class=\"w\" /spanspan class=\"mi\"0/span\nspan class=\"n\"int_le/spanspan class=\"p\"(/spanspan class=\"n\"x/spanspan class=\"p\",/spanspan class=\"w\" /spanspan class=\"n\"x/spanspan class=\"p\")/spanspan class=\"w\" /spanspan class=\"o\"-gt;/spanspan class=\"w\" /spanspan class=\"mi\"1/span\nspan class=\"n\"int_gt/spanspan class=\"p\"(/spanspan class=\"n\"x/spanspan class=\"p\",/spanspan class=\"w\" /spanspan class=\"n\"x/spanspan class=\"p\")/spanspan class=\"w\" /spanspan class=\"o\"-gt;/spanspan class=\"w\" /spanspan class=\"mi\"0/span\nspan class=\"n\"int_ge/spanspan class=\"p\"(/spanspan class=\"n\"x/spanspan class=\"p\",/spanspan class=\"w\" /spanspan class=\"n\"x/spanspan class=\"p\")/spanspan class=\"w\" /spanspan class=\"o\"-gt;/spanspan class=\"w\" /spanspan class=\"mi\"1/span\nspan class=\"n\"uint_lt/spanspan class=\"p\"(/spanspan class=\"n\"x/spanspan class=\"p\",/spanspan class=\"w\" /spanspan class=\"n\"x/spanspan class=\"p\")/spanspan class=\"w\" /spanspan class=\"o\"-gt;/spanspan class=\"w\" /spanspan class=\"mi\"0/span\nspan class=\"n\"uint_le/spanspan class=\"p\"(/spanspan class=\"n\"x/spanspan class=\"p\",/spanspan class=\"w\" /spanspan class=\"n\"x/spanspan class=\"p\")/spanspan class=\"w\" /spanspan class=\"o\"-gt;/spanspan class=\"w\" /spanspan class=\"mi\"1/span\nspan class=\"n\"uint_gt/spanspan class=\"p\"(/spanspan class=\"n\"x/spanspan class=\"p\",/spanspan class=\"w\" /spanspan class=\"n\"x/spanspan class=\"p\")/spanspan class=\"w\" /spanspan class=\"o\"-gt;/spanspan class=\"w\" /spanspan class=\"mi\"0/span\nspan class=\"n\"uint_ge/spanspan class=\"p\"(/spanspan class=\"n\"x/spanspan class=\"p\",/spanspan class=\"w\" /spanspan class=\"n\"x/spanspan class=\"p\")/spanspan class=\"w\" /spanspan class=\"o\"-gt;/spanspan class=\"w\" /spanspan class=\"mi\"1/span\nspan class=\"n\"int_add/spanspan class=\"p\"(/spanspan class=\"n\"x/spanspan class=\"p\",/spanspan class=\"w\" /spanspan class=\"mi\"0/spanspan class=\"p\")/spanspan class=\"w\" /spanspan class=\"o\"-gt;/spanspan class=\"w\" /spanspan class=\"n\"x/span\nspan class=\"n\"int_add/spanspan class=\"p\"(/spanspan class=\"mi\"0/spanspan class=\"p\",/spanspan class=\"w\" /spanspan class=\"n\"x/spanspan class=\"p\")/spanspan class=\"w\" /spanspan class=\"o\"-gt;/spanspan class=\"w\" /spanspan class=\"n\"x/span\nspan class=\"n\"int_sub/spanspan class=\"p\"(/spanspan class=\"n\"x/spanspan class=\"p\",/spanspan class=\"w\" /spanspan class=\"mi\"0/spanspan class=\"p\")/spanspan class=\"w\" /spanspan class=\"o\"-gt;/spanspan class=\"w\" /spanspan class=\"n\"x/span\nspan class=\"n\"int_mul/spanspan class=\"p\"(/spanspan class=\"n\"x/spanspan class=\"p\",/spanspan class=\"w\" /spanspan class=\"mi\"1/spanspan class=\"p\")/spanspan class=\"w\" /spanspan class=\"o\"-gt;/spanspan class=\"w\" /spanspan class=\"n\"x/span\nspan class=\"n\"int_mul/spanspan class=\"p\"(/spanspan class=\"mi\"1/spanspan class=\"p\",/spanspan class=\"w\" /spanspan class=\"n\"x/spanspan class=\"p\")/spanspan class=\"w\" /spanspan class=\"o\"-gt;/spanspan class=\"w\" /spanspan class=\"n\"x/span\nspan class=\"n\"int_and/spanspan class=\"p\"(/spanspan class=\"n\"x/spanspan class=\"p\",/spanspan class=\"w\" /spanspan class=\"o\"-/spanspan class=\"mi\"1/spanspan class=\"p\")/spanspan class=\"w\" /spanspan class=\"o\"-gt;/spanspan class=\"w\" /spanspan class=\"n\"x/span\nspan class=\"n\"int_and/spanspan class=\"p\"(/spanspan class=\"o\"-/spanspan class=\"mi\"1/spanspan class=\"p\",/spanspan class=\"w\" /spanspan class=\"n\"x/spanspan class=\"p\")/spanspan class=\"w\" /spanspan class=\"o\"-gt;/spanspan class=\"w\" /spanspan class=\"n\"x/span\nspan class=\"n\"int_or/spanspan class=\"p\"(/spanspan class=\"n\"x/spanspan class=\"p\",/spanspan class=\"w\" /spanspan class=\"mi\"0/spanspan class=\"p\")/spanspan class=\"w\" /spanspan class=\"o\"-gt;/spanspan class=\"w\" /spanspan class=\"n\"x/span\nspan class=\"n\"int_or/spanspan class=\"p\"(/spanspan class=\"mi\"0/spanspan class=\"p\",/spanspan class=\"w\" /spanspan class=\"n\"x/spanspan class=\"p\")/spanspan class=\"w\" /spanspan class=\"o\"-gt;/spanspan class=\"w\" /spanspan class=\"n\"x/span\nspan class=\"n\"int_xor/spanspan class=\"p\"(/spanspan class=\"n\"x/spanspan class=\"p\",/spanspan class=\"w\" /spanspan class=\"mi\"0/spanspan class=\"p\")/spanspan class=\"w\" /spanspan class=\"o\"-gt;/spanspan class=\"w\" /spanspan class=\"n\"x/span\nspan class=\"n\"int_xor/spanspan class=\"p\"(/spanspan class=\"mi\"0/spanspan class=\"p\",/spanspan class=\"w\" /spanspan class=\"n\"x/spanspan class=\"p\")/spanspan class=\"w\" /spanspan class=\"o\"-gt;/spanspan class=\"w\" /spanspan class=\"n\"x/span\nspan class=\"n\"int_lshift/spanspan class=\"p\"(/spanspan class=\"n\"x/spanspan class=\"p\",/spanspan class=\"w\" /spanspan class=\"mi\"0/spanspan class=\"p\")/spanspan class=\"w\" /spanspan class=\"o\"-gt;/spanspan class=\"w\" /spanspan class=\"n\"x/span\nspan class=\"n\"int_rshift/spanspan class=\"p\"(/spanspan class=\"n\"x/spanspan class=\"p\",/spanspan class=\"w\" /spanspan class=\"mi\"0/spanspan class=\"p\")/spanspan class=\"w\" /spanspan class=\"o\"-gt;/spanspan class=\"w\" /spanspan class=\"n\"x/span\nspan class=\"n\"uint_rshift/spanspan class=\"p\"(/spanspan class=\"n\"x/spanspan class=\"p\",/spanspan class=\"w\" /spanspan class=\"mi\"0/spanspan class=\"p\")/spanspan class=\"w\" /spanspan class=\"o\"-gt;/spanspan class=\"w\" /spanspan class=\"n\"x/span\nspan class=\"n\"int_pydiv/spanspan class=\"p\"(/spanspan class=\"n\"x/spanspan class=\"p\",/spanspan class=\"w\" /spanspan class=\"mi\"1/spanspan class=\"p\")/spanspan class=\"w\" /spanspan class=\"o\"-gt;/spanspan class=\"w\" /spanspan class=\"n\"x/span\n/pre/div\n\nh3 id=\"synthesizing-two-constants\"Synthesizing two constants/h3\npFor the patterns codeop(x, c1) == c2/code and codeop(c1, x) == c2/code we need to synthesize\ntwo constants. We can again write a helper method for that:/p\ndiv class=\"code\"pre class=\"code literal-block\"span class=\"k\"def/span span class=\"nf\"find_2consts/spanspan class=\"p\"(/spanspan class=\"n\"z3expr/spanspan class=\"p\",/span span class=\"n\"number_of_results/spanspan class=\"o\"=/spanspan class=\"mi\"5/spanspan class=\"p\"):/span\n    span class=\"n\"condition/span span class=\"o\"=/span span class=\"n\"z3/spanspan class=\"o\"./spanspan class=\"n\"ForAll/spanspan class=\"p\"(/span\n        span class=\"p\"[/spanspan class=\"n\"xvar/spanspan class=\"p\"],/span\n        span class=\"n\"z3expr/span\n    span class=\"p\")/span\n    span class=\"k\"for/span span class=\"n\"i/span span class=\"ow\"in/span span class=\"nb\"range/spanspan class=\"p\"(/spanspan class=\"n\"number_of_results/spanspan class=\"p\"):/span\n        span class=\"n\"checkres/span span class=\"o\"=/span span class=\"n\"solver/spanspan class=\"o\"./spanspan class=\"n\"check/spanspan class=\"p\"(/spanspan class=\"n\"condition/spanspan class=\"p\")/span\n        span class=\"k\"if/span span class=\"n\"checkres/span span class=\"o\"==/span span class=\"n\"z3/spanspan class=\"o\"./spanspan class=\"n\"sat/spanspan class=\"p\":/span\n            span class=\"n\"model/span span class=\"o\"=/span span class=\"n\"solver/spanspan class=\"o\"./spanspan class=\"n\"model/spanspan class=\"p\"()/span\n            span class=\"n\"const/span span class=\"o\"=/span span class=\"n\"model/spanspan class=\"p\"[/spanspan class=\"n\"constvar/spanspan class=\"p\"]/spanspan class=\"o\"./spanspan class=\"n\"as_signed_long/spanspan class=\"p\"()/span\n            span class=\"n\"const2/span span class=\"o\"=/span span class=\"n\"model/spanspan class=\"p\"[/spanspan class=\"n\"constvar2/spanspan class=\"p\"]/spanspan class=\"o\"./spanspan class=\"n\"as_signed_long/spanspan class=\"p\"()/span\n            span class=\"k\"yield/span span class=\"n\"const/spanspan class=\"p\",/span span class=\"n\"const2/span\n            span class=\"n\"condition/span span class=\"o\"=/span span class=\"n\"z3/spanspan class=\"o\"./spanspan class=\"n\"And/spanspan class=\"p\"(/spanspan class=\"n\"z3/spanspan class=\"o\"./spanspan class=\"n\"Or/spanspan class=\"p\"(/spanspan class=\"n\"constvar/span span class=\"o\"!=/span span class=\"n\"const/spanspan class=\"p\",/span span class=\"n\"constvar2/span span class=\"o\"!=/span span class=\"n\"const2/spanspan class=\"p\"),/span span class=\"n\"condition/spanspan class=\"p\")/span\n        span class=\"k\"else/spanspan class=\"p\":/span\n            span class=\"k\"return/span\n/pre/div\n\npAnd then use it like this:/p\ndiv class=\"code\"pre class=\"code literal-block\"span class=\"k\"for/span span class=\"n\"opname/span span class=\"ow\"in/span span class=\"n\"opnames2/spanspan class=\"p\":/span\n    span class=\"c1\"# try to find constants c1, c2 such that op(c1, x) -gt; c2/span\n    span class=\"n\"result/spanspan class=\"p\",/span span class=\"n\"valid_if/span span class=\"o\"=/span span class=\"n\"z3_expression/spanspan class=\"p\"(/spanspan class=\"n\"opname/spanspan class=\"p\",/span span class=\"n\"constvar/spanspan class=\"p\",/span span class=\"n\"xvar/spanspan class=\"p\")/span\n    span class=\"n\"consts/span span class=\"o\"=/span span class=\"n\"find_2consts/spanspan class=\"p\"(/spanspan class=\"n\"z3/spanspan class=\"o\"./spanspan class=\"n\"And/spanspan class=\"p\"(/spanspan class=\"n\"valid_if/spanspan class=\"p\",/span span class=\"n\"result/span span class=\"o\"==/span span class=\"n\"constvar2/spanspan class=\"p\"))/span\n    span class=\"k\"for/span span class=\"n\"const/spanspan class=\"p\",/span span class=\"n\"const2/span span class=\"ow\"in/span span class=\"n\"consts/spanspan class=\"p\":/span\n        span class=\"nb\"print/spanspan class=\"p\"(/spanspan class=\"sa\"f/spanspan class=\"s2\"\"/spanspan class=\"si\"{/spanspan class=\"n\"opname/spanspan class=\"si\"}/spanspan class=\"s2\"(/spanspan class=\"si\"{/spanspan class=\"n\"const/spanspan class=\"si\"}/spanspan class=\"s2\", x) -gt; /spanspan class=\"si\"{/spanspan class=\"n\"const2/spanspan class=\"si\"}/spanspan class=\"s2\"\"/spanspan class=\"p\")/span\n    span class=\"c1\"# try to find constants c1, c2 such that op(x, c1) -gt; c2/span\n    span class=\"n\"result/spanspan class=\"p\",/span span class=\"n\"valid_if/span span class=\"o\"=/span span class=\"n\"z3_expression/spanspan class=\"p\"(/spanspan class=\"n\"opname/spanspan class=\"p\",/span span class=\"n\"xvar/spanspan class=\"p\",/span span class=\"n\"constvar/spanspan class=\"p\")/span\n    span class=\"n\"consts/span span class=\"o\"=/span span class=\"n\"find_2consts/spanspan class=\"p\"(/spanspan class=\"n\"z3/spanspan class=\"o\"./spanspan class=\"n\"And/spanspan class=\"p\"(/spanspan class=\"n\"valid_if/spanspan class=\"p\",/span span class=\"n\"result/span span class=\"o\"==/span span class=\"n\"constvar2/spanspan class=\"p\"))/span\n    span class=\"k\"for/span span class=\"n\"const/spanspan class=\"p\",/span span class=\"n\"const2/span span class=\"ow\"in/span span class=\"n\"consts/spanspan class=\"p\":/span\n        span class=\"nb\"print/spanspan class=\"p\"(/spanspan class=\"s2\"\"/spanspan class=\"si\"%s/spanspan class=\"s2\"(x, /spanspan class=\"si\"%s/spanspan class=\"s2\") -gt; /spanspan class=\"si\"%s/spanspan class=\"s2\"\"/span span class=\"o\"%/span span class=\"p\"(/spanspan class=\"n\"opname/spanspan class=\"p\",/span span class=\"n\"const/spanspan class=\"p\",/span span class=\"n\"const2/spanspan class=\"p\"))/span\n/pre/div\n\npWhich yields some straightforward simplifications:/p\ndiv class=\"code\"pre class=\"code literal-block\"span class=\"n\"int_mul/spanspan class=\"p\"(/spanspan class=\"mi\"0/spanspan class=\"p\",/spanspan class=\"w\" /spanspan class=\"n\"x/spanspan class=\"p\")/spanspan class=\"w\" /spanspan class=\"o\"-gt;/spanspan class=\"w\" /spanspan class=\"mi\"0/span\nspan class=\"n\"int_mul/spanspan class=\"p\"(/spanspan class=\"n\"x/spanspan class=\"p\",/spanspan class=\"w\" /spanspan class=\"mi\"0/spanspan class=\"p\")/spanspan class=\"w\" /spanspan class=\"o\"-gt;/spanspan class=\"w\" /spanspan class=\"mi\"0/span\nspan class=\"n\"int_and/spanspan class=\"p\"(/spanspan class=\"mi\"0/spanspan class=\"p\",/spanspan class=\"w\" /spanspan class=\"n\"x/spanspan class=\"p\")/spanspan class=\"w\" /spanspan class=\"o\"-gt;/spanspan class=\"w\" /spanspan class=\"mi\"0/span\nspan class=\"n\"int_and/spanspan class=\"p\"(/spanspan class=\"n\"x/spanspan class=\"p\",/spanspan class=\"w\" /spanspan class=\"mi\"0/spanspan class=\"p\")/spanspan class=\"w\" /spanspan class=\"o\"-gt;/spanspan class=\"w\" /spanspan class=\"mi\"0/span\nspan class=\"n\"uint_lt/spanspan class=\"p\"(/spanspan class=\"n\"x/spanspan class=\"p\",/spanspan class=\"w\" /spanspan class=\"mi\"0/spanspan class=\"p\")/spanspan class=\"w\" /spanspan class=\"o\"-gt;/spanspan class=\"w\" /spanspan class=\"mi\"0/span\nspan class=\"n\"uint_le/spanspan class=\"p\"(/spanspan class=\"mi\"0/spanspan class=\"p\",/spanspan class=\"w\" /spanspan class=\"n\"x/spanspan class=\"p\")/spanspan class=\"w\" /spanspan class=\"o\"-gt;/spanspan class=\"w\" /spanspan class=\"mi\"1/span\nspan class=\"n\"uint_gt/spanspan class=\"p\"(/spanspan class=\"mi\"0/spanspan class=\"p\",/spanspan class=\"w\" /spanspan class=\"n\"x/spanspan class=\"p\")/spanspan class=\"w\" /spanspan class=\"o\"-gt;/spanspan class=\"w\" /spanspan class=\"mi\"0/span\nspan class=\"n\"uint_ge/spanspan class=\"p\"(/spanspan class=\"n\"x/spanspan class=\"p\",/spanspan class=\"w\" /spanspan class=\"mi\"0/spanspan class=\"p\")/spanspan class=\"w\" /spanspan class=\"o\"-gt;/spanspan class=\"w\" /spanspan class=\"mi\"1/span\nspan class=\"n\"int_lshift/spanspan class=\"p\"(/spanspan class=\"mi\"0/spanspan class=\"p\",/spanspan class=\"w\" /spanspan class=\"n\"x/spanspan class=\"p\")/spanspan class=\"w\" /spanspan class=\"o\"-gt;/spanspan class=\"w\" /spanspan class=\"mi\"0/span\nspan class=\"n\"int_rshift/spanspan class=\"p\"(/spanspan class=\"mi\"0/spanspan class=\"p\",/spanspan class=\"w\" /spanspan class=\"n\"x/spanspan class=\"p\")/spanspan class=\"w\" /spanspan class=\"o\"-gt;/spanspan class=\"w\" /spanspan class=\"mi\"0/span\nspan class=\"n\"uint_rshift/spanspan class=\"p\"(/spanspan class=\"mi\"0/spanspan class=\"p\",/spanspan class=\"w\" /spanspan class=\"n\"x/spanspan class=\"p\")/spanspan class=\"w\" /spanspan class=\"o\"-gt;/spanspan class=\"w\" /spanspan class=\"mi\"0/span\nspan class=\"n\"uint_mul_high/spanspan class=\"p\"(/spanspan class=\"mi\"0/spanspan class=\"p\",/spanspan class=\"w\" /spanspan class=\"n\"x/spanspan class=\"p\")/spanspan class=\"w\" /spanspan class=\"o\"-gt;/spanspan class=\"w\" /spanspan class=\"mi\"0/span\nspan class=\"n\"uint_mul_high/spanspan class=\"p\"(/spanspan class=\"mi\"1/spanspan class=\"p\",/spanspan class=\"w\" /spanspan class=\"n\"x/spanspan class=\"p\")/spanspan class=\"w\" /spanspan class=\"o\"-gt;/spanspan class=\"w\" /spanspan class=\"mi\"0/span\nspan class=\"n\"uint_mul_high/spanspan class=\"p\"(/spanspan class=\"n\"x/spanspan class=\"p\",/spanspan class=\"w\" /spanspan class=\"mi\"0/spanspan class=\"p\")/spanspan class=\"w\" /spanspan class=\"o\"-gt;/spanspan class=\"w\" /spanspan class=\"mi\"0/span\nspan class=\"n\"uint_mul_high/spanspan class=\"p\"(/spanspan class=\"n\"x/spanspan class=\"p\",/spanspan class=\"w\" /spanspan class=\"mi\"1/spanspan class=\"p\")/spanspan class=\"w\" /spanspan class=\"o\"-gt;/spanspan class=\"w\" /spanspan class=\"mi\"0/span\nspan class=\"n\"int_pymod/spanspan class=\"p\"(/spanspan class=\"n\"x/spanspan class=\"p\",/spanspan class=\"w\" /spanspan class=\"mi\"1/spanspan class=\"p\")/spanspan class=\"w\" /spanspan class=\"o\"-gt;/spanspan class=\"w\" /spanspan class=\"mi\"0/span\nspan class=\"n\"int_pymod/spanspan class=\"p\"(/spanspan class=\"n\"x/spanspan class=\"p\",/spanspan class=\"w\" /spanspan class=\"o\"-/spanspan class=\"mi\"1/spanspan class=\"p\")/spanspan class=\"w\" /spanspan class=\"o\"-gt;/spanspan class=\"w\" /spanspan class=\"mi\"0/span\n/pre/div\n\npA few require a bit more thinking:/p\ndiv class=\"code\"pre class=\"code literal-block\"span class=\"n\"int_or/spanspan class=\"p\"(/spanspan class=\"o\"-/spanspan class=\"mi\"1/spanspan class=\"p\",/spanspan class=\"w\" /spanspan class=\"n\"x/spanspan class=\"p\")/spanspan class=\"w\" /spanspan class=\"o\"-gt;/spanspan class=\"w\" /spanspan class=\"o\"-/spanspan class=\"mi\"1/span\nspan class=\"n\"int_or/spanspan class=\"p\"(/spanspan class=\"n\"x/spanspan class=\"p\",/spanspan class=\"w\" /spanspan class=\"o\"-/spanspan class=\"mi\"1/spanspan class=\"p\")/spanspan class=\"w\" /spanspan class=\"o\"-gt;/spanspan class=\"w\" /spanspan class=\"o\"-/spanspan class=\"mi\"1/span\n/pre/div\n\npThe are true because in two's complement, code-1/code has all bits set./p\npThe following ones require recognizing that code-9223372036854775808 == -2**63/code is\nthe most negative signed 64-bit integer, and code9223372036854775807 == 2 ** 63 -\n1/code is the most positive one:/p\ndiv class=\"code\"pre class=\"code literal-block\"span class=\"n\"int_lt/spanspan class=\"p\"(/spanspan class=\"mi\"9223372036854775807/spanspan class=\"p\",/spanspan class=\"w\" /spanspan class=\"n\"x/spanspan class=\"p\")/spanspan class=\"w\" /spanspan class=\"o\"-gt;/spanspan class=\"w\" /spanspan class=\"mi\"0/span\nspan class=\"n\"int_lt/spanspan class=\"p\"(/spanspan class=\"n\"x/spanspan class=\"p\",/spanspan class=\"w\" /spanspan class=\"o\"-/spanspan class=\"mi\"9223372036854775808/spanspan class=\"p\")/spanspan class=\"w\" /spanspan class=\"o\"-gt;/spanspan class=\"w\" /spanspan class=\"mi\"0/span\nspan class=\"n\"int_le/spanspan class=\"p\"(/spanspan class=\"o\"-/spanspan class=\"mi\"9223372036854775808/spanspan class=\"p\",/spanspan class=\"w\" /spanspan class=\"n\"x/spanspan class=\"p\")/spanspan class=\"w\" /spanspan class=\"o\"-gt;/spanspan class=\"w\" /spanspan class=\"mi\"1/span\nspan class=\"n\"int_le/spanspan class=\"p\"(/spanspan class=\"n\"x/spanspan class=\"p\",/spanspan class=\"w\" /spanspan class=\"mi\"9223372036854775807/spanspan class=\"p\")/spanspan class=\"w\" /spanspan class=\"o\"-gt;/spanspan class=\"w\" /spanspan class=\"mi\"1/span\nspan class=\"n\"int_gt/spanspan class=\"p\"(/spanspan class=\"o\"-/spanspan class=\"mi\"9223372036854775808/spanspan class=\"p\",/spanspan class=\"w\" /spanspan class=\"n\"x/spanspan class=\"p\")/spanspan class=\"w\" /spanspan class=\"o\"-gt;/spanspan class=\"w\" /spanspan class=\"mi\"0/span\nspan class=\"n\"int_gt/spanspan class=\"p\"(/spanspan class=\"n\"x/spanspan class=\"p\",/spanspan class=\"w\" /spanspan class=\"mi\"9223372036854775807/spanspan class=\"p\")/spanspan class=\"w\" /spanspan class=\"o\"-gt;/spanspan class=\"w\" /spanspan class=\"mi\"0/span\nspan class=\"n\"int_ge/spanspan class=\"p\"(/spanspan class=\"mi\"9223372036854775807/spanspan class=\"p\",/spanspan class=\"w\" /spanspan class=\"n\"x/spanspan class=\"p\")/spanspan class=\"w\" /spanspan class=\"o\"-gt;/spanspan class=\"w\" /spanspan class=\"mi\"1/span\nspan class=\"n\"int_ge/spanspan class=\"p\"(/spanspan class=\"n\"x/spanspan class=\"p\",/spanspan class=\"w\" /spanspan class=\"o\"-/spanspan class=\"mi\"9223372036854775808/spanspan class=\"p\")/spanspan class=\"w\" /spanspan class=\"o\"-gt;/spanspan class=\"w\" /spanspan class=\"mi\"1/span\n/pre/div\n\npThe following ones are true because the bitpattern for code-1/code is the largest\nunsigned number:/p\ndiv class=\"code\"pre class=\"code literal-block\"span class=\"n\"uint_lt/spanspan class=\"p\"(/spanspan class=\"o\"-/spanspan class=\"mi\"1/spanspan class=\"p\",/spanspan class=\"w\" /spanspan class=\"n\"x/spanspan class=\"p\")/spanspan class=\"w\" /spanspan class=\"o\"-gt;/spanspan class=\"w\" /spanspan class=\"mi\"0/span\nspan class=\"n\"uint_le/spanspan class=\"p\"(/spanspan class=\"n\"x/spanspan class=\"p\",/spanspan class=\"w\" /spanspan class=\"o\"-/spanspan class=\"mi\"1/spanspan class=\"p\")/spanspan class=\"w\" /spanspan class=\"o\"-gt;/spanspan class=\"w\" /spanspan class=\"mi\"1/span\nspan class=\"n\"uint_gt/spanspan class=\"p\"(/spanspan class=\"n\"x/spanspan class=\"p\",/spanspan class=\"w\" /spanspan class=\"o\"-/spanspan class=\"mi\"1/spanspan class=\"p\")/spanspan class=\"w\" /spanspan class=\"o\"-gt;/spanspan class=\"w\" /spanspan class=\"mi\"0/span\nspan class=\"n\"uint_ge/spanspan class=\"p\"(/spanspan class=\"o\"-/spanspan class=\"mi\"1/spanspan class=\"p\",/spanspan class=\"w\" /spanspan class=\"n\"x/spanspan class=\"p\")/spanspan class=\"w\" /spanspan class=\"o\"-gt;/spanspan class=\"w\" /spanspan class=\"mi\"1/span\n/pre/div\n\nh3 id=\"strength-reductions\"Strength Reductions/h3\npAll the patterns so far only had a variable or a constant on the target of the\nrewrite. We can also use the machinery to do strengh-reductions where we\ngenerate a single-argument operation codeop1(x)/code for input operations codeop(x, c1)/code\nor codeop(c1, x)/code. To achieve this, we try all combinations of binary and unary\noperations. (We won't consider strength reductions where a binary operation\ngets turned into a \"cheaper\" other binary operation here.)/p\ndiv class=\"code\"pre class=\"code literal-block\"span class=\"n\"opnames1/span span class=\"o\"=/span span class=\"p\"[/span\nspan class=\"s2\"\"int_is_true\"/spanspan class=\"p\",/span\nspan class=\"s2\"\"int_is_zero\"/spanspan class=\"p\",/span\nspan class=\"s2\"\"int_neg\"/spanspan class=\"p\",/span\nspan class=\"s2\"\"int_invert\"/spanspan class=\"p\",/span\nspan class=\"p\"]/span\n\nspan class=\"k\"for/span span class=\"n\"opname/span span class=\"ow\"in/span span class=\"n\"opnames2/spanspan class=\"p\":/span\n    span class=\"k\"for/span span class=\"n\"opname1/span span class=\"ow\"in/span span class=\"n\"opnames1/spanspan class=\"p\":/span\n        span class=\"n\"result/spanspan class=\"p\",/span span class=\"n\"valid_if/span span class=\"o\"=/span span class=\"n\"z3_expression/spanspan class=\"p\"(/spanspan class=\"n\"opname/spanspan class=\"p\",/span span class=\"n\"xvar/spanspan class=\"p\",/span span class=\"n\"constvar/spanspan class=\"p\")/span\n        span class=\"c1\"# try to find a constant op(x, c) == g(x)/span\n        span class=\"n\"result1/spanspan class=\"p\",/span span class=\"n\"valid_if1/span span class=\"o\"=/span span class=\"n\"z3_expression/spanspan class=\"p\"(/spanspan class=\"n\"opname1/spanspan class=\"p\",/span span class=\"n\"xvar/spanspan class=\"p\")/span\n        span class=\"n\"consts/span span class=\"o\"=/span span class=\"n\"find_constant/spanspan class=\"p\"(/spanspan class=\"n\"z3/spanspan class=\"o\"./spanspan class=\"n\"And/spanspan class=\"p\"(/spanspan class=\"n\"valid_if/spanspan class=\"p\",/span span class=\"n\"valid_if1/spanspan class=\"p\",/span span class=\"n\"result/span span class=\"o\"==/span span class=\"n\"result1/spanspan class=\"p\"))/span\n        span class=\"k\"for/span span class=\"n\"const/span span class=\"ow\"in/span span class=\"n\"consts/spanspan class=\"p\":/span\n            span class=\"nb\"print/spanspan class=\"p\"(/spanspan class=\"sa\"f/spanspan class=\"s2\"\"/spanspan class=\"si\"{/spanspan class=\"n\"opname/spanspan class=\"si\"}/spanspan class=\"s2\"(x, /spanspan class=\"si\"{/spanspan class=\"n\"const/spanspan class=\"si\"}/spanspan class=\"s2\") -gt; /spanspan class=\"si\"{/spanspan class=\"n\"opname1/spanspan class=\"si\"}/spanspan class=\"s2\"(x)\"/spanspan class=\"p\")/span\n\n        span class=\"c1\"# try to find a constant op(c, x) == g(x)/span\n        span class=\"n\"result/spanspan class=\"p\",/span span class=\"n\"valid_if/span span class=\"o\"=/span span class=\"n\"z3_expression/spanspan class=\"p\"(/spanspan class=\"n\"opname/spanspan class=\"p\",/span span class=\"n\"constvar/spanspan class=\"p\",/span span class=\"n\"xvar/spanspan class=\"p\")/span\n        span class=\"n\"result1/spanspan class=\"p\",/span span class=\"n\"valid_if1/span span class=\"o\"=/span span class=\"n\"z3_expression/spanspan class=\"p\"(/spanspan class=\"n\"opname1/spanspan class=\"p\",/span span class=\"n\"xvar/spanspan class=\"p\")/span\n        span class=\"n\"consts/span span class=\"o\"=/span span class=\"n\"find_constant/spanspan class=\"p\"(/spanspan class=\"n\"z3/spanspan class=\"o\"./spanspan class=\"n\"And/spanspan class=\"p\"(/spanspan class=\"n\"valid_if/spanspan class=\"p\",/span span class=\"n\"valid_if1/spanspan class=\"p\",/span span class=\"n\"result/span span class=\"o\"==/span span class=\"n\"result1/spanspan class=\"p\"))/span\n        span class=\"k\"for/span span class=\"n\"const/span span class=\"ow\"in/span span class=\"n\"consts/spanspan class=\"p\":/span\n            span class=\"nb\"print/spanspan class=\"p\"(/spanspan class=\"sa\"f/spanspan class=\"s2\"\"/spanspan class=\"si\"{/spanspan class=\"n\"opname/spanspan class=\"si\"}/spanspan class=\"s2\"(/spanspan class=\"si\"{/spanspan class=\"n\"const/spanspan class=\"si\"}/spanspan class=\"s2\", x) -gt; /spanspan class=\"si\"{/spanspan class=\"n\"opname1/spanspan class=\"si\"}/spanspan class=\"s2\"(x)\"/spanspan class=\"p\")/span\n/pre/div\n\npWhich yields the following new simplifications:/p\ndiv class=\"code\"pre class=\"code literal-block\"span class=\"n\"int_sub/spanspan class=\"p\"(/spanspan class=\"mi\"0/spanspan class=\"p\",/spanspan class=\"w\" /spanspan class=\"n\"x/spanspan class=\"p\")/spanspan class=\"w\" /spanspan class=\"o\"-gt;/spanspan class=\"w\" /spanspan class=\"n\"int_neg/spanspan class=\"p\"(/spanspan class=\"n\"x/spanspan class=\"p\")/span\nspan class=\"n\"int_sub/spanspan class=\"p\"(/spanspan class=\"o\"-/spanspan class=\"mi\"1/spanspan class=\"p\",/spanspan class=\"w\" /spanspan class=\"n\"x/spanspan class=\"p\")/spanspan class=\"w\" /spanspan class=\"o\"-gt;/spanspan class=\"w\" /spanspan class=\"n\"int_invert/spanspan class=\"p\"(/spanspan class=\"n\"x/spanspan class=\"p\")/span\nspan class=\"n\"int_mul/spanspan class=\"p\"(/spanspan class=\"n\"x/spanspan class=\"p\",/spanspan class=\"w\" /spanspan class=\"o\"-/spanspan class=\"mi\"1/spanspan class=\"p\")/spanspan class=\"w\" /spanspan class=\"o\"-gt;/spanspan class=\"w\" /spanspan class=\"n\"int_neg/spanspan class=\"p\"(/spanspan class=\"n\"x/spanspan class=\"p\")/span\nspan class=\"n\"int_mul/spanspan class=\"p\"(/spanspan class=\"o\"-/spanspan class=\"mi\"1/spanspan class=\"p\",/spanspan class=\"w\" /spanspan class=\"n\"x/spanspan class=\"p\")/spanspan class=\"w\" /spanspan class=\"o\"-gt;/spanspan class=\"w\" /spanspan class=\"n\"int_neg/spanspan class=\"p\"(/spanspan class=\"n\"x/spanspan class=\"p\")/span\nspan class=\"n\"int_xor/spanspan class=\"p\"(/spanspan class=\"n\"x/spanspan class=\"p\",/spanspan class=\"w\" /spanspan class=\"o\"-/spanspan class=\"mi\"1/spanspan class=\"p\")/spanspan class=\"w\" /spanspan class=\"o\"-gt;/spanspan class=\"w\" /spanspan class=\"n\"int_invert/spanspan class=\"p\"(/spanspan class=\"n\"x/spanspan class=\"p\")/span\nspan class=\"n\"int_xor/spanspan class=\"p\"(/spanspan class=\"o\"-/spanspan class=\"mi\"1/spanspan class=\"p\",/spanspan class=\"w\" /spanspan class=\"n\"x/spanspan class=\"p\")/spanspan class=\"w\" /spanspan class=\"o\"-gt;/spanspan class=\"w\" /spanspan class=\"n\"int_invert/spanspan class=\"p\"(/spanspan class=\"n\"x/spanspan class=\"p\")/span\nspan class=\"n\"int_eq/spanspan class=\"p\"(/spanspan class=\"n\"x/spanspan class=\"p\",/spanspan class=\"w\" /spanspan class=\"mi\"0/spanspan class=\"p\")/spanspan class=\"w\" /spanspan class=\"o\"-gt;/spanspan class=\"w\" /spanspan class=\"n\"int_is_zero/spanspan class=\"p\"(/spanspan class=\"n\"x/spanspan class=\"p\")/span\nspan class=\"n\"int_eq/spanspan class=\"p\"(/spanspan class=\"mi\"0/spanspan class=\"p\",/spanspan class=\"w\" /spanspan class=\"n\"x/spanspan class=\"p\")/spanspan class=\"w\" /spanspan class=\"o\"-gt;/spanspan class=\"w\" /spanspan class=\"n\"int_is_zero/spanspan class=\"p\"(/spanspan class=\"n\"x/spanspan class=\"p\")/span\nspan class=\"n\"int_ne/spanspan class=\"p\"(/spanspan class=\"n\"x/spanspan class=\"p\",/spanspan class=\"w\" /spanspan class=\"mi\"0/spanspan class=\"p\")/spanspan class=\"w\" /spanspan class=\"o\"-gt;/spanspan class=\"w\" /spanspan class=\"n\"int_is_true/spanspan class=\"p\"(/spanspan class=\"n\"x/spanspan class=\"p\")/span\nspan class=\"n\"int_ne/spanspan class=\"p\"(/spanspan class=\"mi\"0/spanspan class=\"p\",/spanspan class=\"w\" /spanspan class=\"n\"x/spanspan class=\"p\")/spanspan class=\"w\" /spanspan class=\"o\"-gt;/spanspan class=\"w\" /spanspan class=\"n\"int_is_true/spanspan class=\"p\"(/spanspan class=\"n\"x/spanspan class=\"p\")/span\nspan class=\"n\"uint_lt/spanspan class=\"p\"(/spanspan class=\"mi\"0/spanspan class=\"p\",/spanspan class=\"w\" /spanspan class=\"n\"x/spanspan class=\"p\")/spanspan class=\"w\" /spanspan class=\"o\"-gt;/spanspan class=\"w\" /spanspan class=\"n\"int_is_true/spanspan class=\"p\"(/spanspan class=\"n\"x/spanspan class=\"p\")/span\nspan class=\"n\"uint_lt/spanspan class=\"p\"(/spanspan class=\"n\"x/spanspan class=\"p\",/spanspan class=\"w\" /spanspan class=\"mi\"1/spanspan class=\"p\")/spanspan class=\"w\" /spanspan class=\"o\"-gt;/spanspan class=\"w\" /spanspan class=\"n\"int_is_zero/spanspan class=\"p\"(/spanspan class=\"n\"x/spanspan class=\"p\")/span\nspan class=\"n\"uint_le/spanspan class=\"p\"(/spanspan class=\"mi\"1/spanspan class=\"p\",/spanspan class=\"w\" /spanspan class=\"n\"x/spanspan class=\"p\")/spanspan class=\"w\" /spanspan class=\"o\"-gt;/spanspan class=\"w\" /spanspan class=\"n\"int_is_true/spanspan class=\"p\"(/spanspan class=\"n\"x/spanspan class=\"p\")/span\nspan class=\"n\"uint_le/spanspan class=\"p\"(/spanspan class=\"n\"x/spanspan class=\"p\",/spanspan class=\"w\" /spanspan class=\"mi\"0/spanspan class=\"p\")/spanspan class=\"w\" /spanspan class=\"o\"-gt;/spanspan class=\"w\" /spanspan class=\"n\"int_is_zero/spanspan class=\"p\"(/spanspan class=\"n\"x/spanspan class=\"p\")/span\nspan class=\"n\"uint_gt/spanspan class=\"p\"(/spanspan class=\"n\"x/spanspan class=\"p\",/spanspan class=\"w\" /spanspan class=\"mi\"0/spanspan class=\"p\")/spanspan class=\"w\" /spanspan class=\"o\"-gt;/spanspan class=\"w\" /spanspan class=\"n\"int_is_true/spanspan class=\"p\"(/spanspan class=\"n\"x/spanspan class=\"p\")/span\nspan class=\"n\"uint_gt/spanspan class=\"p\"(/spanspan class=\"mi\"1/spanspan class=\"p\",/spanspan class=\"w\" /spanspan class=\"n\"x/spanspan class=\"p\")/spanspan class=\"w\" /spanspan class=\"o\"-gt;/spanspan class=\"w\" /spanspan class=\"n\"int_is_zero/spanspan class=\"p\"(/spanspan class=\"n\"x/spanspan class=\"p\")/span\nspan class=\"n\"uint_ge/spanspan class=\"p\"(/spanspan class=\"n\"x/spanspan class=\"p\",/spanspan class=\"w\" /spanspan class=\"mi\"1/spanspan class=\"p\")/spanspan class=\"w\" /spanspan class=\"o\"-gt;/spanspan class=\"w\" /spanspan class=\"n\"int_is_true/spanspan class=\"p\"(/spanspan class=\"n\"x/spanspan class=\"p\")/span\nspan class=\"n\"uint_ge/spanspan class=\"p\"(/spanspan class=\"mi\"0/spanspan class=\"p\",/spanspan class=\"w\" /spanspan class=\"n\"x/spanspan class=\"p\")/spanspan class=\"w\" /spanspan class=\"o\"-gt;/spanspan class=\"w\" /spanspan class=\"n\"int_is_zero/spanspan class=\"p\"(/spanspan class=\"n\"x/spanspan class=\"p\")/span\nspan class=\"n\"int_pydiv/spanspan class=\"p\"(/spanspan class=\"n\"x/spanspan class=\"p\",/spanspan class=\"w\" /spanspan class=\"o\"-/spanspan class=\"mi\"1/spanspan class=\"p\")/spanspan class=\"w\" /spanspan class=\"o\"-gt;/spanspan class=\"w\" /spanspan class=\"n\"int_neg/spanspan class=\"p\"(/spanspan class=\"n\"x/spanspan class=\"p\")/span\n/pre/div\n\nh3 id=\"conclusions\"Conclusions/h3\npWith not very little code we managed to generate a whole lot of local\nsimplifications for integer operations in the IR of PyPy's JIT. The rules\ndiscovered that way are \"simple\", in the sense that they only require looking\nat a single instruction, and not where the arguments of that instruction came\nfrom. They also don't require any knowledge about the properties of the\narguments of the instructions (e.g. that they are positive)./p\npThe rewrites in this post have mostly been in PyPy's JIT already. But now we\nmechanically confirmed that they are correct. I've also added the remaining\nuseful looking ones, in particular codeint_eq(x, 0) -gt; int_is_zero(x)/code etc./p\npIf we wanted to scale this approach up, we would have to work much harder!\nThere are a bunch of problems that come with generalizing the approach to\nlooking at sequences of instructions:/p\nul\nli\npCombinatorial explosion: if we look at sequences of instructions, we very\n  quickly get a combinatorial explosion and it becomes untractable to try all\n  combinations./p\n/li\nli\npFinding non-minimal patterns: Some complicated simplifications can be\n  instances of simpler ones. For example, because codeint_add(x, 0) -gt; x/code, it's\n  also true that codeint_add(int_sub(x, y), 0) -gt; int_sub(x, y)/code. If we simply\n  generate all possible sequences, we will find the latter simplification rule,\n  which we would usually not care about./p\n/li\nli\npUnclear usefulness: if we simply generate all rewrites up to a certain number\n  of instructions, we will get a lot of patterns that are useless in the sense\n  that they typically aren't found in realistic programs. It would be much\n  better to somehow focus on the patterns that real benchmarks are using./p\n/li\n/ul\npIn the a href=\"https://www.pypy.org/posts/2024/07/mining-jit-traces-missing-optimizations-z3.html\"next blog post/a I'll discuss an alternative approach to simply generating\nall possible sequences of instructions, that tries to address these problems.\nThis works by analyzing the real traces of benchmarks and mining those for\ninefficiencies, which only shows problems that occur in actual programs./p\nh3 id=\"sources\"Sources/h3\npI've been re-reading a lot of blog posts from John's blog:/p\nul\nlia href=\"https://blog.regehr.org/archives/1109\"Lets Work on an LLVM Superoptimizer/a/li\nlia href=\"https://blog.regehr.org/archives/1146\"Early Superoptimizer Results/a/li\nlia href=\"https://blog.regehr.org/archives/1252\"A Few Synthesizing Superoptimizer Results/a/li\nlia href=\"https://blog.regehr.org/archives/1636\"Synthesizing Constants/a/li\n/ul\npbut also papers:/p\nul\nlia href=\"https://arxiv.org/pdf/1711.04422\"A Synthesizing Superoptimizer/a/li\nlia href=\"https://dl.acm.org/doi/pdf/10.1145/3649837\"Hydra: Generalizing Peephole Optimizations with Program Synthesis/a/li\n/ul\npAnother of my favorite blogs has been a href=\"https://www.philipzucker.com/\"Philipp Zucker's\nblog/a in the last year or two, lots of excellent\nposts about/using Z3 on there./p",
      "link": "https://www.pypy.org/posts/2024/07/finding-simple-rewrite-rules-jit-z3.html",
      "links": [],
      "published": "2024-07-12T19:14:09+00:00",
      "summary": "",
      "title": "Finding Simple Rewrite Rules for the JIT with Z3"
    },
    {
      "author": "Christoph Jung",
      "content": [
        {
          "type": "text/html",
          "value": "h3 id=\"introduction\"Introduction/h3\npIf you ever wanted to profile your Python code on PyPy, you probably came across a href=\"https://vmprof.readthedocs.io/en/latest/vmprof.html\"VMProf/a  a statistical profiler for PyPy./p\npVMProf's console output can already give some insights into where your code spends time,\nbut it is far from showing all the information captured while profiling./p\npThere have been some tools around to visualize VMProf's output.\nUnfortunately the vmprof.com user interface is no longer available and vmprof-server is not as easy to use, you may want to take a look at a local viewer or converter.\nThose so far could give you some general visualizations of your profile, but do not show any PyPy related context like PyPy's log output (a href=\"https://rpython.readthedocs.io/en/latest/logging.html\"PyPyLog/a, which is output when using the PYPYLOG environment variable to log JIT actions)./p\npTo bring all of those features together in one tool, you may take a look at the vmprof-firefox-converter./p\npCreated in the context of my bachelor's thesis, the vmprof-firefox-converter is a tool for analyzing VMProf profiles with the a href=\"https://profiler.firefox.com/\"Firefox profiler/a user interface.\nInstead of building a new user interface from scratch, this allows us to reuse the user interface work Mozilla put into the Firefox profiler.\nThe Firefox profiler offers a timeline where you can zoom into profiles and work with different visualizations like a flame graph or a stack chart.\nTo understand why there is time spent inside a function, you can revisit the source code and even dive into the intermediate representation of functions executed by PyPy's just-in-time compiler.\nAdditionally, there is a visualization for PyPy's log output, to keep track whether PyPy spent time inside the interpreter, JIT or GC throughout the profiling time./p\nh3 id=\"profiling-word-count\"Profiling word count/h3\npIn this blog post, I want to show an example of how to use the vmprof-firefox-converter for a simple Python program.\nBased on Ben Hoyt's blog a href=\"https://benhoyt.com/writings/count-words/\"Performance comparison: counting words in Python, Go, C++, C, AWK, Forth, and Rust/a we will profile two python versions of a word counter running on PyPy. One being a bit more optimized. For this, VMProf will be used, but instead of just going with the console output, we will use the Firefox profiler user interface./p\npAt first, we are going to look at a simple way of counting words with codeCollections.Counter/code.\nThis will read one line from the standard input at a time and count the words with codecounter.update()/code/p\ndiv class=\"code\"pre class=\"code literal-block\"counts = collections.Counter()\nfor line in sys.stdin:\n    words = line.lower().split()\n    counts.update(words)\n\nfor word, count in counts.most_common():\n    print(word, count)\n/pre/div\n\npTo start profiling, simply execute:\ncodepypy -m vmprofconvert -run simple.py lt;kjvbible_x10.txt/code/p\npThis will run the above code with vmprof, automatically capture and convert the results and finally open the Firefox profiler. /p\npThe input file is the king James version of the bible concatenated ten times./p\npTo get started, we take a look at the call stack./p\npimg src=\"https://github.com/Cskorpion/vmprof-firefox-converter/blob/main/images/blog/simple_call_stack_crp.png?raw=true\"\nHere we see that most of the time is spent in native code (marked as blue) e.g., the codecounter.update()/code or codesplit()/code C implementation./p\npNow let's proceed with the more optimized version.\nThis time we read 64 Kb of data from the standard input and count the words with codecounter.update()/code./p\ndiv class=\"code\"pre class=\"code literal-block\"counts = collections.Counter()\nremaining = ''\nwhile True:\n    chunk = remaining + sys.stdin.read(64*1024)\n    if not chunk:\n        break\n    last_lf = chunk.rfind('\\n')  # process to last LF character\n    if last_lf == -1:\n        remaining = ''\n    else:\n        remaining = chunk[last_lf+1:]\n        chunk = chunk[:last_lf]\n    counts.update(chunk.lower().split())\n\nfor word, count in counts.most_common():\n    print(word, count)\n/pre/div\n\npAs we did before, we are going to take a peek at the call stack./p\npimg src=\"https://github.com/Cskorpion/vmprof-firefox-converter/blob/main/images/blog/optimized_call_stack_crp.png?raw=true\" /p\npNow there is more time spent in native code, caused by larger chunks of text passed to  codecounter.update()/code./p\npThis becomes even more clear by comparing the stack charts./p\npimg src=\"https://github.com/Cskorpion/vmprof-firefox-converter/blob/main/images/blog/simple_stack_chart.png?raw=true\"/p\npHere, in the unoptimized case, we only read in one line at each loop iteration.\nThis results in small \"spikes\" in the stack chart. /p\npBut let's take an even closer look./p\npimg src=\"https://github.com/Cskorpion/vmprof-firefox-converter/blob/main/images/blog/simple_stack_chart_zoom.png?raw=true\"/p\npZoomed in, we see the call stack alternating between code_count_elements()/code and (unfortunately unsymbolized) native calls coming from reading and splitting the input text (e.g., codedecode()/code)./p\npLet us now take a look at the optimized case./p\npimg src=\"https://github.com/Cskorpion/vmprof-firefox-converter/blob/main/images/blog/optimized_stack_chart.png?raw=true\"/p\npAnd if we look closer at the same interval as before, we see some spikes, but slightly different./p\npimg src=\"https://github.com/Cskorpion/vmprof-firefox-converter/blob/main/images/blog/optimized_stack_chart_zoom.png?raw=true\"/p\npEven though we do not want to compare the (amount of) milliseconds directly, we clearly see that the spikes are wider, i.e. the time spent in those function calls is longer.\nYou may already know where this comes from.\nWe read a 64 Kb chunk of data from std in and pass that to codecounter.update()/code, so both these tasks do more work and take longer.\nBigger chunks mean there is less alternating between reading and counting, so there is more time spent doing work than \"doing\" loop iterations./p\nh3 id=\"getting-started\"Getting started/h3\npYou can get the converter from a href=\"https://github.com/Cskorpion/vmprof-firefox-converter\"GitHub/a./p\npBoth VMProf and the vmprof-firefox-converter were created for profiling PyPy, but you can also use them with CPython. /p\npThis project is still somewhat experimental, so if you want to try it out, please let us know whether it worked for you./p"
        }
      ],
      "description": "h3 id=\"introduction\"Introduction/h3\npIf you ever wanted to profile your Python code on PyPy, you probably came across a href=\"https://vmprof.readthedocs.io/en/latest/vmprof.html\"VMProf/a  a statistical profiler for PyPy./p\npVMProf's console output can already give some insights into where your code spends time,\nbut it is far from showing all the information captured while profiling./p\npThere have been some tools around to visualize VMProf's output.\nUnfortunately the vmprof.com user interface is no longer available and vmprof-server is not as easy to use, you may want to take a look at a local viewer or converter.\nThose so far could give you some general visualizations of your profile, but do not show any PyPy related context like PyPy's log output (a href=\"https://rpython.readthedocs.io/en/latest/logging.html\"PyPyLog/a, which is output when using the PYPYLOG environment variable to log JIT actions)./p\npTo bring all of those features together in one tool, you may take a look at the vmprof-firefox-converter./p\npCreated in the context of my bachelor's thesis, the vmprof-firefox-converter is a tool for analyzing VMProf profiles with the a href=\"https://profiler.firefox.com/\"Firefox profiler/a user interface.\nInstead of building a new user interface from scratch, this allows us to reuse the user interface work Mozilla put into the Firefox profiler.\nThe Firefox profiler offers a timeline where you can zoom into profiles and work with different visualizations like a flame graph or a stack chart.\nTo understand why there is time spent inside a function, you can revisit the source code and even dive into the intermediate representation of functions executed by PyPy's just-in-time compiler.\nAdditionally, there is a visualization for PyPy's log output, to keep track whether PyPy spent time inside the interpreter, JIT or GC throughout the profiling time./p\nh3 id=\"profiling-word-count\"Profiling word count/h3\npIn this blog post, I want to show an example of how to use the vmprof-firefox-converter for a simple Python program.\nBased on Ben Hoyt's blog a href=\"https://benhoyt.com/writings/count-words/\"Performance comparison: counting words in Python, Go, C++, C, AWK, Forth, and Rust/a we will profile two python versions of a word counter running on PyPy. One being a bit more optimized. For this, VMProf will be used, but instead of just going with the console output, we will use the Firefox profiler user interface./p\npAt first, we are going to look at a simple way of counting words with codeCollections.Counter/code.\nThis will read one line from the standard input at a time and count the words with codecounter.update()/code/p\ndiv class=\"code\"pre class=\"code literal-block\"counts = collections.Counter()\nfor line in sys.stdin:\n    words = line.lower().split()\n    counts.update(words)\n\nfor word, count in counts.most_common():\n    print(word, count)\n/pre/div\n\npTo start profiling, simply execute:\ncodepypy -m vmprofconvert -run simple.py lt;kjvbible_x10.txt/code/p\npThis will run the above code with vmprof, automatically capture and convert the results and finally open the Firefox profiler. /p\npThe input file is the king James version of the bible concatenated ten times./p\npTo get started, we take a look at the call stack./p\npimg src=\"https://github.com/Cskorpion/vmprof-firefox-converter/blob/main/images/blog/simple_call_stack_crp.png?raw=true\"\nHere we see that most of the time is spent in native code (marked as blue) e.g., the codecounter.update()/code or codesplit()/code C implementation./p\npNow let's proceed with the more optimized version.\nThis time we read 64 Kb of data from the standard input and count the words with codecounter.update()/code./p\ndiv class=\"code\"pre class=\"code literal-block\"counts = collections.Counter()\nremaining = ''\nwhile True:\n    chunk = remaining + sys.stdin.read(64*1024)\n    if not chunk:\n        break\n    last_lf = chunk.rfind('\\n')  # process to last LF character\n    if last_lf == -1:\n        remaining = ''\n    else:\n        remaining = chunk[last_lf+1:]\n        chunk = chunk[:last_lf]\n    counts.update(chunk.lower().split())\n\nfor word, count in counts.most_common():\n    print(word, count)\n/pre/div\n\npAs we did before, we are going to take a peek at the call stack./p\npimg src=\"https://github.com/Cskorpion/vmprof-firefox-converter/blob/main/images/blog/optimized_call_stack_crp.png?raw=true\" /p\npNow there is more time spent in native code, caused by larger chunks of text passed to  codecounter.update()/code./p\npThis becomes even more clear by comparing the stack charts./p\npimg src=\"https://github.com/Cskorpion/vmprof-firefox-converter/blob/main/images/blog/simple_stack_chart.png?raw=true\"/p\npHere, in the unoptimized case, we only read in one line at each loop iteration.\nThis results in small \"spikes\" in the stack chart. /p\npBut let's take an even closer look./p\npimg src=\"https://github.com/Cskorpion/vmprof-firefox-converter/blob/main/images/blog/simple_stack_chart_zoom.png?raw=true\"/p\npZoomed in, we see the call stack alternating between code_count_elements()/code and (unfortunately unsymbolized) native calls coming from reading and splitting the input text (e.g., codedecode()/code)./p\npLet us now take a look at the optimized case./p\npimg src=\"https://github.com/Cskorpion/vmprof-firefox-converter/blob/main/images/blog/optimized_stack_chart.png?raw=true\"/p\npAnd if we look closer at the same interval as before, we see some spikes, but slightly different./p\npimg src=\"https://github.com/Cskorpion/vmprof-firefox-converter/blob/main/images/blog/optimized_stack_chart_zoom.png?raw=true\"/p\npEven though we do not want to compare the (amount of) milliseconds directly, we clearly see that the spikes are wider, i.e. the time spent in those function calls is longer.\nYou may already know where this comes from.\nWe read a 64 Kb chunk of data from std in and pass that to codecounter.update()/code, so both these tasks do more work and take longer.\nBigger chunks mean there is less alternating between reading and counting, so there is more time spent doing work than \"doing\" loop iterations./p\nh3 id=\"getting-started\"Getting started/h3\npYou can get the converter from a href=\"https://github.com/Cskorpion/vmprof-firefox-converter\"GitHub/a./p\npBoth VMProf and the vmprof-firefox-converter were created for profiling PyPy, but you can also use them with CPython. /p\npThis project is still somewhat experimental, so if you want to try it out, please let us know whether it worked for you./p",
      "link": "https://www.pypy.org/posts/2024/05/vmprof-firefox-converter.html",
      "links": [],
      "published": "2024-04-26T14:38:00+00:00",
      "summary": "",
      "title": "Profiling PyPy using the Firefox profiler user interface"
    }
  ],
  "feed": {
    "generator": "Nikola (getnikola.com)",
    "guidislink": false,
    "id": null,
    "language": null,
    "link": "https://www.pypy.org/",
    "links": [],
    "subtitle": "A Faster Python",
    "subtitle_detail": {
      "base": null,
      "language": null,
      "type": "text/plain",
      "value": "A Faster Python"
    },
    "title": "PyPy",
    "title_detail": {
      "base": null,
      "language": null,
      "type": "text/plain",
      "value": "PyPy"
    },
    "updated": "Thu, 14 Nov 2024 08:45:19 GMT"
  }
}