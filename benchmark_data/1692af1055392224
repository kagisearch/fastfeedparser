<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title><![CDATA[Still debugging]]></title><description><![CDATA[Still Debugging is where I break down what I‚Äôve learned (often the hard way), clear up concepts that confused me, and share patterns and pitfalls across Java, J]]></description><link>https://blog.gaurang.page</link><generator>RSS for Node</generator><lastBuildDate>Wed, 18 Feb 2026 02:18:32 GMT</lastBuildDate><atom:link href="https://blog.gaurang.page/rss.xml" rel="self" type="application/rss+xml"/><language><![CDATA[en]]></language><ttl>60</ttl><item><title><![CDATA[ORMs: A Solution Looking for a Problem?]]></title><description><![CDATA[Introduction
When I first got into web development during my college days, the process was refreshingly straightforward. I would set up a PHP backend, execute my SQL queries using mysqli_query, and that was it‚Äîno models, no layers, just raw queries a...]]></description><link>https://blog.gaurang.page/orms-a-solution-looking-for-a-problem</link><guid isPermaLink="true">https://blog.gaurang.page/orms-a-solution-looking-for-a-problem</guid><category><![CDATA[ORM (Object-Relational Mapping)]]></category><category><![CDATA[Java]]></category><category><![CDATA[Node.js]]></category><category><![CDATA[hibernate]]></category><category><![CDATA[Sequelize]]></category><category><![CDATA[mongoose]]></category><dc:creator><![CDATA[Gaurang Pansare]]></dc:creator><pubDate>Mon, 30 Jun 2025 20:27:53 GMT</pubDate><enclosure url="https://cdn.hashnode.com/res/hashnode/image/upload/v1752004053059/9d957fc2-ce4f-4e87-a007-0ec1b11afb16.png" length="0" type="image/jpeg"/><content:encoded><![CDATA[<h1 id="heading-introduction">Introduction</h1>
<p>When I first got into web development during my college days, the process was refreshingly straightforward. I would set up a PHP backend, execute my SQL queries using <code>mysqli_query</code>, and that was it‚Äîno models, no layers, just raw queries and the data I needed.</p>
<pre><code class="lang-php">$conn = mysqli_connect(<span class="hljs-string">"localhost"</span>, <span class="hljs-string">"root"</span>, <span class="hljs-string">""</span>, <span class="hljs-string">"mydb"</span>);
$result = mysqli_query($conn, <span class="hljs-string">"SELECT * FROM users WHERE id = 1"</span>);
</code></pre>
<p>Then I was introduced to <a target="_blank" href="https://hibernate.org/orm/">Hibernate ORM</a> in Java. Later, <a target="_blank" href="https://sequelize.org/">Sequelize ORM</a> in Node.js. And eventually, <a target="_blank" href="https://mongoosejs.com/">Mongoose ODM</a> with MongoDB. Suddenly, everything was an object, everything had a schema, and everything required a model definition.</p>
<p>For those unfamiliar, <strong>ORM</strong> (Object Relational Mapping) and <strong>ODM</strong> (Object Document Mapping) tools let you interact with your database using objects in your programming language ‚Äî instead of writing raw SQL or database commands. ORMs are typically used with relational databases like MySQL or PostgreSQL, while ODMs are used with document databases like MongoDB. So instead of crafting a SQL <code>SELECT</code> statement, you call something like <code>User.findAll()</code> or <code>User.save()</code> in your code, and the ORM or ODM library handles the database part under the hood.</p>
<h1 id="heading-my-initial-reaction-these-people-are-mad"><strong>My Initial Reaction:</strong> ‚ÄúThese People Are Mad!!‚Äù</h1>
<p>I vividly remember my initial reaction while learning about Hibernate ORM during a Java crash course at my first job: <em>‚ÄúWHHHATT?! These Java people are MAD!‚Äù</em> Why does everything need to be a class, a model, or a POJO object? If I can retrieve my data with a one-line SQL query, why must I now split that across three files and define models, relationships, and repositories just to achieve the same result?</p>
<p>It felt like some kind of object-worship cult. SQL ‚Äî a perfectly capable language ‚Äî was suddenly not allowed to sit next to Java. No, no. We must now jump through a flaming hoop of entity files and framework magic just to avoid writing SQL directly.</p>
<h1 id="heading-then-came-sequelize-and-then-mongoose">Then Came Sequelize... And Then Mongoose</h1>
<p>When I switched to Node.js, we used <a target="_blank" href="https://sequelize.org/">Sequelize ORM</a>. Same story ‚Äî more models, more boilerplate, more time spent reading docs just to figure out how to define a basic relationship between entities.</p>
<p>Even after working with Sequelize for years, I would <em>still</em> have to go back to their <a target="_blank" href="https://sequelize.org/docs/v6/core-concepts/assocs/">documentation on associations</a> to understand how to use <code>hasOne</code>, <code>belongsTo</code>, and <code>through</code>. Every. Single. Time.</p>
<p>Then came MongoDB and the <a target="_blank" href="https://mongoosejs.com/">Mongoose ODM</a>. And my confusion reached a whole new level. MongoDB is supposed to be <em>schema-less</em>, right? And JavaScript isn‚Äôt even a typed language. So why the heck are we defining schemas?</p>
<p>People often say that ORMs make it easy to switch between relational databases ‚Äî like swapping MySQL for PostgreSQL ‚Äî because they abstract away the underlying database. Fair enough. But in the case of MongoDB, what exactly am I switching to? Sure, other document databases exist ‚Äî but Mongoose is tightly coupled to MongoDB, so the whole ‚Äúyou can switch databases‚Äù argument kind of falls apart here.</p>
<p>And let‚Äôs be real ‚Äî no one‚Äôs casually swapping out their database on a Tuesday afternoon. Even if you did want to, it‚Äôs rarely seamless. You can‚Äôt just unplug Postgres and plug in MySQL and expect things to work because <em>‚Äúwe use an ORM‚Äù</em>. If someone has actually done that flawlessly, please message me ‚Äî I need to see this miracle firsthand.</p>
<p>Out of a mix of curiosity and a bit of rebellion, I once wrote a quick script for a one-off task that just updated some data in MongoDB. I didn‚Äôt bother using Mongoose or defining any schema. I just used the native MongoDB Node.js client ‚Äî no models, no schema validation, nothing. And it worked. Which left me thinking: if this gets the job done, why go through all the extra steps with Mongoose and its overhead?</p>
<p>People also say that with an ORM, developers don‚Äôt need to learn SQL ‚Äî they can just stick to the programming language they already know. But here‚Äôs the catch: you still have to learn how to use the ORM! And most of them have their own conventions, syntax, and rules. You didn‚Äôt really avoid learning something new ‚Äî you just traded SQL for something else. Sometimes, something even more confusing.</p>
<p>In fact, I‚Äôve lost count of how many times I had a perfectly valid SQL query ‚Äî maybe something I got from a colleague or wrote for debugging ‚Äî and then had to spend extra time figuring out how to express that same logic using the ORM‚Äôs syntax. Sometimes it's straightforward, but other times it feels like translating from English to Klingon.</p>
<h1 id="heading-we-think-its-just-mapping">We Think It's Just ‚ÄúMapping‚Äù</h1>
<p>I came across a line ‚Äî maybe in a MongoDB blog or a talk (I honestly can‚Äôt recall the exact source) ‚Äî that really struck a chord and got me thinking:</p>
<blockquote>
<p>‚ÄúMongoDB is schema-less. But your data sure follows some schema.‚Äù</p>
</blockquote>
<p>That line really made me pause. Just because MongoDB doesn‚Äôt <em>enforce</em> a schema doesn‚Äôt mean your app doesn‚Äôt <em>need</em> one. Without some kind of structure, things quickly spiral into chaos ‚Äî making the code harder to understand, maintain, and trust.</p>
<p>And that‚Äôs where tools like ORMs and ODMs come in. The phrase <em>Object Relational Mapping</em> or <em>Object Document Mapping</em> sounds so harmless. Just a mapping. No big deal.</p>
<p>But we often lose context for <em>why</em> that mapping matters.</p>
<h1 id="heading-the-reality-without-orms"><strong>The Reality Without ORMs</strong></h1>
<p>Let‚Äôs imagine a production-grade app built entirely without ORMs or ODMs.</p>
<h2 id="heading-raw-sql-everywhere">Raw SQL Everywhere</h2>
<p>Your queries end up scattered throughout the codebase ‚Äî sometimes written inline alongside business logic, sometimes tucked away in helper functions. If your team is organized, maybe there‚Äôs a dedicated file or folder just for SQL strings. But even then, they‚Äôre just raw strings ‚Äî meaning the compiler, linter, or even your IDE‚Äôs IntelliSense can‚Äôt catch errors, offer suggestions, or help you refactor them safely.</p>
<p>And that‚Äôs the real problem: if there‚Äôs <em>any</em> mistake in one of those strings ‚Äî a wrong column name, a missing comma, <code>ORDER BY</code> before <code>WHERE</code> ‚Äî you don‚Äôt know until the query actually runs.</p>
<p>And if the query is buried in a rarely-used API endpoint? That bug could sit unnoticed for months. Then one day, someone calls that API, and boom ‚Äî SQL error in production.</p>
<p>Now imagine someone renames a column or changes a data type in the DB. Good luck finding every instance of that column across your codebase. Miss one, and you‚Äôll find out the hard way.</p>
<h2 id="heading-conditional-joins-get-messy">Conditional Joins Get Messy</h2>
<p>Let‚Äôs say you‚Äôre building an API to fetch employee details. If the employee is an intern, include the <code>university_address</code> table. If they‚Äôre a manager, include the <code>office_address</code> table. Both have similar schemas, but they‚Äôre still separate tables ‚Äî so your joins and logic must adapt accordingly.</p>
<p>You now have two options:</p>
<ul>
<li><p><strong>Option 1:</strong> Write separate SQL queries for each case. This often results in duplicated logic ‚Äî like repeating the same <code>SELECT</code>, <code>WHERE</code>, <code>ORDER BY</code> clauses or shared joins ‚Äî across multiple queries.</p>
</li>
<li><p><strong>Option 2:</strong> Dynamically build the query with string concatenation. That reduces redundancy, but now no one knows what the final query looks like without running the code.</p>
</li>
</ul>
<p>Now imagine handling 6‚Äì8 optional joins like this. Yikes!</p>
<h2 id="heading-transactions-and-multi-step-logic">Transactions and Multi-Step Logic</h2>
<p>Now imagine you need a transaction: create an employee, then insert into <code>employee_address</code>, and based on role, insert into either <code>manager</code>, <code>intern</code>, or <code>director</code>.</p>
<p>Without an ORM, you‚Äôre manually building a query block like this:</p>
<pre><code class="lang-sql"><span class="hljs-keyword">BEGIN</span>;
<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> employee (<span class="hljs-keyword">name</span>, <span class="hljs-keyword">role</span>) <span class="hljs-keyword">VALUES</span> (<span class="hljs-string">'John Doe'</span>, <span class="hljs-string">'manager'</span>);
<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> employee_address (employee_id, address) <span class="hljs-keyword">VALUES</span> (<span class="hljs-keyword">LAST_INSERT_ID</span>(), <span class="hljs-string">'123 Office St'</span>);
<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> manager (employee_id, department) <span class="hljs-keyword">VALUES</span> (<span class="hljs-keyword">LAST_INSERT_ID</span>(), <span class="hljs-string">'Engineering'</span>);
<span class="hljs-keyword">COMMIT</span>;
</code></pre>
<p>Now imagine you have to add logic to conditionally insert into <code>intern</code> or <code>director</code> instead of <code>manager</code>, handle rollbacks, and construct this dynamically in code using string concatenation ‚Äî things get messy fast.</p>
<p>In the previous section, we saw how conditional joins can complicate a single query. Now imagine chaining multiple such conditionally-executed queries into a single transaction. It becomes more difficult to read, understand or even predict what the final query will look like.</p>
<h2 id="heading-input-validation-and-sql-injection-risks"><strong>Input Validation and SQL Injection Risks</strong></h2>
<p>When you build queries by stitching strings together ‚Äî especially with values coming from API requests ‚Äî things can get dangerous fast. You have to be extremely cautious about validating and sanitizing every input, or you risk exposing your app to SQL injection attacks. ORMs take care of this for you by using parameter binding and escaping inputs safely by default. That means one less thing to worry about every time you write a query ‚Äî and a big step toward keeping your APIs secure.</p>
<h1 id="heading-lessons-from-real-projects">Lessons From Real Projects</h1>
<p>Here are two real work experiences that I‚Äôve faced.</p>
<h2 id="heading-changing-column-names">Changing Column Names</h2>
<p>At work, we sometimes had to rename DB columns. With JPQL, all I had to do was update the field name in the entity class. Done. The app might throw a few syntax errors on startup, but once fixed, everything stays consistent.</p>
<p>With native queries? Total pain. Every single query using that column had to be updated. And that could be in hundreds! Miss one, and it quietly fails later when someone happens to hit that endpoint.</p>
<h2 id="heading-environment-specific-schema-hack">Environment-Specific Schema Hack</h2>
<p>Once, our client didn‚Äôt want to set up a separate database instance for pre-prod environment. Instead, they asked us to create a different database schema in the same instance.</p>
<p>Now, Spring Boot allows us to configure a custom strategy to set the schema name. But it only applies to the JPQL queries - the ones that are ORM-based. And since most of our queries were native, we had to create a Java file with the schema names, exclude it from Git, and manually place a different version on each environment's server. We also had to update all our queries to use the schema name from the Java file.</p>
<p>It worked. But it was fragile, ugly, and easily avoidable if we had relied more on ORM features.</p>
<h1 id="heading-what-ive-come-to-realize">What I've come to realize</h1>
<p>I used to think that ORMs were just bloated frameworks trying to make simple things harder. But over time, I realized they‚Äôre actually solving the problems you don‚Äôt even know you‚Äôll have ‚Äî until it‚Äôs too late.</p>
<h2 id="heading-when-you-try-to-build-your-own-mini-orm">üõ† When You Try to Build Your Own Mini ORM</h2>
<p>Let‚Äôs be honest ‚Äî if you‚Äôre going to pull out query strings, schema names, and column names into separate files, and then write logic to stitch strings together based on conditions... aren‚Äôt you basically building your own mini ORM? You‚Äôre solving the exact problems that ORMs are designed to handle.</p>
<p>Only now, it‚Äôs more error-prone, less generic, and tightly coupled to your project. ORMs already do this ‚Äî and they do it better, more reliably, and in a way that works across projects and teams.</p>
<h2 id="heading-the-orm-but-still-raw-sql-anti-pattern">üö® The ‚ÄúORM But Still Raw SQL‚Äù Anti-Pattern</h2>
<p>Imagine you buy an expensive bed for your cat‚Ä¶ and it still sleeps in a cardboard box.<br />Or you visit a doctor, get prescribed medicine‚Ä¶ and then never finish the course.<br />Or you buy nice clothes, only to leave them unworn in the closet.</p>
<p>Frustrating, right?</p>
<p>That‚Äôs exactly what it‚Äôs like when a project includes an ORM ‚Äî but developers still write most of the queries in raw SQL. You're adding the overhead, but not reaping any of the benefits.</p>
<p>I‚Äôve seen codebases where an ORM was technically in place, but nearly all queries were still written natively. In that case, you‚Äôre getting the worst of both worlds ‚Äî extra boilerplate from the ORM, and all the risks of raw SQL.</p>
<p>To be clear, most ORMs do let you run raw queries ‚Äî and that‚Äôs by design. It‚Äôs meant as a fallback, for when you have a complex SQL query that the ORM syntax can‚Äôt express easily. But that‚Äôs a backup plan, not the main plan. If you find yourself reaching for raw queries by default, you‚Äôre not really using the ORM ‚Äî you‚Äôre just working around it.</p>
<p>A lot of times, teams stick with raw queries because learning the ORM feels like extra work. Or they were told to use an ORM, so they did ‚Äî but without really getting why it matters. And in the end, they miss out on everything the ORM was supposed to help with.</p>
<p>If you‚Äôre using an ORM, native queries should be your last resort. The more you rely on raw queries, the more you defeat the purpose of using an ORM in the first place.</p>
<p>As your project grows, you‚Äôll eventually run into a moment where you think,<br /><em>‚ÄúWe already have the ORM. This would‚Äôve been trivial if we just used it properly.‚Äù</em><br />But by then, the ORM feels useless ‚Äî not because it didn‚Äôt work, but because we never used it the way it was meant to be used. The tool had the power to help ‚Äî and yet we couldn't tap into it when it mattered most.</p>
<h2 id="heading-not-perfect-but-worth-it">üß© Not Perfect, But Worth It</h2>
<p>Sure, they aren‚Äôt perfect. Sometimes the queries these ORMs generate are messy. Sometimes they feel overkill for basic stuff. Sometimes, they get in the way. But they solve real problems. They handle transactions, conditional logic, rollbacks, query sanitization ‚Äî all in your app‚Äôs native language. You write clean logic. It handles the mess behind the scenes.</p>
<h2 id="heading-the-real-value">üß± The Real Value</h2>
<p>They‚Äôre not just ‚Äúmappers.‚Äù They‚Äôre your defense against chaos that give you:</p>
<ul>
<li><p>üîí Safer queries</p>
</li>
<li><p>üîß Easier maintenance</p>
</li>
<li><p>üîÑ Smoother schema changes</p>
</li>
<li><p>üîÅ Better handling of relationships, conditional logic, and transactions</p>
</li>
</ul>
<p>‚ú® It‚Äôs not about being able to switch databases or not having to learn SQL. It‚Äôs about building something that won‚Äôt fall apart when things get complicated.</p>
<h1 id="heading-summary">Summary</h1>
<p>ORMs and ODMs can feel like unnecessary overhead in small projects or one-off scripts ‚Äî and in these cases, skipping them is perfectly fine. But as your codebase grows, raw queries introduce real risks: scattered queries, fragile string concatenation, and painful schema changes. ORMs and ODMs bring structure, safety, and consistency that scale with your application.</p>
<p>This article isn‚Äôt about always using ORMs ‚Äî it‚Äôs about understanding why they matter.</p>
<p>You can get things done without them ‚Äî but when things get complex, you‚Äôll be glad you have them.</p>
<hr />
<p><strong>P.S.</strong> This turned out to be a long one ‚Äî so if you made it all the way to the end, thank you! üôå I hope it gave you something to think about. If you have any questions or thoughts, feel free to leave a comment below. And if you found it helpful, a like or share would really mean a lot! üòä</p>
]]></content:encoded></item><item><title><![CDATA[[Node.js] How to Use Promises in a Callback-based Codebase]]></title><description><![CDATA[Hi! I'm Gaurang. I‚Äôve worked extensively with Node.js in the past, and during that time, I spent a lot of effort wrangling with different async patterns ‚Äî callbacks, promises, and async/await. This article is part of my series, "My guide to getting t...]]></description><link>https://blog.gaurang.page/nodejs-how-to-use-promises-in-a-callback-based-codebase</link><guid isPermaLink="true">https://blog.gaurang.page/nodejs-how-to-use-promises-in-a-callback-based-codebase</guid><category><![CDATA[Node.js]]></category><category><![CDATA[callback]]></category><category><![CDATA[promises]]></category><category><![CDATA[asynchronous]]></category><dc:creator><![CDATA[Gaurang Pansare]]></dc:creator><pubDate>Sun, 25 May 2025 19:20:12 GMT</pubDate><enclosure url="https://cdn.hashnode.com/res/hashnode/image/upload/v1748197190690/11f083ef-6560-4012-aea7-7e78540773c4.png" length="0" type="image/jpeg"/><content:encoded><![CDATA[<p>Hi! I'm Gaurang. I‚Äôve worked extensively with Node.js in the past, and during that time, I spent a lot of effort wrangling with different async patterns ‚Äî callbacks, promises, and async/await. This article is part of my series, <em>"</em><a target="_blank" href="https://blog.gaurang.page/series/nodejs-async-guide"><em>My guide to getting through the maze of callbacks, promises, and async-await</em></a><em>"</em>, where I share lessons learned and best practices for writing asynchronous code in Node.js.</p>
<p>This article assumes you‚Äôre familiar with basic Node.js concepts, especially asynchronous programming constructs like callbacks, promises, and async/await.</p>
<hr />
<h1 id="heading-converting-a-promise-based-function-to-use-callbacks">Converting a Promise-based Function to Use Callbacks</h1>
<p>Often, you‚Äôll find yourself working in older codebases where asynchronous functions are written using the callback pattern. Node.js also offers a built-in way to convert a Promise-returning function into a callback-based one using <code>util.callbackify()</code>.</p>
<p>Personally, I believe we should avoid writing new callbacks whenever possible. Even in a callback-heavy codebase, it's often worth introducing promises or async/await for better readability and maintainability.<br />I‚Äôve spent years digging through callback-infested codebases, and I‚Äôll say it plainly: callbacks are obsolete. They had their time, but that time is over. Stop writing them. Let them die.</p>
<p>Use this only when absolutely necessary ‚Äî like when you're deep in a legacy callback jungle and need to drop in a Promise-based function without rewriting everything around it.</p>
<div class="embed-wrapper"><div class="embed-loading"><div class="loadingRow"></div><div class="loadingRow"></div></div><a class="embed-card" href="https://gist.github.com/gaurang847/38e6f62eff32ac2e3bfb444f74f13585.js?file=promise_in_callback">https://gist.github.com/gaurang847/38e6f62eff32ac2e3bfb444f74f13585.js?file=promise_in_callback</a></div>
<p> </p>
<h1 id="heading-prefer-then-chaining-over-nesting">Prefer Then-chaining over nesting</h1>
<p>It's common to see people misuse promises by nesting <code>.then()</code> calls instead of chaining them. This leads to "Promise hell", which is structurally similar to "callback hell."</p>
<div class="embed-wrapper"><div class="embed-loading"><div class="loadingRow"></div><div class="loadingRow"></div></div><a class="embed-card" href="https://gist.github.com/gaurang847/38e6f62eff32ac2e3bfb444f74f13585.js?file=promise_hell">https://gist.github.com/gaurang847/38e6f62eff32ac2e3bfb444f74f13585.js?file=promise_hell</a></div>
<p> </p>
<p>Callbacks are difficult to work with primarily because of their deeply nested structure. Promises were introduced to address this by enabling a more linear, manageable code flow.</p>
<p>Of course, code with then-chaining may not be as readable and intuitive as synchronous code or code written with async-await. But it is more manageable than code with nested thens.</p>
<p>For a deeper dive into why Promise hell is best avoided ‚Äî and how to write cleaner promise chains ‚Äî check out these excellent articles:</p>
<div class="embed-wrapper"><div class="embed-loading"><div class="loadingRow"></div><div class="loadingRow"></div></div><a class="embed-card" href="https://dev.to/somedood/please-don-t-nest-promises-3o1o">https://dev.to/somedood/please-don-t-nest-promises-3o1o</a></div>
<p> </p>
<div class="embed-wrapper"><div class="embed-loading"><div class="loadingRow"></div><div class="loadingRow"></div></div><a class="embed-card" href="https://medium.com/@pyrolistical/how-to-get-out-of-promise-hell-8c20e0ab0513">https://medium.com/@pyrolistical/how-to-get-out-of-promise-hell-8c20e0ab0513</a></div>
<p> </p>
<p>Keep in mind that it‚Äôs not just <code>.then()</code> chains you need to keep clean ‚Äî <strong>don‚Äôt nest callback-based functions inside a</strong> <code>.then()</code> either. This is a common mistake that defeats the purpose of using Promises in the first place.</p>
<p>If you‚Äôre already using Promises, don‚Äôt go back to callbacks mid-way. Promises are designed to give you a linear, manageable control flow ‚Äî and the moment you reintroduce nested callbacks, you throw that benefit away. Whether you‚Äôre nesting callbacks or <code>.then()</code> blocks, the result is the same: harder-to-read code.</p>
<p>Instead, convert the callback-based function into a Promise using any of the methods discussed in my previous article ‚Äú<a target="_blank" href="https://blog.gaurang.page/nodejs-using-callback-based-functions-when-the-rest-of-the-code-uses-promises">Using callback-based functions when the rest of the code uses Promises</a>‚Äú and keep your chain linear.</p>
<div class="embed-wrapper"><div class="embed-loading"><div class="loadingRow"></div><div class="loadingRow"></div></div><a class="embed-card" href="https://gist.github.com/gaurang847/38e6f62eff32ac2e3bfb444f74f13585.js?file=avoid_nesting_cb_in_promise">https://gist.github.com/gaurang847/38e6f62eff32ac2e3bfb444f74f13585.js?file=avoid_nesting_cb_in_promise</a></div>
<p> </p>
<p>Notice that <code>readFile2CB</code> is a callback-based function. If you nest it (as shown in the bad-code example), any code that relies on <code>content2</code> or <code>results</code> must go <em>inside</em> that nested block. Over time, this leads to deeply indented, harder-to-read code ‚Äî exactly the kind of mess Promises were created to prevent.</p>
<p>Once you start using Promises, commit to the pattern. Nesting defeats the purpose. Whether you‚Äôre nesting <code>.then()</code> blocks or stuffing callbacks inside them, you‚Äôre trading away clarity and maintainability ‚Äî the very reasons Promises exist.</p>
<hr />
<p>If you're stuck in a callback-heavy codebase, I feel your pain. Use these patterns sparingly, but push for modern async functions where you can ‚Äî your future self (and your teammates) will thank you.</p>
<p>I've put a lot of work into this article. And I hope that it has been helpful. If you have any questions, please feel free to leave a comment below. I'd really appreciate it if you could like and share the article! üòä</p>
]]></content:encoded></item><item><title><![CDATA[[Node.js] Using callback-based functions when the rest of the code uses Promises]]></title><description><![CDATA[Hey!
My name is Gaurang and I've been working with Node.js for the past 5 years. This article is part of the "My Guide to Getting through the Maze of Callbacks and Promises" series. It's a 3-part series where I talk about writing asynchronous code wi...]]></description><link>https://blog.gaurang.page/nodejs-using-callback-based-functions-when-the-rest-of-the-code-uses-promises</link><guid isPermaLink="true">https://blog.gaurang.page/nodejs-using-callback-based-functions-when-the-rest-of-the-code-uses-promises</guid><category><![CDATA[Node.js]]></category><category><![CDATA[JavaScript]]></category><category><![CDATA[promises]]></category><category><![CDATA[asynchronous]]></category><category><![CDATA[callback]]></category><dc:creator><![CDATA[Gaurang Pansare]]></dc:creator><pubDate>Sun, 07 May 2023 19:20:14 GMT</pubDate><enclosure url="https://cdn.hashnode.com/res/hashnode/image/upload/v1748716152326/bc59c7a6-7b61-4928-b1fd-43f865e71238.png" length="0" type="image/jpeg"/><content:encoded><![CDATA[<p>Hey!</p>
<p>My name is Gaurang and I've been working with Node.js for the past 5 years. This article is part of the "<a target="_blank" href="https://blog.gaurang.page/series/nodejs-async-guide">My Guide to Getting through the Maze of Callbacks and Promises</a>" series. It's a 3-part series where I talk about writing asynchronous code with Node.js.</p>
<p>The articles are intermediate-level and it is expected that the reader already has basic familiarity with Node.js syntax and the constructs related to asynchronous programming in it. Such as callbacks, promises, and async-await.</p>
<hr />
<h1 id="heading-introduction">Introduction</h1>
<p>Promises were introduced in JavaScript in 2015 - just 8 years back from the date of writing this article. Async-await was introduced in 2017 - just 6 years back. That was not a very long time ago. (At least not enough to eradicate the use of callbacks üò¢)</p>
<p>As a working professional, you often need to work with legacy code. So as a JavaScript/Node.js developer, God forbid, you may have to work with callbacks at some point. And I'm assuming that you've had enough exposure to callbacks to understand the general dread that they bring.</p>
<p>It takes time to get a hang of writing code with callbacks. For those without prior experience with asynchronous programming, it is no different than bullfighting for the first time. For this reason, I believe they try to stick to the sync version of async functions. If you've read my previous article in the series, you would know that this approach is more damaging than it is helpful.</p>
<p>My personal opinion is that the best way to deal with callback-based functions is to convert them into promise-returning ones.</p>
<p>Suppose, you're working on a Node.js-based project. You created new modules (it could be APIs, controllers, utility services, etc.); everything using promises and async-await. However, there are some legacy functions written using the callback approach. You need to call one such function but don't want to give birth to a callback hell.</p>
<p>There are 3 ways of going ahead with this.</p>
<ol>
<li><p>Use <code>util.promisify</code> (My favourite)</p>
</li>
<li><p>Create a new promise.</p>
</li>
<li><p>Create a dual-behaviour wrapper that can get you either a callback or a Promise based on your requirement</p>
</li>
</ol>
<h1 id="heading-using-utilpromisify">Using <code>util.promisify</code></h1>
<p>A lot of people don't know about this gem that was introduced in Node.js version 8. If the legacy callback-based function uses the standard <a target="_blank" href="https://fredkschott.com/post/2014/03/understanding-error-first-callbacks-in-node-js/">error-first callback style</a> and the callback is the last argument, you can create a promise-returning function with minimal code using <a target="_blank" href="https://nodejs.org/api/util.html#utilinspectobject-options"><code>util.promisify</code></a>.</p>
<div class="embed-wrapper"><div class="embed-loading"><div class="loadingRow"></div><div class="loadingRow"></div></div><a class="embed-card" href="https://gist.github.com/gaurang847/d2e9265a2b2a6d5a3a72cbb942c31dea.js?file=promisify_simple">https://gist.github.com/gaurang847/d2e9265a2b2a6d5a3a72cbb942c31dea.js?file=promisify_simple</a></div>
<p> </p>
<p>You have to be careful using it with functions that belong to a class/object though.</p>
<div class="embed-wrapper"><div class="embed-loading"><div class="loadingRow"></div><div class="loadingRow"></div></div><a class="embed-card" href="https://gist.github.com/gaurang847/d2e9265a2b2a6d5a3a72cbb942c31dea.js?file=promisify_with_bind">https://gist.github.com/gaurang847/d2e9265a2b2a6d5a3a72cbb942c31dea.js?file=promisify_with_bind</a></div>
<p> </p>
<p>If you're new to the bind function and are not sure what the object context is, here are a few great resources that may help:</p>
<ul>
<li><p><a target="_blank" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/bind">MDN docs on bind function</a></p>
</li>
<li><p><a target="_blank" href="https://youtu.be/GhbhD1HR5vk">MPJ's explainer video on bind and this</a></p>
</li>
<li><p><a target="_blank" href="https://www.javascripttutorial.net/javascript-bind/">JavaScript Tutorial article on bind function</a></p>
</li>
</ul>
<p>One of the best things about <code>util.promisify</code> is that it works flawlessly with Node.js native library methods such as functions belonging to modules: <code>fs</code>, <code>child_process</code>, etc. You can use it to promisify <code>setTimeout</code> as well.</p>
<h1 id="heading-creating-a-new-promise">Creating a new Promise</h1>
<p>If the callback-based function doesn't follow proper conventions. Or for some reason, <code>util.promisify</code> doesn't work for you, you can always create a custom new Promise.</p>
<div class="embed-wrapper"><div class="embed-loading"><div class="loadingRow"></div><div class="loadingRow"></div></div><a class="embed-card" href="https://gist.github.com/gaurang847/d2e9265a2b2a6d5a3a72cbb942c31dea.js?file=new_promise">https://gist.github.com/gaurang847/d2e9265a2b2a6d5a3a72cbb942c31dea.js?file=new_promise</a></div>
<p> </p>
<p>You can move the Promise-creation to a separate function if doing it inline looks shabby.</p>
<div class="embed-wrapper"><div class="embed-loading"><div class="loadingRow"></div><div class="loadingRow"></div></div><a class="embed-card" href="https://gist.github.com/gaurang847/d2e9265a2b2a6d5a3a72cbb942c31dea.js?file=new_promise_new_func">https://gist.github.com/gaurang847/d2e9265a2b2a6d5a3a72cbb942c31dea.js?file=new_promise_new_func</a></div>
<p> </p>
<p><strong>Note:</strong> Here, <code>promisifiedAsyncFunction</code> does not use async-await. But, it returns a Promise. So, we have to use <code>await</code> in the <code>main</code> function while calling <code>promisifiedAsyncFunction</code></p>
<p>If the callback-based function belongs to a class/object, you'll need to take care of the context.</p>
<div class="embed-wrapper"><div class="embed-loading"><div class="loadingRow"></div><div class="loadingRow"></div></div><a class="embed-card" href="https://gist.github.com/gaurang847/d2e9265a2b2a6d5a3a72cbb942c31dea.js?file=new_promise_new_func_with_class">https://gist.github.com/gaurang847/d2e9265a2b2a6d5a3a72cbb942c31dea.js?file=new_promise_new_func_with_class</a></div>
<p> </p>
<h1 id="heading-create-a-promisecallback-dual-behaviour-wrapper">Create a Promise/callback dual-behaviour wrapper</h1>
<p>If you have access to the source code of the original callback-based function. And the authority to modify it, you can create a wrapper around it. This wrapper will work as a callback-based function if a callback is provided. If not, it'll return a Promise.</p>
<p>This dual-behaviour wrapper lets you work with Promises in new code that you write. Without disturbing the old code where the function is expected to work with a callback. Thus, it provides Promise support with backward compatibility for callback-based legacy code.</p>
<div class="embed-wrapper"><div class="embed-loading"><div class="loadingRow"></div><div class="loadingRow"></div></div><a class="embed-card" href="https://gist.github.com/gaurang847/d2e9265a2b2a6d5a3a72cbb942c31dea.js?file=dual_behaviour_wrapper">https://gist.github.com/gaurang847/d2e9265a2b2a6d5a3a72cbb942c31dea.js?file=dual_behaviour_wrapper</a></div>
<p> </p>
<p>Previously, if the module exported the <code>callbackBasedAsyncFunc</code> function, now it can export the <code>dualBehaviourWrapper</code>.</p>
<pre><code class="lang-javascript"><span class="hljs-comment">// Previously</span>
<span class="hljs-built_in">module</span>.exports.callbackBasedAsyncFunc = callbackBasedAsyncFunc;

<span class="hljs-comment">// Now</span>
<span class="hljs-built_in">module</span>.exports.callbackBasedAsyncFunc = dualBehaviourWrapper;
</code></pre>
<p>Thus, with minimal modification, you can add Promise support to a legacy module. And all the other existing modules, that are calling <code>callbackBasedAsyncFunc</code> by passing a callback, remain unaffected. Win-win!</p>
<p>You might have noticed that a lot of popular NPM libraries give similar dual-behaviour support for their functions where they use a callback if it is passed, and return a Promise if a callback is not passed. Their implementation may be different though. For example, <a target="_blank" href="https://mochajs.org/#asynchronous-code">mocha.js</a></p>
<h1 id="heading-conclusion">Conclusion</h1>
<p>Overall, handling callback-based functions when the rest of your code uses promises can be a bit tricky. However, by following the tips in this article, you can make the process much easier. With a little practice, you'll be handling callback-based functions like a pro in no time!</p>
<p>I've put a lot of work into this article. And I hope that it has been helpful. If you have any questions, please feel free to leave a comment below.<br />I'd really appreciate it if you could like and share the article! üòä</p>
<h1 id="heading-footnote"><strong>Footnote</strong></h1>
<p><code>fs</code> version 10 introduced Promises API which has promise-based versions of functions. Have a look at the <a target="_blank" href="https://nodejs.org/docs/latest-v10.x/api/fs.html#fs_fs_promises_api">documentation</a>. So you don't need to struggle with callbacks or manually convert <code>fs</code> functions to Promise-based ones.</p>
]]></content:encoded></item><item><title><![CDATA[[Node.js] Why using sync versions of async functions is bad.]]></title><description><![CDATA[Hey!
My name is Gaurang and I've been working with Node.js for the past 5 years. This article is part of the "My Guide to Getting through the Maze of Callbacks and Promises" series. It's a 3-part series where I talk about writing asynchronous code wi...]]></description><link>https://blog.gaurang.page/nodejs-why-using-sync-versions-of-async-functions-is-bad</link><guid isPermaLink="true">https://blog.gaurang.page/nodejs-why-using-sync-versions-of-async-functions-is-bad</guid><category><![CDATA[Node.js]]></category><category><![CDATA[JavaScript]]></category><category><![CDATA[performance]]></category><category><![CDATA[asynchronous]]></category><category><![CDATA[Web Development]]></category><dc:creator><![CDATA[Gaurang Pansare]]></dc:creator><pubDate>Wed, 15 Mar 2023 16:41:18 GMT</pubDate><enclosure url="https://cdn.hashnode.com/res/hashnode/image/upload/v1678817401656/3fb2299a-e5ae-4637-89bd-870f3db6130c.png" length="0" type="image/jpeg"/><content:encoded><![CDATA[<p>Hey!</p>
<p>My name is Gaurang and I've been working with Node.js for the past 5 years. This article is part of the "<a target="_blank" href="https://blog.gaurang.page/series/nodejs-async-guide">My Guide to Getting through the Maze of Callbacks and Promises</a>" series. It's a 3-part series where I talk about writing asynchronous code with Node.js.</p>
<p>The articles are intermediate-level and it is expected that the reader already has basic familiarity with Node.js syntax and the constructs related to asynchronous programming in it. Such as callbacks, promises, and async-await.</p>
<hr />
<h1 id="heading-sync-of-async-what">Sync of Async what?</h1>
<p>Before I go ahead and beef about synchronous functions, I suppose I should briefly describe synchronous as well as asynchronous functions.</p>
<p>Many Node.js packages provide synchronous alternatives to their asynchronous functions. For example, the <code>fs</code> package has <a target="_blank" href="https://nodejs.org/api/fs.html#fsreadfilepath-options-callback"><code>fs.readFile</code></a> (which works asynchronously) and <a target="_blank" href="https://nodejs.org/api/fs.html#fsreadfilesyncpath-options"><code>fs.readFileSync</code></a> (which works synchronously).</p>
<p>The working of <code>fs.readFileSync</code> is similar to traditional functions. Your program calls the method and waits for the file to be read. Once the file is completely read, it returns the contents. The program then resumes execution of the rest of the code.</p>
<p>In contrast, when our program calls the asynchronous <code>fs.readFile</code> method, it does not wait for the method to read the entire file and return the contents. Our program moves ahead with the execution of the rest of the code immediately; while <code>fs.readFile</code> continues with the reading task in parallel.</p>
<p>If there's any code you want to execute after the file contents have been read, you need to wrap the code in a function and pass that function to <code>fs.readFile</code> as a callback. <code>fs.readFile</code> will call the callback function as soon as the file contents have been read. This way of writing code is an engineering choice made by the creators of Node.js. And it allows Node.js to be extremely fast despite being single-threaded.</p>
<p>Here's a sample script demonstrating the difference between synchronous and asynchronous programming in JavaScript.</p>
<div class="embed-wrapper"><div class="embed-loading"><div class="loadingRow"></div><div class="loadingRow"></div></div><a class="embed-card" href="https://gist.github.com/gaurang847/2cfc5a2b0edda0db1950a289cb4baafa.js?file=sync_vs_async">https://gist.github.com/gaurang847/2cfc5a2b0edda0db1950a289cb4baafa.js?file=sync_vs_async</a></div>
<p> </p>
<h1 id="heading-whats-wrong-with-using-sync-versions-of-async-functions">What's wrong with using sync versions of async functions?</h1>
<p>Today, I often come across codebases where callbacks, promises, and async-await have been mixed together. Turning the code into a hotch-potch. I sympathize with the people that have to work with such codebases. Understanding callbacks and promises is difficult. Writing code with callbacks is difficult. Understanding the difference between synchronous and asynchronous functions is difficult.</p>
<p>The advent of <a target="_blank" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function">async-await</a> has made writing code in JavaScript fairly straightforward. Most people learning JavaScript today do not know what a pain it used to be when using callbacks was the primary method of writing code. As a result, they often lack experience in handling callbacks.</p>
<p>People often retreat to synchronous versions of library methods because they're more convenient. E.g. <a target="_blank" href="https://nodejs.org/api/fs.html#fsreadfilesyncpath-options"><code>fs.readFileSync</code></a>, <code>fs.writeFileSync</code>, <code>fs.copyFileSync</code>, <code>child_process.execSync</code>, etc. In my opinion, that is one of the worst things to do to your project.</p>
<p>People generally opt for Node.js due to its reputation for fast network and I/O operations. However, it's crucial not to overlook the fundamental reason behind this efficiency: Node.js's single-threaded, asynchronous execution model! Utilizing synchronous versions of I/O and network operations can significantly impair your application's performance compared to counterparts developed in alternative languages.</p>
<p>Asynchronous functions are designed to be non-blocking and to avoid delays. As Node.js is single-threaded, just one long-running synchronous (blocking) task is enough to degrade the performance of the entire application. Using synchronous versions of asynchronous functions may seem like an easy solution at first, but it is the devil in disguise. It can cause delays all over the application; leading to frustration for developers and users alike.</p>
<p>Of course, if you're writing a small independent one-time script, the performance degradation may not matter much. But in large production-level applications, this is going to cause unnecessary bottlenecks.</p>
<p>Here's a short demo of how a synchronous method call affects the rest of the application.</p>
<div class="gist-block embed-wrapper" data-gist-show-loading="false" data-id="f1680c593ebe56bbd2fedf15468c5b51"><div class="embed-loading"><div class="loadingRow"></div><div class="loadingRow"></div></div><a href="https://gist.github.com/gaurang847/f1680c593ebe56bbd2fedf15468c5b51" class="embed-card">https://gist.github.com/gaurang847/f1680c593ebe56bbd2fedf15468c5b51</a></div><p> </p>
<div class="embed-wrapper"><div class="embed-loading"><div class="loadingRow"></div><div class="loadingRow"></div></div><a class="embed-card" href="https://youtu.be/xxKffpI7EIY">https://youtu.be/xxKffpI7EIY</a></div>
<p> </p>
<p>This script starts a barebones Node.js server that has three APIs.</p>
<ul>
<li><p><code>GET /quick-api</code></p>
</li>
<li><p><code>GET /slow-sync-api</code></p>
</li>
<li><p><code>GET /slow-async-api</code></p>
</li>
</ul>
<p>The <code>quick-api</code> API is supposed to return a response immediately. But, if you call <code>quick-api</code> after calling <code>slow-sync-api</code>, it does not return until <code>slow-sync-api</code> returns. This is because Node.js is single-threaded. And <code>slow-sync-api</code> calls a synchronous method that does not let the main thread do anything else until its execution is complete. It blocks all other requests. However, if you call <code>quick-api</code> after <code>slow-async-api</code>, the <code>quick-api</code> works as expected. This is because <code>slow-async-api</code> does not block the main thread till its execution is complete. The work of the asynchronous function is deferred to a worker thread and the main thread waits for the execution to complete. Meanwhile, the main thread is free to fulfill other requests.</p>
<h1 id="heading-conclusion">Conclusion</h1>
<p>Asynchronous execution is integral to JavaScript. So, you'll find asynchronous functions everywhere. Transitioning from a traditional synchronous mindset to an asynchronous one takes some adjustment.</p>
<p>However, using the synchronous versions of asynchronous functions is a bad practice. It can lead to unexpected behavior and performance bottlenecks. When performing asynchronous operations, it's best to use the asynchronous version of functions whenever possible. This will help you avoid any potential problems and ensure that your code is as efficient as possible.</p>
<hr />
<p>I've put a lot of work into this article. And I hope that it has been helpful. If you have any questions, please feel free to leave a comment below. I'd really appreciate it if you could like and share the article! üòä</p>
]]></content:encoded></item><item><title><![CDATA[Do you really understand interfaces?]]></title><description><![CDATA[The lead-up
When I was learning Java in college, I did not understand the use of interfaces. You can't define functions inside an interface. You can only declare them. You have to have a class implement the interface to define its functions and then ...]]></description><link>https://blog.gaurang.page/do-you-really-understand-interfaces</link><guid isPermaLink="true">https://blog.gaurang.page/do-you-really-understand-interfaces</guid><category><![CDATA[Java]]></category><category><![CDATA[interface]]></category><category><![CDATA[Object Oriented Programming]]></category><category><![CDATA[newbie]]></category><category><![CDATA[#codenewbies]]></category><dc:creator><![CDATA[Gaurang Pansare]]></dc:creator><pubDate>Sat, 14 Mar 2020 19:00:54 GMT</pubDate><enclosure url="https://cdn.hashnode.com/res/hashnode/image/upload/v1679149203228/f1794e71-4cc8-4124-ac50-e9630f66d8bd.png" length="0" type="image/jpeg"/><content:encoded><![CDATA[<h1 id="heading-the-lead-up">The lead-up</h1>
<p>When I was learning Java in college, I did not understand the use of interfaces. You can't define functions inside an interface. You can only declare them. You have to have a class implement the interface to define its functions and then use them. That's crazy! Pretty worthless piece of crap I would think. I can just write my classes and their functions normally. Why would I declare them in one place and define them in another? I don't even need to declare them. Just write my functions normally in a class. It's so redundant.</p>
<p>Confused and curious, I asked my teacher why I would ever require to implement an interface. Almost immediately, she said that interfaces let you achieve multiple inheritance, while normal classes don't - the textbook answer on the difference between classes and interfaces. And I was like, so? Even if my class can implement multiple interfaces at once, none of them would contain function definitions. They would all be pretty useless. I can just drop them all and write my class without implementing them. Single or multiple, what advantage do I get by using interfaces? My teacher did not have an answer to that.</p>
<p>With the lack of a proper answer, I and most (if not all) of my friends resigned ourselves to accepting that interfaces are some kind of mysterious artifacts. That, given the right incantation, would help us manipulate the space-time continuum, rip through the fabric of the Java ecosystem and use multiple inheritance - the fruit that is wrongly forbidden from us.</p>
<p>Meanwhile, we gave the same answer during our engineering vivas my teacher gave me. And wrote the same in our written exams. Something felt off though. And I could never digest this. It wasn't until later when I dabbled with Android that I learned the true purpose of interfaces - as a contract that lets <em>you enforce that, the classes you work with, exhibit certain behavior</em>.</p>
<p>I still come across people whose primary understanding of interfaces is something that allows multiple inheritance in Java. And that is so ridiculous - saying that interfaces support multiple inheritance while classes don't when I ask you what's the difference between the two. It's like saying that the difference between a dog and a horse is that a dog barks while horse neighs. While that is indeed true, you must understand that dogs and horses are fundamentally different animals! If your understanding of a horse is that of a dog that neighs. Then boy! You're going to have a wild time on a farm!</p>
<h1 id="heading-deadly-diamond-of-death">Deadly Diamond of Death</h1>
<p>First off, let's understand why multiple inheritance is not allowed in Java.</p>
<p>Consider there's a class <code>Animals</code>. All animals <code>makeNoise()</code>. We derive two child classes from this class - <code>Horses</code> and <code>Dogs</code>. Both of them override the <code>makeNoise()</code> behavior. Horses <code>makeNoise()</code> by neighing. Dogs <code>makeNoise()</code> by barking. Now suppose, for whatever godforsaken reason, a mad scientist decides to mix up the genes of Horses and Dogs together, and make a new species of Animals - <code>Horgs</code>. When the Horgs <code>makeNoise()</code>, will they bark? Or will they neigh? This is the infamous diamond problem (aka Deadly Diamond of Death) in object-oriented programming.</p>
<p><img src="https://dev-to-uploads.s3.amazonaws.com/i/3tb30o8gf52llo9v2fx1.png" alt="Graphical representation of the given Animal problem" /></p>
<p>Java doesn't support multiple inheritance with classes simply because <em>inheriting multiple classes together is problematic</em>. If a class inherits multiple other classes, and these classes contain functions with the same signature, there arises an ambiguity - when I call the said function with an instance of the inheriting (derived) class, how should it behave? Out of the many function definitions coming from multiple inherited classes, which should be considered? And how do I control which definition is used when?</p>
<p>C++ tries to handle the Diamond problem using <a target="_blank" href="https://en.wikipedia.org/wiki/Virtual_inheritance">virtual inheritance and scope resolution</a>. I'm not really a C++ person. And I don't understand how virtual inheritance works. But, from what I understand, it requires prior knowledge that a certain function may get involved in multiple inheritance. And it requires to be specially handled. Now that feels weird to me. I did not find many articles on the topic. So, maybe not many people use it. But, please do recommend me any good material on the topic if you have any.</p>
<h1 id="heading-how-do-interfaces-solve-the-diamond-problem">How do interfaces solve the diamond problem?</h1>
<p>They don't. As I said, they're not a mechanism to allow multiple inheritance. It's just that since interfaces don't have method definitions, they don't <strong><em>have</em></strong> the diamond problem. That is why you're allowed to implement multiple interfaces. That's all. But the notion that the use of interfaces is to enable multiple inheritance, is wrong and far from the truth.</p>
<h1 id="heading-the-idea-behind-interfaces">The idea behind interfaces</h1>
<p>Consider you're a king. You have a beautiful daughter who has reached the age of marriage. A lot of princes' from the neighboring nations are eager to marry your daughter. But, you have some basic criteria in mind that they should fulfill before they could be considered to marry your daughter.</p>
<ol>
<li><p>The Prince should be able to fight. 'cause that's a necessary skill to have for a prince</p>
</li>
<li><p>The Prince should like reading books. 'cause books contain knowledge. And you'd want your son-in-law to be well-educated and wise.</p>
</li>
<li><p>The Prince should be able to speak <a target="_blank" href="https://en.wikipedia.org/wiki/Klingon_language">Klingon</a>. 'cause that's the sign of a superior man.</p>
</li>
</ol>
<p>You write these requirements down on a big banner and place it above the castle gate. If a Prince comes and satisfies all these conditions, the gatekeeper awards him a 'Badass Prince' badge and sends him in. If, however, the prince doesn't meet these requirements, the gatekeeper of the castle won't even allow him inside.</p>
<p>Now, this is exactly the idea behind interfaces. The banner with the requirements on it is an interface for a 'Badass Prince'. And by enforcing those requirements on the prospective Prince, you're essentially requiring them to implement the 'Badass Prince' interface. Thus stating, that if a Prince <a target="_blank" href="https://stackoverflow.com/questions/2218937/has-a-is-a-terminology-in-object-oriented-language">is not a</a> 'Badass Prince' (as defined by your interface), they're not eligible to marry your daughter.</p>
<h1 id="heading-the-practical-use-of-interfaces-while-writing-software">The practical use of interfaces while writing software</h1>
<blockquote>
<p><em>If you know a class implements an interface, then you know that the class contains concrete implementations of the methods declared in that interface, and you are guaranteed to be able to invoke these methods safely.</em></p>
<p>‚Äî <a target="_blank" href="https://stackoverflow.com/a/17163473/5968979">StackOverflow answer</a></p>
</blockquote>
<p>Often, different teams work together to develop a product. They may work on different features or segments that are integrated together to form the final product. In such a case, it is obvious that there will be certain interdependencies within the teams.</p>
<p>Say, for example, we're building an e-commerce website. One team is developing the 'Add-to-cart' feature (the process before checkout). And another team is working on the online-payment system (the process after checkout). We definitely can't make the online payments team wait and idle till the cart team has finished and tested their feature.</p>
<p>But then, if both teams start working on their features in parallel, how do we ensure that we'll be able to integrate the online payments with the cart? In the end, both features should come together to form the final product, right? For example, the online payments team needs the cart to be cleared on successful payment. But, since the cart is not ready yet, how would the payments team do that? What function should they call? What parameters should they pass to it? What if the cart team doesn't implement such a function at all? And instead, do you have to write logic to remove every product from the cart individually?</p>
<p>To mitigate such problems, both teams must brainstorm about the technical requirements of their own features and realize the interdependencies. Once that is done, both teams can design appropriate interfaces. For example, the teams decide that on checkout, the cart system will provide a <code>MyCart</code> object to the payments system. This <code>MyCart</code> class must implement the Cart interface that has the following methods:</p>
<pre><code class="lang-java"><span class="hljs-number">1.</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">addProduct</span><span class="hljs-params">(Product product)</span>
2. Product <span class="hljs-title">removeProduct</span><span class="hljs-params">(integer productId)</span>
3. List&lt;Product&gt; <span class="hljs-title">getProductsFromCart</span><span class="hljs-params">()</span>
4. <span class="hljs-keyword">boolean</span> <span class="hljs-title">emptyCart</span><span class="hljs-params">()</span></span>
</code></pre>
<p>If the object provided by the cart system does not come from a class that has implemented the Cart interface, then the payments system will throw an Exception.</p>
<pre><code class="lang-java"><span class="hljs-keyword">if</span>(!(myCart <span class="hljs-keyword">instanceof</span> Cart)){
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Exception(<span class="hljs-string">"Expected an instance of Cart"</span>);
}
</code></pre>
<p>Due to the principle of <a target="_blank" href="http://www.edibleapple.com/2011/10/29/steve-jobs-explains-object-oriented-programming/">abstraction</a> in object-oriented programming, the payments team does not need to know how the <code>emptyCart</code> method works. They just need to know:</p>
<ol>
<li><p>that it exists</p>
</li>
<li><p>that it is intended to do what they want (clear all products in the cart)</p>
</li>
<li><p>how to call it (what parameters to pass and what to expect in return).</p>
</li>
</ol>
<p>Out of these, interfaces take care of points 1 and 3. Point 2 is left to the human intellect.</p>
<p>Basically, by asking the cart team to implement the <code>Cart</code> interface, the payments team says,</p>
<blockquote>
<p><em>"Hey cart team,</em> <em>We are not concerned about the logic and implementation on your side.</em> <em>But, we require certain functionality to be present in the object that you pass to us. And we require it in a very specific manner (with so and so name, so and so parameters, and so and so value returned).</em> <em>Please implement these exactly as specified so that we can just plug your cart system into our payment system. And we can have a seamless integration."</em></p>
</blockquote>
<p>This was just a simple example of when an interface is used. There might be more. But, I hope it helps you to understand what an important role interfaces play in software development. If you can think of more examples, please let me know in the comments.</p>
<blockquote>
<p><em>In computing, an interface is a shared boundary across which two or more separate components of a computer system exchange information.</em> <em>...</em> <em>An interface is thus a type definition; anywhere an object can be exchanged (for example, in a function or method call) the type of the object to be exchanged can be defined in terms of one of its implemented interfaces or base-classes rather than specifying the specific class.</em></p>
<p>‚Äî <a target="_blank" href="https://en.wikipedia.org/wiki/Interface_%28computing%29#In_object-oriented_languages">Wikipedia</a></p>
</blockquote>
<p>Also, a lot of people relate interfaces with legal contracts. This is because interfaces are based on mutual agreement between two parties; on how one party could use the services of another. You meet the requirements in the contract. And you shall enjoy our uninterrupted services. If you fall short of the terms of the contract, we shall no longer serve you.</p>
<blockquote>
<p><em>A contract is like a promise between people. It is an understanding, a deal between two or more people or organizations to do certain things.</em></p>
<p>‚Äî <a target="_blank" href="https://www.artslaw.com.au/legal/raw-law/what-is-a-contract/">Arts + Law article</a></p>
</blockquote>
<h1 id="heading-to-conclude">To conclude...</h1>
<ol>
<li><p>Multiple inheritance is problematic.</p>
</li>
<li><p>Java novices often wrongly associate interfaces with multiple inheritance. That's not what they are for.</p>
</li>
<li><p>An interface is a pretty powerful construct that lets you define the requirements of your software component. It also lets you enforce that other software components, that interact with yours, meet those requirements.</p>
</li>
</ol>
<h1 id="heading-official-oracle-documentation">Official Oracle documentation</h1>
<p>Oracle has provided some really awesome documentation on interfaces. So, please check out the following links and look around.</p>
<ul>
<li><p><a target="_blank" href="https://docs.oracle.com/javase/tutorial/java/concepts/interface.html">What is an Interface</a></p>
</li>
<li><p><a target="_blank" href="https://docs.oracle.com/javase/tutorial/java/IandI/createinterface.html">Interface Tutorial</a></p>
</li>
</ul>
]]></content:encoded></item><item><title><![CDATA[The odyssey of asynchronous JavaScript]]></title><description><![CDATA[The lead-up
When I was learning JavaScript (about 1-2 years back), my mentor had me go through it step-by-step. So, first I spent some time getting comfortable with callbacks. Then I jumped onto Promises. And then, after months, I started using Async...]]></description><link>https://blog.gaurang.page/the-odyssey-of-asynchronous-javascript</link><guid isPermaLink="true">https://blog.gaurang.page/the-odyssey-of-asynchronous-javascript</guid><category><![CDATA[Node.js]]></category><category><![CDATA[JavaScript]]></category><category><![CDATA[asynchronous]]></category><category><![CDATA[async]]></category><category><![CDATA[callback]]></category><dc:creator><![CDATA[Gaurang Pansare]]></dc:creator><pubDate>Tue, 29 Oct 2019 19:29:25 GMT</pubDate><enclosure url="https://cdn.hashnode.com/res/hashnode/image/stock/unsplash/rE3kbKmLmhE/upload/1340ab667d69c90f93abf0a59be444e5.jpeg" length="0" type="image/jpeg"/><content:encoded><![CDATA[<h2 id="heading-the-lead-up">The lead-up</h2>
<p>When I was learning JavaScript (about 1-2 years back), my mentor had me go through it step-by-step. So, first I spent some time getting comfortable with callbacks. Then I jumped onto Promises. And then, after months, I started using Async-await.</p>
<p>Due to this reason, I was exposed to several flow-control methods and practises that evolved around JavaScript; which I would've missed otherwise - simply because of the fact that I wasn't part of that generation.</p>
<p>Just like how our grandparents complain about how easy our generation has it due to the existence of the internet, mobiles, electronic devices, etc. I strongly believe that in the next 2-3 years, we'll complain about how easy the JS newcomers have it since they do not have to deal with callback hell and all the other struggles of the <em>"pre-Promise" era</em>. To them, it'll probably just be a textbook paragraph on the history of JavaScript that no one really cares about; except for the compulsory 1-mark question that is asked from it.</p>
<p>When I was in college, I had no idea what <em>'asynchronous'</em> meant. Coming from the world of C++, PHP, and Java, the word 'asynchronous' was completely alien to me. I had a vague understanding of multi-threading in Java and I dreaded it. I've come a long way from there! üòå</p>
<p>My intention in writing this article is simple. It is my humble attempt to immortalize the evolution of writing in JavaScript before it's too late and forgotten; in a way that even non-JS people can appreciate it. Even if they don't completely understand the specifics, as they're not familiar with JavaScript constructs, I'm trying to keep it so that they can at least get a general idea. Yet, if something doesn't make sense, or you want to talk more about it, feel free to reach out.</p>
<h2 id="heading-events-event-handlers-and-callbacks">Events, event handlers and callbacks.</h2>
<p>This is from pre-historic times. If you have enough experience, you must've come across event-driven systems - Visual Basic, <code>OnClickListener()</code> in Android, <code>onchange</code> behaviour in HTML, etc. Since Node.js is primarily an event-based runtime environment, all it had initially were <em>events</em> and <em>event handlers</em>. Event handlers are just functions that are triggered once a certain event is fired/emitted. Just like the <code>onChange</code> behaviour in HTML.</p>
<blockquote>
<p><em>Simply put, it means something that occurs after an unknown amount of time, so don't expect immediate results.</em></p>
<p><em>For example, "Mom, can I have five dollars?"</em></p>
<p><em>Putting my hand out for money is me expecting her to immediately respond by giving me money (synchronous).</em></p>
<p><em>Realistically, she will look at me for a moment or two, and then decide to respond when she wants to (asynchronous).</em></p>
<p>‚Äî <a target="_blank" href="https://stackoverflow.com/a/4559139/5968979">Kai (StackOverflow)</a></p>
</blockquote>
<p>Due to the asynchronous nature of JS, the system wouldn't wait while, say, you get some data from a database (It was really difficult to wrap my head around and get used to this initially).</p>
<div class="gist-block embed-wrapper" data-gist-show-loading="false" data-id="3d845f4c902adf350d50183955e8f19a"><div class="embed-loading"><div class="loadingRow"></div><div class="loadingRow"></div></div><a href="https://gist.github.com/gaurang847/3d845f4c902adf350d50183955e8f19a" class="embed-card">https://gist.github.com/gaurang847/3d845f4c902adf350d50183955e8f19a</a></div><p> </p>
<p>However, <em>events</em> enable you to put your work on hold when Node.js realises that it is an <em>async task</em> you're performing; and then lets you resume your work when the task has been completed and data is available.</p>
<div class="gist-block embed-wrapper" data-gist-show-loading="false" data-id="ab7a258fff02398450c701b4ca15575a"><div class="embed-loading"><div class="loadingRow"></div><div class="loadingRow"></div></div><a href="https://gist.github.com/gaurang847/ab7a258fff02398450c701b4ca15575a" class="embed-card">https://gist.github.com/gaurang847/ab7a258fff02398450c701b4ca15575a</a></div><p> </p>
<p>In JavaScript, functions can be passed as arguments to other functions and functions can return functions. Such functions are called <a target="_blank" href="https://hackernoon.com/effective-functional-javascript-first-class-and-higher-order-functions-713fde8df50a"><em>higher-order functions</em></a> - similar to how a person who manages other people under him is considered to be at a higher level or position. Thus, a pattern emerged where a function will be passed as the last parameter to an asynchronous function; called a <em>callback function</em>. Under the hood, this function would become the <em>event handler</em> for the concerned event.</p>
<div class="gist-block embed-wrapper" data-gist-show-loading="false" data-id="2309015f37f289f48d9adb3fccce7cd5"><div class="embed-loading"><div class="loadingRow"></div><div class="loadingRow"></div></div><a href="https://gist.github.com/gaurang847/2309015f37f289f48d9adb3fccce7cd5" class="embed-card">https://gist.github.com/gaurang847/2309015f37f289f48d9adb3fccce7cd5</a></div><p> </p>
<h2 id="heading-the-issue-with-callbacks">The issue with callbacks.</h2>
<p>There are hardly any practical applications that may not involve async operations. The advantage of using Node.js is that time-consuming async operations don't affect the performance of your server. The server won't hold off (or <em>starve</em>) one request till another one is completely processed and its response is sent. As soon as Node.js realizes that an async operation is to be performed, it'll delegate a worker process to handle the operation and immediately start processing the next request. This gives a terrific boost to the speed of the system. If your server is getting a lot of requests, and each request requires some async operation (say, database queries), this turns out to be significantly efficient.</p>
<p>However, this efficiency came at a great cost. Writing industry-grade applications with just events, event handlers and callbacks is not easy. <a target="_blank" href="http://callbackhell.com">Callback-hell</a> is the biggest problem with callbacks that leads to decreased code-extensibility, reusability and manageability.</p>
<div class="gist-block embed-wrapper" data-gist-show-loading="false" data-id="1d62d9422476e3bd78993c7d3d10c070"><div class="embed-loading"><div class="loadingRow"></div><div class="loadingRow"></div></div><a href="https://gist.github.com/gaurang847/1d62d9422476e3bd78993c7d3d10c070" class="embed-card">https://gist.github.com/gaurang847/1d62d9422476e3bd78993c7d3d10c070</a></div><p> </p>
<p>Coming from the object-oriented background of Java, I found it very difficult to get used to writing code involving callbacks - how you have to split the code into a separate function, the callback function. The struggle was real during that time.</p>
<p>Frustrated by writing asynchronous code with callbacks, developers started finding creative ways to write better, cleaner code. For example, we used to use <a target="_blank" href="http://async.io">async.io</a> at my workplace. It has utility methods like <a target="_blank" href="https://caolan.github.io/async/v3/docs.html#series"><code>async.series()</code></a>, <a target="_blank" href="https://caolan.github.io/async/v3/docs.html#parallel"><code>async.parallel()</code></a>, <a target="_blank" href="https://caolan.github.io/async/v3/docs.html#waterfall"><code>async.waterfall()</code></a>, etc. <code>async.waterfall()</code> is the most interesting one to me. It lets you chain async functions together so that one function's output is the next function's input - kind of like the human centipede but with functions. üòÖ</p>
<h2 id="heading-promises">Promises</h2>
<p>Promises were introduced in <a target="_blank" href="https://www.ecma-international.org/ecma-262/6.0/#sec-promise-objects">ES6 (2015)</a>. Until then, people only had callbacks. Promises were the next step from callbacks. A major step that brought a revolution in the way we worked with Node.js. Consider it the industrial revolution of JavaScript.</p>
<blockquote>
<p><em>The Promise object represents the eventual completion (or failure) of an asynchronous operation and its resulting value.</em></p>
<p>‚Äî‚Ää<a target="_blank" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise">MDN web docs</a></p>
</blockquote>
<p>A promise is just a wrapper around callbacks. An ingenious wrapper where we make a shift from using functions for storing the next code to using an object. The next function to call (the callback), instead of passing it into a function, we attach it to an object - the promise object. This object is then responsible to pass the callback function as an event handler to the concerned event.</p>
<p>You can instantiate a promise object from any callback-based function. Thus, you can always go from a function-based approach to an object-based one.</p>
<div class="gist-block embed-wrapper" data-gist-show-loading="false" data-id="b2191b7a88547aeaa715f6f0be0268ee"><div class="embed-loading"><div class="loadingRow"></div><div class="loadingRow"></div></div><a href="https://gist.github.com/gaurang847/b2191b7a88547aeaa715f6f0be0268ee" class="embed-card">https://gist.github.com/gaurang847/b2191b7a88547aeaa715f6f0be0268ee</a></div><p> </p>
<p>The significance of this is that your code turns from nested blocks of callbacks to a linear chain of <code>.then</code>-ables.</p>
<div class="gist-block embed-wrapper" data-gist-show-loading="false" data-id="527617922dc4872eb88555f1cf14c9bb"><div class="embed-loading"><div class="loadingRow"></div><div class="loadingRow"></div></div><a href="https://gist.github.com/gaurang847/527617922dc4872eb88555f1cf14c9bb" class="embed-card">https://gist.github.com/gaurang847/527617922dc4872eb88555f1cf14c9bb</a></div><p> </p>
<p>It is a lot easier to make modifications to your code when it is written in a linear sequential manner (the very reason we love synchronous code) than when it is written in nested blocks. Your code instantly becomes readable, predictable and 200x more manageable.</p>
<p>Read this article for more information on Promises:</p>
<div class="embed-wrapper"><div class="embed-loading"><div class="loadingRow"></div><div class="loadingRow"></div></div><a class="embed-card" href="https://medium.com/javascript-scene/master-the-javascript-interview-what-is-a-promise-27fc71e77261">https://medium.com/javascript-scene/master-the-javascript-interview-what-is-a-promise-27fc71e77261</a></div>
<p> </p>
<p>If the Promise object sounded like magic, and you are interested in understanding its internal working, you might be interested in <a target="_blank" href="https://www.mattgreer.org/articles/promises-in-wicked-detail/">this article</a>.</p>
<h2 id="heading-co-routines">Co-routines</h2>
<h4 id="heading-generators">Generators</h4>
<p>Generators were introduced in <a target="_blank" href="https://www.ecma-international.org/ecma-262/6.0/#sec-generator-objects">ES6 (2015)</a> along with promises. But, I believe not many people know about them or use them often. They are functions that return <em>generator objects</em>. A generator object is an <em>iterator</em>. An iterator is anything that implements <a target="_blank" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols"><em>the iterator protocol</em></a>.</p>
<p>The iterator protocol says that an object can be called an <em>iterator</em> if it has the <code>next()</code> method that is supposed to do a very specific job; get the next value of iteration/sequence. If you're familiar with <a target="_blank" href="https://docs.oracle.com/javase/7/docs/api/java/util/Scanner.html">Scanner</a> in Java, it's an Iterator (Although it breaks <a target="_blank" href="https://stackoverflow.com/questions/31153006/why-does-scanner-implement-iteratorstring">Java design principles</a>)</p>
<div class="embed-wrapper"><div class="embed-loading"><div class="loadingRow"></div><div class="loadingRow"></div></div><a class="embed-card" href="https://runkit.com/masquerade817/641219640217950008ba537c">https://runkit.com/masquerade817/641219640217950008ba537c</a></div>
<p> </p>
<p>So, a generator object is basically an object that has this <code>next()</code> method. And generator functions are just functions that return generator objects. If you've ever used <a target="_blank" href="https://www.geeksforgeeks.org/range-vs-xrange-python/"><code>xrange()</code></a> in Python 2.x, that's literally a generator. A very good example of a generator will be a Fibonacci generator.</p>
<div class="gist-block embed-wrapper" data-gist-show-loading="false" data-id="c8cf43e22ed956ecff2fc1c13effea6b"><div class="embed-loading"><div class="loadingRow"></div><div class="loadingRow"></div></div><a href="https://gist.github.com/gaurang847/c8cf43e22ed956ecff2fc1c13effea6b" class="embed-card">https://gist.github.com/gaurang847/c8cf43e22ed956ecff2fc1c13effea6b</a></div><p> </p>
<p>Read the <a target="_blank" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Iterators_and_Generators">Mozilla docs</a> for more information on generators and iterators. Also, this in-detail post on generators on Medium:</p>
<div class="embed-wrapper"><div class="embed-loading"><div class="loadingRow"></div><div class="loadingRow"></div></div><a class="embed-card" href="https://medium.com/dailyjs/a-simple-guide-to-understanding-javascript-es6-generators-d1c350551950">https://medium.com/dailyjs/a-simple-guide-to-understanding-javascript-es6-generators-d1c350551950</a></div>
<p> </p>
<h4 id="heading-co-routines-1">Co-routines</h4>
<p>Now that we know what generators are, we make <em>coroutines</em> simply by adding promises to the mix.</p>
<div class="gist-block embed-wrapper" data-gist-show-loading="false" data-id="a6804f916f570333e6fdf1c764c6c2f9"><div class="embed-loading"><div class="loadingRow"></div><div class="loadingRow"></div></div><a href="https://gist.github.com/gaurang847/a6804f916f570333e6fdf1c764c6c2f9" class="embed-card">https://gist.github.com/gaurang847/a6804f916f570333e6fdf1c764c6c2f9</a></div><p> </p>
<p>Please note that the code has started looking very similar to its synchronous equivalent. It just needs some supplementary parts. To take care of that, people came up with a few coroutine libraries such as <a target="_blank" href="https://github.com/tj/co">CO</a>.</p>
<p>This part might have been pretty difficult to wrap your head around. It is pretty convoluted. But you might want to read this article if you're interested:</p>
<div class="embed-wrapper"><div class="embed-loading"><div class="loadingRow"></div><div class="loadingRow"></div></div><a class="embed-card" href="https://medium.com/front-end-weekly/modern-javascript-and-asynchronous-programming-generators-yield-vs-async-await-550275cbe433">https://medium.com/front-end-weekly/modern-javascript-and-asynchronous-programming-generators-yield-vs-async-await-550275cbe433</a></div>
<p> </p>
<h2 id="heading-asyncawait">Async/await</h2>
<p>Soon, in <a target="_blank" href="https://www.ecma-international.org/ecma-262/8.0/#sec-async-function-definitions">ES8 (2017)</a>, <a target="_blank" href="https://javascript.info/async-await">async-await</a> was announced and that made writing coroutines redundant. Co-routines died out before they could become a thing. Many people today probably don‚Äôt even know about them.</p>
<p>Async-await is just a wrapper around Promises. And again, a promise is just a wrapper around callbacks. So, in reality, promises and async-await are all just glamour. Under the skin, it's still callbacks everywhere! And yet, JS code now looks so clean, intuitive and manageable, that it's orgasmic! 6 years back, nobody would've imagined we could write such clean code in JavaScript.</p>
<div class="gist-block embed-wrapper" data-gist-show-loading="false" data-id="b8deb3befe38434fb977eb78b3d3e54a"><div class="embed-loading"><div class="loadingRow"></div><div class="loadingRow"></div></div><a href="https://gist.github.com/gaurang847/b8deb3befe38434fb977eb78b3d3e54a" class="embed-card">https://gist.github.com/gaurang847/b8deb3befe38434fb977eb78b3d3e54a</a></div><p> </p>
<p>This code looks exactly similar to the synchronous equivalent. And I‚Äôm awe-struck when I think about how much we hated callbacks, and how much we love structure, that it led us from callbacks to async-await. I'm mesmerized by the transitions that happened around Node.js in a such short period and I needed to talk about it.</p>
<p>Now, the code looks really simple. Write your code using functions and when you're going to perform an async task, just use the <code>async</code> and <code>await</code> keywords. Anybody can easily write asynchronous code in JavaScript now. But sometimes, things don't work as expected. Things that look simple often give unexpected results. And without enough understanding of the problem and the inherent system, one can go nuts in the process of debugging such errors. Happened to me once.</p>
<div class="embed-wrapper"><div class="embed-loading"><div class="loadingRow"></div><div class="loadingRow"></div></div><a class="embed-card" href="https://twitter.com/gaurang847/status/1120390303440044033">https://twitter.com/gaurang847/status/1120390303440044033</a></div>
<p> </p>
<div class="embed-wrapper"><div class="embed-loading"><div class="loadingRow"></div><div class="loadingRow"></div></div><a class="embed-card" href="https://twitter.com/gaurang847/status/1120390582239682560">https://twitter.com/gaurang847/status/1120390582239682560</a></div>
<p> </p>
<p>My mentor probably understood that well. And that is why he set me up on this journey to find and feel the true essence of Node.js.</p>
<p>JS-veterans, if you find any inconsistencies in this piece, or would like to add more. Or simply want to talk, feel free to comment or DM me. JS-newbies and JS-virgins, I hope I've sparked an interest in the JS community in your minds. Feel free to reach out in case of any doubts.</p>
]]></content:encoded></item></channel></rss>